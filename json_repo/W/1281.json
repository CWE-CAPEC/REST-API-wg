{"ID":"1281","Name":"Sequence of Processor Instructions Leads to Unexpected Behavior","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"Specific combinations of processor instructions lead to undesirable behavior such as locking the processor until a hard reset performed.","ExtendedDescription":"\n\nIf the instruction set architecture (ISA) and processor logic are not designed carefully and tested thoroughly, certain combinations of instructions may lead to locking the processor or other unexpected and undesirable behavior. Upon encountering unimplemented instruction opcodes or illegal instruction operands, the processor should throw an exception and carry on without negatively impacting security. However, specific combinations of legal and illegal instructions may cause unexpected behavior with security implications such as allowing unprivileged programs to completely lock the CPU. \n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"691","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Processor Hardware","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"Unexpected behavior from certain instruction combinations can arise from bugs in the ISA"},{"Phase":"Implementation","Note":"Unexpected behavior from certain instruction combinations can arise because of implementation details such as speculative execution, caching etc."}],"CommonConsequences":[{"Scope":["Integrity","Availability"],"Impact":["Varies by Context"]}],"PotentialMitigations":[{"Phase":["Testing"],"Description":"Implement a rigorous testing strategy that incorporates randomization to explore instruction sequences that are unlikely to appear in normal workloads in order to identify halt and catch fire instruction sequences."},{"Phase":["Patching and Maintenance"],"Description":"Patch operating system to avoid running Halt and Catch Fire type sequences or to mitigate the damage caused by unexpected behavior. See [REF-1108]."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The Pentium F00F bug is a real-world example of how a sequence of instructions can lock a processor. The \"cmpxchg8b\" instruction compares contents of registers with a memory location. The operand is expected to be a memory location, but in the bad code snippet it is the eax register. Because the specified operand is illegal, an exception is generated, which is the correct behavior and not a security issue in itself. However, when prefixed with the \"lock\" instruction, the processor deadlocks because locked memory transactions require a read and write pair of transactions to occur before the lock on the memory bus is released. The exception causes a read to occur but there is no corresponding write, as there would have been if a legal operand had been supplied to the cmpxchg8b instruction. [REF-1331]"},{"Nature":"Bad","Language":"x86 Assembly","ExampleCode":"lock cmpxchg8b eax"}]},{"Entries":[{"IntroText":"The Cyrix Coma bug was capable of trapping a Cyrix 6x86, 6x86L, or 6x86MX processor in an infinite loop. An infinite loop on a processor is not necessarily an issue on its own, as interrupts could stop the loop. However, on select Cyrix processors, the x86 Assembly 'xchg' instruction was designed to prevent interrupts. On these processors, if the loop was such that a new 'xchg' instruction entered the instruction pipeline before the previous one exited, the processor would become deadlocked. [REF-1323]"}]},{"Entries":[{"IntroText":"The Motorola MC6800 microprocessor contained the first documented instance of a Halt and Catch Fire instruction - an instruction that causes the normal function of a processor to stop. If the MC6800 was given the opcode 0x9D or 0xDD, the processor would begin to read all memory very quickly, in sequence, and without executing any other instructions. This will cause the processor to become unresponsive to anything but a hard reset. [REF-1324]"}]},{"Entries":[{"IntroText":"The example code is taken from the commit stage inside the processor core of the HACK@DAC'19 buggy CVA6 SoC [REF-1342]. To ensure the correct execution of atomic instructions, the CPU must guarantee atomicity: no other device overwrites the memory location between the atomic read starts and the atomic write finishes. Another device may overwrite the memory location only before the read operation or after the write operation, but never between them, and finally, the content will still be consistent."},{"BodyText":"Atomicity is especially critical when the variable to be modified is a mutex, counting semaphore, or similar piece of data that controls access to shared resources. Failure to ensure atomicity may result in two processors accessing a shared resource simultaneously, permanent lock-up, or similar disastrous behavior."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"```\n```\nif (csr_exception_i.valid \u0026\u0026 csr_exception_i.cause[63] \u0026\u0026 commit_instr_i[0].fu != CSR) begin** \n\t```\n\t\t exception_o = csr_exception_i;\n\t\t exception_o.tval = commit_instr_i[0].ex.tval;\n\t end\n```"},{"BodyText":"The above vulnerable code checks for CSR interrupts and gives them precedence over any other exception. However, the interrupts should not occur when the processor runs a series of atomic instructions. In the above vulnerable code, the required check must be included to ensure the processor is not in the middle of a series of atomic instructions."},{"BodyText":"Refrain from interrupting if the intention is to commit an atomic instruction that should not be interrupted. This can be done by adding a condition to check whether the current committing instruction is atomic. [REF-1343]"},{"Nature":"Good","Language":"Verilog","ExampleCode":"```\n```\nif (csr_exception_i.valid \u0026\u0026 csr_exception_i.cause[63] \u0026\u0026 !amo_valid_commit_o \u0026\u0026 commit_instr_i[0].fu != CSR) begin** \n\t```\n\t\t exception_o = csr_exception_i;\n\t\t exception_o.tval = commit_instr_i[0].ex.tval;\n\t end\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2021-26339","Description":"A bug in AMD CPU's core logic allows a potential DoS by using a specific x86 instruction sequence to hang the processor","Link":"https://www.cve.org/CVERecord?id=CVE-2021-26339"},{"Reference":"CVE-1999-1476","Description":"A bug in some Intel Pentium processors allow DoS (hang) via an invalid \"CMPXCHG8B\" instruction, causing a deadlock","Link":"https://www.cve.org/CVERecord?id=CVE-1999-1476"}],"RelatedAttackPatterns":["212"],"References":[{"ExternalReferenceID":"REF-1094","Authors":["Christopher Domas"],"Title":"Breaking the x86 ISA","URL":"https://github.com/xoreaxeaxeax/sandsifter/blob/master/references/domas_breaking_the_x86_isa_wp.pdf"},{"ExternalReferenceID":"REF-1108","Authors":["Intel Corporation"],"Title":"Deep Dive: Retpoline: A Branch Target Injection Mitigation","URL":"https://www.intel.com/content/www/us/en/developer/topic-technology/software-security-guidance/overview.html","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-1323","Title":"Cyrix coma bug","PublicationYear":"2006","PublicationMonth":"03","PublicationDay":"22","Publisher":"Wikipedia","URL":"https://en.wikipedia.org/wiki/Cyrix_coma_bug"},{"ExternalReferenceID":"REF-1324","Authors":["Gary Wheeler"],"Title":"Undocumented M6800 Instructions","PublicationYear":"1977","PublicationMonth":"12","URL":"https://spivey.oriel.ox.ac.uk/wiki/images-corner/1/1a/Undoc6800.pdf","URLDate":"2023-04-20"},{"ExternalReferenceID":"REF-1331","Authors":["Robert R. Collins"],"Title":"The Pentium F00F Bug","PublicationYear":"1998","PublicationMonth":"05","PublicationDay":"01","URL":"https://www.drdobbs.com/embedded-systems/the-pentium-f00f-bug/184410555","URLDate":"2023-04-25"},{"ExternalReferenceID":"REF-1342","Title":"Hackatdac19 commit_stage.sv","PublicationYear":"2019","URL":"https://github.com/HACK-EVENT/hackatdac19/blob/619e9fb0ef32ee1e01ad76b8732a156572c65700/src/commit_stage.sv#L287:L290","URLDate":"2023-06-21"},{"ExternalReferenceID":"REF-1343","Authors":["Florian Zaruba","Michael Schaffner","Stefan Mach","Andreas Traber"],"Title":"commit_stage.sv","PublicationYear":"2018","URL":"https://github.com/openhwgroup/cva6/blob/7951802a0147aedb21e8f2f6dc1e1e9c4ee857a2/src/commit_stage.sv#L296:L301","URLDate":"2023-06-21"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Nicole Fern","SubmissionOrganization":"Cycuity (originally submitted as Tortuga Logic)","SubmissionDate":"2020-05-15","SubmissionVersion":"4.1","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Name, Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Applicable_Platforms, Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Demonstrative_Examples, Description, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Demonstrative_Examples, Mapping_Notes, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Demonstrative_Examples, Observed_Examples"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Pouya Mahmoody, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Rahul Kande, Chen Chen, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Hareesh Khattri","ContributionOrganization":"Intel Corporation","ContributionDate":"2023-06-21","ContributionComment":"contributed to observed example","ContributionType":"Content"},{"Type":"Rename","PreviousEntryName":"Sequence of Processor Instructions Leads to Unexpected Behavior (Halt and Catch Fire)","Date":"2021-07-20"}]}