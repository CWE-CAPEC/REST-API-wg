{"ID":"1191","Name":"On-Chip Debug and Test Interface With Improper Access Control","Abstraction":"Base","Structure":"Simple","Status":"Stable","Description":"The chip does not implement or does not correctly perform access control to check whether users are authorized to access internal registers and test modes through the physical debug/test interface.","ExtendedDescription":"\n\nA device's internal information may be accessed through a scan chain of interconnected internal registers, usually through a JTAG interface. The JTAG interface provides access to these registers in a serial fashion in the form of a scan chain for the purposes of debugging programs running on a device. Since almost all information contained within a device may be accessed over this interface, device manufacturers typically insert some form of authentication and authorization to prevent unintended use of this sensitive information. This mechanism is implemented in addition to on-chip protections that are already present.\n\n\nIf authorization, authentication, or some other form of access control is not implemented or not implemented correctly, a user may be able to bypass on-chip protection mechanisms through the debug interface.\n\n\nSometimes, designers choose not to expose the debug pins on the motherboard. Instead, they choose to hide these pins in the intermediate layers of the board. This is primarily done to work around the lack of debug authorization inside the chip. In such a scenario (without debug authorization), when the debug interface is exposed, chip internals are accessible to an attacker.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"284","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Application Data"],"Likelihood":["High"]},{"Scope":["Confidentiality"],"Impact":["Read Memory"],"Likelihood":["High"]},{"Scope":["Authorization"],"Impact":["Execute Unauthorized Code or Commands"],"Likelihood":["High"]},{"Scope":["Integrity"],"Impact":["Modify Memory"],"Likelihood":["High"]},{"Scope":["Integrity"],"Impact":["Modify Application Data"],"Likelihood":["High"]},{"Scope":["Access Control"],"Impact":["Bypass Protection Mechanism"],"Likelihood":["High"]}],"DetectionMethods":[{"Method":"Dynamic Analysis with Manual Results Interpretation","Description":"\n\nAuthentication and authorization of debug and test interfaces should be part of the architecture and design review process. Withholding of private register documentation from the debug and test interface public specification (\"Security by obscurity\") should not be considered as sufficient security.\n"},{"Method":"Dynamic Analysis with Manual Results Interpretation","Description":"\n\nDynamic tests should be done in the pre-silicon and post-silicon stages to verify that the debug and test interfaces are not open by default.\n"},{"Method":"Fuzzing","Description":"Tests that fuzz Debug and Test Interfaces should ensure that no access without appropriate authentication and authorization is possible.","Effectiveness":"Moderate"}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Strategy":"Separation of Privilege","Description":"If feasible, the manufacturer should disable the JTAG interface or implement authentication and authorization for the JTAG interface. If authentication logic is added, it should be resistant to timing attacks. Security-sensitive data stored in registers, such as keys, etc. should be cleared when entering debug mode.","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"A home, WiFi-router device implements a login prompt which prevents an unauthorized user from issuing any commands on the device until appropriate credentials are provided. The credentials are protected on the device and are checked for strength against attack."},{"Nature":"Bad","Language":"Other","ExampleCode":"If the JTAG interface on this device is not hidden by the manufacturer, the interface may be identified using tools such as JTAGulator. If it is hidden but not disabled, it can be exposed by physically wiring to the board.\n\n\nBy issuing a \"halt\" command before the OS starts, the unauthorized user pauses the watchdog timer and prevents the router from restarting (once the watchdog timer would have expired). Having paused the router, an unauthorized user is able to execute code and inspect and modify data in the device, even extracting all of the router's firmware. This allows the user to examine the router and potentially exploit it."},{"BodyText":"JTAG is useful to chip and device manufacturers during design, testing, and production and is included in nearly every product. Without proper authentication and authorization, the interface may allow tampering with a product."},{"Nature":"Good","Language":"Other","ExampleCode":"In order to prevent exposing the debugging interface, manufacturers might try to obfuscate the JTAG interface or blow device internal fuses to disable the JTAG interface. Adding authentication and authorization to this interface makes use by unauthorized individuals much more difficult."}]},{"Entries":[{"IntroText":"The following example code is a snippet from the JTAG wrapper module in the RISC-V debug module of the HACK@DAC'21 Openpiton SoC [REF-1355]. To make sure that the JTAG is accessed securely, the developers have included a primary authentication mechanism based on a password."},{"BodyText":"The developers employed a Finite State Machine (FSM) to implement this authentication. When a user intends to read from or write to the JTAG module, they must input a password."},{"BodyText":"In the subsequent state of the FSM module, the entered password undergoes Hash-based Message Authentication Code (HMAC) calculation using an internal HMAC submodule. Once the HMAC for the entered password is computed by the HMAC submodule, the FSM transitions to the next state, where it compares the computed HMAC with the expected HMAC for the password."},{"BodyText":"If the computed HMAC matches the expected HMAC, the FSM grants the user permission to perform read or write operations on the JTAG module. [REF-1352]"},{"Nature":"Bad","Language":"Verilog","ExampleCode":"```\n\t...\n\t\tPassChkValid: begin\n\t\t\tif(hashValid) begin\n```\nif(exp_hash == pass_hash) begin** \n\t\t\t\t\n\t\t\t\t```\n```\npass_check = 1'b1;** \n\t\t\t\t **end else begin** \n\t\t\t\t```\n```\npass_check = 1'b0;** \n\t\t\t\t **end\n\t\t\t\t\t state_d = Idle;**  end else begin \n\t\t\t```\n\t\t\t\tstate_d = PassChkValid;\n\t\t\t end\n\t\t end\n\t ...\n```"},{"BodyText":"However, in the given vulnerable part of the code, the JTAG module has not defined a limitation for several continuous wrong password attempts. This omission poses a significant security risk, allowing attackers to carry out brute-force attacks without restrictions."},{"BodyText":"Without a limitation on wrong password attempts, an attacker can repeatedly guess different passwords until they gain unauthorized access to the JTAG module. This leads to various malicious activities, such as unauthorized read from or write to debug module interface."},{"BodyText":"To mitigate the mentioned vulnerability, developers need to implement a restriction on the number of consecutive incorrect password attempts allowed by the JTAG module, which can achieve by incorporating a mechanism that temporarily locks the module after a certain number of failed attempts.[REF-1353][REF-1354]"},{"Nature":"Good","Language":"Verilog","ExampleCode":"```\n\t...\n\t case (state_q) \n\t\tIdle: begin\n\t\t ... \n\t\t\telse if ( (dm::dtm_op_e'(dmi.op) == dm::DTM_PASS) \u0026\u0026 \n```\n(miss_pass_check_cnt_q != 2'b11)**  )\n\t\t\t begin \n\t\t\t```\n\t\t\t\tstate_d = Write;\n\t\t\t\tpass_mode = 1'b1;\n\t\t\t end\n\t\t ...\n\t\t end\n\t\t ...\n\t\tPassChkValid: begin\n\t\t\tif(hashValid) begin\n\t\t\t\tif(exp_hash == pass_hash) begin\n\t\t\t\t\tpass_check = 1'b1;\n\t\t\t\t end else begin \n\t\t\t\t\tpass_check = 1'b0;\n```\nmiss_pass_check_cnt_d = miss_pass_check_cnt_q + 1**  end\n\t\t\t\t state_d = Idle;  end else begin \n\t\t\t```\n\t\t\t\tstate_d = PassChkValid;\n\t\t\t end\n\t\t end\n\t ...\n```"}]},{"Entries":[{"IntroText":"The example code below is taken from the JTAG access control mechanism of the HACK@DAC'21 buggy OpenPiton SoC [REF-1364]. Access to JTAG allows users to access sensitive information in the system. Hence, access to JTAG is controlled using cryptographic authentication of the users. In this example (see the vulnerable code source), the password checker uses HMAC-SHA256 for authentication. It takes a 512-bit secret message from the user, hashes it using HMAC, and compares its output with the expected output to determine the authenticity of the user."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"...\n\n **logic [31-1:0] data_d,**  data_q;\n ...\n\n **logic [512-1:0] pass_data;** \n ...\n\n```\n\t Write: begin\n\t\t ...\n\t\t\t if (pass_mode) begin\n```\npass_data = { {60{8'h00}}, data_d};** \n\t\t\t\t state_d = PassChk;\n\t\t\t\t pass_mode = 1'b0;\n\t\t\t\t ...\n\t\t\t end\n\t ..."},{"BodyText":"The vulnerable code shows an incorrect implementation of the HMAC authentication where it only uses the least significant 32 bits of the secret message for the authentication (the remaining 480 bits are hard coded as zeros). As a result, the system is susceptible to brute-force attacks on the access control mechanism of JTAG, where the attacker only needs to determine 32 bits of the secret message instead of 512 bits."},{"BodyText":"To mitigate this issue, remove the zero padding and use all 512 bits of the secret message for HMAC authentication [REF-1365]."},{"Nature":"Good","Language":"Verilog","ExampleCode":"...\n\n **logic [512-1:0] data_d,**  data_q;\n ...\n logic [512-1:0] pass_data;\n ...\n\n```\n\t Write: begin\n\t\t ...\n\t\t\t if (pass_mode) begin\n```\npass_data = data_d;** \n\t\t\t\t state_d = PassChk;\n\t\t\t\t pass_mode = 1'b0;\n\t\t\t\t ...\n\t\t\t end\n\t ..."}]}],"ObservedExamples":[{"Reference":"CVE-2019-18827","Description":"chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys","Link":"https://www.cve.org/CVERecord?id=CVE-2019-18827"}],"RelatedAttackPatterns":["1","180"],"References":[{"ExternalReferenceID":"REF-1037","Authors":["Kurt Rosenfeld","Ramesh Karri"],"Title":"Attacks and Defenses for JTAG","PublicationYear":"2010","PublicationMonth":"02","URL":"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=\u0026arnumber=5406671"},{"ExternalReferenceID":"REF-1043","Authors":["Gopal Vishwakarma","Wonjun Lee"],"Title":"Exploiting JTAG and Its Mitigation in IOT: A Survey","PublicationYear":"2018","PublicationMonth":"12","PublicationDay":"03","URL":"https://www.mdpi.com/1999-5903/10/12/121/pdf","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-1084","Authors":["Gopal Vishwakarma","Wonjun Lee"],"Title":"JTAG Explained (finally!): Why \"IoT\", Software Security Engineers, and Manufacturers Should Care","URL":"https://www.mdpi.com/1999-5903/10/12/121/pdf","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-1085","Authors":["Bob Molyneaux","Mark McDermott","Anil Sabbavarapu"],"Title":"Design for Testability \u0026 Design for Debug","URL":"http://users.ece.utexas.edu/~mcdermot/vlsi-2/Lecture_17.pdf"},{"ExternalReferenceID":"REF-1355","Authors":["Florian Zaruba"],"Title":"dmi_jtag.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/71103971e8204de6a61afc17d3653292517d32bf/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L192:L204","URLDate":"2023-09-18"},{"ExternalReferenceID":"REF-1354","Authors":["Florian Zaruba"],"Title":"Fix CWE-1191 in dmi_jtag.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/58f984d492fdb0369c82ef10fcbbaa4b9850f9fb/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L200","URLDate":"2023-09-18"},{"ExternalReferenceID":"REF-1353","Authors":["Florian Zaruba"],"Title":"Fix CWE-1191 in dmi_jtag.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/58f984d492fdb0369c82ef10fcbbaa4b9850f9fb/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L131","URLDate":"2023-09-18"},{"ExternalReferenceID":"REF-1352","Authors":["Florian Zaruba"],"Title":"dmi_jtag.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/71103971e8204de6a61afc17d3653292517d32bf/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L118:L204","URLDate":"2023-09-18"},{"ExternalReferenceID":"REF-1364","Title":"dmi_jtag.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/71103971e8204de6a61afc17d3653292517d32bf/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L82","URLDate":"2023-07-15"},{"ExternalReferenceID":"REF-1365","Title":"fix cwe_1205 in dmi_jtag.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/c4f4b832218b50c406dbf9f425d3b654117c1355/piton/design/chip/tile/ariane/src/riscv-dbg/src/dmi_jtag.sv#L158","URLDate":"2023-07-22"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"Notes":[{"Type":"Relationship","Note":"CWE-1191 and CWE-1244 both involve physical debug access, but the weaknesses are different. CWE-1191 is effectively about missing authorization for a debug interface, i.e. JTAG. CWE-1244 is about providing internal assets with the wrong debug access level, exposing the asset to untrusted debug agents."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2019-10-15","SubmissionVersion":"4.0","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-06-25","ModificationComment":"updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Description, Name, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Applicable_Platforms, Demonstrative_Examples, Description, Name, Potential_Mitigations, Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Maintenance_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Potential_Mitigations, Relationship_Notes, Relationships, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Description, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Demonstrative_Examples, References"},{"Type":"Contribution","ContributionName":"Parbati K. Manna","ContributionOrganization":"Intel Corporation","ContributionDate":"2021-10-18","ContributionComment":"provided detection methods","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Narasimha Kumar V Mangipudi","ContributionOrganization":"Lattice Semiconductor","ContributionDate":"2021-10-20","ContributionComment":"reviewed content changes","ContributionType":"Feedback"},{"Type":"Contribution","ContributionName":"Hareesh Khattri","ContributionOrganization":"Intel Corporation","ContributionDate":"2021-10-22","ContributionComment":"clarified differences between CWE-1191 and CWE-1244","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Arun Kanuparthi","ContributionOrganization":"Intel Corporation","ContributionDate":"2021-10-27","ContributionComment":"suggested additional detail in extended description","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Pouya Mahmoody, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Rahul Kande, Chen Chen, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Rename","PreviousEntryName":"Exposed Chip Debug Interface With Insufficient Access Control","Date":"2020-02-26"},{"Type":"Rename","PreviousEntryName":"Exposed Chip Debug and or Test Interface With Insufficient Access Control","Date":"2020-08-20"},{"Type":"Rename","PreviousEntryName":"Exposed Chip Debug and Test Interface With Insufficient or Missing Authorization","Date":"2021-10-28"}]}