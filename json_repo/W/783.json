{"ID":"783","Name":"Operator Precedence Logic Error","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The product uses an expression in which operator precedence causes incorrect logic to be used.","ExtendedDescription":"While often just a bug, operator precedence logic errors can have serious consequences if they are used in security-critical code, such as making an authentication decision.","LikelihoodOfExploit":"Low","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"670","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Rarely"},{"Type":"Language","Name":"C++","Prevalence":"Rarely"},{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Rarely"}],"ModesOfIntroduction":[{"Phase":"Implementation","Note":"Logic errors related to operator precedence may cause problems even during normal operation, so they are probably discovered quickly during the testing phase. If testing is incomplete or there is a strong reliance on manual review of the code, then these errors may not be discovered before the software is deployed."}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability"],"Impact":["Varies by Context","Unexpected State"],"Note":"The consequences will vary based on the context surrounding the incorrect precedence. In a security decision, integrity or confidentiality are the most likely results. Otherwise, a crash may occur due to the software reaching an unexpected state."}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Regularly wrap sub-expressions in parentheses, especially in security-critical code."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"In the following example, the method validateUser makes a call to another method to authenticate a username and password for a user and returns a success or failure code."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t#define FAIL 0\n\t#define SUCCESS 1\n\t...\n\tint validateUser(char *username, char *password) {\n\t\t\tint isUser = FAIL;\n```\n// call method to authenticate username and password* \n\t\t\t\n\t\t\t\n\t\t\t *// if authentication fails then return failure otherwise return success* \n\t\t\tif (isUser = AuthenticateUser(username, password) == FAIL) {\n\t\t\t```\n\t\t\t\treturn isUser;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tisUser = SUCCESS;\n\t\t\t}\n\t\t\treturn isUser;\n\t}\n```"},{"BodyText":"However, the method that authenticates the username and password is called within an if statement with incorrect operator precedence logic. Because the comparison operator \"==\" has a higher precedence than the assignment operator \"=\", the comparison operator will be evaluated first and if the method returns FAIL then the comparison will be true, the return variable will be set to true and SUCCESS will be returned. This operator precedence logic error can be easily resolved by properly using parentheses within the expression of the if statement, as shown below."},{"Nature":"Good","Language":"C","ExampleCode":"```\n\t...\n\tif ((isUser = AuthenticateUser(username, password)) == FAIL) {\n\t...\n```"}]},{"Entries":[{"IntroText":"In this example, the method calculates the return on investment for an accounting/financial application. The return on investment is calculated by subtracting the initial investment costs from the current value and then dividing by the initial investment costs."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tpublic double calculateReturnOnInvestment(double currentValue, double initialInvestment) {\n\t\t\tdouble returnROI = 0.0;\n```\n// calculate return on investment* \n\t\t\treturnROI = currentValue - initialInvestment / initialInvestment;\n\t\t\t\n\t\t\treturn returnROI;}"},{"BodyText":"However, the return on investment calculation will not produce correct results because of the incorrect operator precedence logic in the equation. The divide operator has a higher precedence than the minus operator, therefore the equation will divide the initial investment costs by the initial investment costs which will only subtract one from the current value. Again this operator precedence logic error can be resolved by the correct use of parentheses within the equation, as shown below."},{"Nature":"Good","Language":"Java","ExampleCode":"```\n\t...\n\treturnROI = (currentValue - initialInvestment) / initialInvestment;\n\t...\n```"},{"BodyText":"Note that the initialInvestment variable in this example should be validated to ensure that it is greater than zero to avoid a potential divide by zero error (CWE-369)."}]}],"ObservedExamples":[{"Reference":"CVE-2008-2516","Description":"Authentication module allows authentication bypass because it uses \"(x = call(args) == SUCCESS)\" instead of \"((x = call(args)) == SUCCESS)\".","Link":"https://www.cve.org/CVERecord?id=CVE-2008-2516"},{"Reference":"CVE-2008-0599","Description":"Chain: Language interpreter calculates wrong buffer size (CWE-131) by using \"size = ptr ? X : Y\" instead of \"size = (ptr ? X : Y)\" expression.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-0599"},{"Reference":"CVE-2001-1155","Description":"Chain: product does not properly check the result of a reverse DNS lookup because of operator precedence (CWE-783), allowing bypass of DNS-based access restrictions.","Link":"https://www.cve.org/CVERecord?id=CVE-2001-1155"}],"TaxonomyMappings":[{"TaxonomyName":"CERT C Secure Coding","EntryID":"EXP00-C","EntryName":"Use parentheses for precedence of operation","MappingFit":"Exact"},{"TaxonomyName":"SEI CERT Perl Coding Standard","EntryID":"EXP04-PL","EntryName":"Do not mix the early-precedence logical operators with late-precedence logical operators","MappingFit":"CWE More Abstract"}],"References":[{"ExternalReferenceID":"REF-704","Authors":["CERT"],"Title":"EXP00-C. Use parentheses for precedence of operation","URL":"https://www.securecoding.cert.org/confluence/display/seccode/EXP00-C.+Use+parentheses+for+precedence+of+operation"},{"ExternalReferenceID":"REF-62","Section":"Chapter 6, \"Precedence\", Page 287","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2009-07-16","SubmissionVersion":"1.5","SubmissionReleaseDate":"2009-07-27"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-12-28","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-27","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Taxonomy_Mappings, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-12-11","ModificationComment":"updated Detection_Factors, Weakness_Ordinalities","ModificationVersion":"4.19","ModificationReleaseDate":"2025-12-11"}]}