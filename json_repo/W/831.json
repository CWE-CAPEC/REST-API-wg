{"ID":"831","Name":"Signal Handler Function Associated with Multiple Signals","Abstraction":"Variant","Structure":"Simple","Status":"Incomplete","Description":"The product defines a function that is used as a handler for more than one signal.","ExtendedDescription":"\n\nWhile sometimes intentional and safe, when the same function is used to handle multiple signals, a race condition could occur if the function uses any state outside of its local declaration, such as global variables or non-reentrant functions, or has any side effects.\n\n\nAn attacker could send one signal that invokes the handler function; in many OSes, this will typically prevent the same signal from invoking the handler again, at least until the handler function has completed execution. However, the attacker could then send a different signal that is associated with the same handler function. This could interrupt the original handler function while it is still executing. If there is shared state, then the state could be corrupted. This can lead to a variety of potential consequences depending on context, including denial of service and code execution.\n\n\nAnother rarely-explored possibility arises when the signal handler is only designed to be executed once (if at all). By sending multiple signals, an attacker could invoke the function more than once. This may generate extra, unintended side effects. A race condition might not even be necessary; the attacker could send one signal, wait until it is handled, then send the other signal.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"364","ViewID":"1000","Ordinal":"Primary"}],"CommonConsequences":[{"Scope":["Availability","Integrity","Confidentiality","Access Control","Other"],"Impact":["DoS: Crash, Exit, or Restart","Execute Unauthorized Code or Commands","Read Application Data","Gain Privileges or Assume Identity","Bypass Protection Mechanism","Varies by Context"],"Note":"The most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit. However, if the signal handler is operating on state variables for security relevant libraries or protection mechanisms, the consequences can be far more severe, including protection mechanism bypass, privilege escalation, or information exposure."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"This code registers the same signal handler function with two different signals."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tvoid handler (int sigNum) {\n\t\t...\n\t}\n\tint main (int argc, char* argv[]) {\n\t\tsignal(SIGUSR1, handler)\n\t\tsignal(SIGUSR2, handler)\n\t}\n```"}]},{"ID":"DX-26","Entries":[{"IntroText":"This code registers the same signal handler function with two different signals (CWE-831). If those signals are sent to the process, the handler creates a log message (specified in the first argument to the program) and exits."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar *logMessage;\n\tvoid handler (int sigNum) {\n\t\t\tsyslog(LOG_NOTICE, \"%s\\n\", logMessage);\n\t\t\tfree(logMessage);\n```\n/* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);\n\t\t\texit(0);}\n\t\n\tint main (int argc, char* argv[]) {\n\t```\n\t\t\tlogMessage = strdup(argv[1]);\n```\n/* Register signal handlers. */* \n\t\t\t\n\t\t\tsignal(SIGHUP, handler);\n\t\t\tsignal(SIGTERM, handler);\n\t\t\t\n\t\t\t */* artificially increase the size of the timing window to make demonstration of this weakness easier. */* \n\t\t\t\n\t\t\tsleep(10);}"},{"BodyText":"The handler function uses global state (globalVar and logMessage), and it can be called by both the SIGHUP and SIGTERM signals. An attack scenario might follow these lines:"},{"BodyText":"- The program begins execution, initializes logMessage, and registers the signal handlers for SIGHUP and SIGTERM.\n\n  - The program begins its \"normal\" functionality, which is simplified as sleep(), but could be any functionality that consumes some time.\n\n  - The attacker sends SIGHUP, which invokes handler (call this \"SIGHUP-handler\").\n\n  - SIGHUP-handler begins to execute, calling syslog().\n\n  - syslog() calls malloc(), which is non-reentrant. malloc() begins to modify metadata to manage the heap.\n\n  - The attacker then sends SIGTERM.\n\n  - SIGHUP-handler is interrupted, but syslog's malloc call is still executing and has not finished modifying its metadata.\n\n  - The SIGTERM handler is invoked.\n\n  - SIGTERM-handler records the log message using syslog(), then frees the logMessage variable."},{"BodyText":"At this point, the state of the heap is uncertain, because malloc is still modifying the metadata for the heap; the metadata might be in an inconsistent state. The SIGTERM-handler call to free() is assuming that the metadata is inconsistent, possibly causing it to write data to the wrong location while managing the heap. The result is memory corruption, which could lead to a crash or even code execution, depending on the circumstances under which the code is running."},{"BodyText":"Note that this is an adaptation of a classic example as originally presented by Michal Zalewski [REF-360]; the original example was shown to be exploitable for code execution."},{"BodyText":"Also note that the strdup(argv[1]) call contains a potential buffer over-read (CWE-126) if the program is called without any arguments, because argc would be 0, and argv[1] would point outside the bounds of the array."}]}],"References":[{"ExternalReferenceID":"REF-360","Authors":["Michal Zalewski"],"Title":"Delivering Signals for Fun and Profit","URL":"https://lcamtuf.coredump.cx/signals.txt","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-361","Title":"Race Condition: Signal Handling","URL":"https://vulncat.fortify.com/en/detail?id=desc.structural.cpp.race_condition_signal_handling#:~:text=Signal%20handling%20race%20conditions%20can,installed%20to%20handle%20multiple%20signals.s","URLDate":"2023-04-07"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2010-12-12","SubmissionVersion":"1.11","SubmissionReleaseDate":"2010-12-13"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-27","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-06-23","ModificationComment":"updated Demonstrative_Examples, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Common_Consequences, Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated References, Relationships, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}