{"ID":"1221","Name":"Incorrect Register Defaults or Module Parameters","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"Hardware description language code incorrectly defines register defaults or hardware Intellectual Property (IP) parameters to insecure values.","ExtendedDescription":"\n\nIntegrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. Hardware descriptive languages also support definition of parameter variables, which can be defined in code during instantiation of the hardware IP module. Such parameters are generally used to configure a specific instance of a hardware IP in the design.\n\n\nThe system security settings of a hardware design can be affected by incorrectly defined default values or IP parameters. The hardware IP would be in an insecure state at power reset, and this can be exposed or exploited by untrusted software running on the system. Both register defaults and parameters are hardcoded values, which cannot be changed using software or firmware patches but must be changed in hardware silicon. Thus, such security issues are considerably more difficult to address later in the lifecycle. Hardware designs can have a large number of such parameters and register defaults settings, and it is important to have design tool support to check these settings in an automated way and be able to identify which settings are security sensitive.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"1419","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"Verilog","Prevalence":"Undetermined"},{"Type":"Language","Name":"VHDL","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation","Note":"Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases."}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability","Access Control"],"Impact":["Varies by Context"],"Note":"Degradation of system functionality, or loss of access control enforcement can occur."}],"DetectionMethods":[{"Method":"Automated Analysis","Description":"Use automated tools to test that values are configured per design specifications."}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"During hardware design, all the system parameters and register defaults must be reviewed to identify security sensitive settings."},{"Phase":["Implementation"],"Description":"The default values of these security sensitive settings need to be defined as part of the design review phase."}],"DemonstrativeExamples":[{"ID":"DX-162","Entries":[{"IntroText":"Consider example design module system verilog code shown below. The register_example module is an example parameterized module that defines two parameters, REGISTER_WIDTH and REGISTER_DEFAULT. Register_example module defines a Secure_mode setting, which when set makes the register content read-only and not modifiable by software writes. register_top module instantiates two registers, Insecure_Device_ID_1 and Insecure_Device_ID_2. Generally, registers containing device identifier values are required to be read only to prevent any possibility of software modifying these values."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"// Parameterized Register module example \n // Secure_mode : REGISTER_DEFAULT[0] : When set to 1 register is read only and not writable// \n module register_example \n #( \n parameter REGISTER_WIDTH = 8, // Parameter defines width of register, default 8 bits \n parameter [REGISTER_WIDTH-1:0] REGISTER_DEFAULT = 2**REGISTER_WIDTH -2 // Default value of register computed from Width. Sets all bits to 1s except bit 0 (Secure _mode) \n ) \n ( \n input [REGISTER_WIDTH-1:0] Data_in, \n input Clk, \n input resetn, \n input write, \n output reg [REGISTER_WIDTH-1:0] Data_out \n ); \n\n reg Secure_mode; \n\n always @(posedge Clk or negedge resetn) \n\n```\n\t if (~resetn) \n\t begin \n\t\t Data_out \u003c= REGISTER_DEFAULT; // Register content set to Default at reset \n\t\t Secure_mode \u003c= REGISTER_DEFAULT[0]; // Register Secure_mode set at reset \n\t end \n\t else if (write \u0026 ~Secure_mode) \n\t begin \n\t\t Data_out \u003c= Data_in; \n\t end \n endmodule \n module register_top \n ( \n input Clk, \n input resetn, \n input write, \n input [31:0] Data_in, \n output reg [31:0] Secure_reg, \n output reg [31:0] Insecure_reg \n ); \n register_example #( \n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1224) // Incorrect Default value used bit 0 is 0. \n ) Insecure_Device_ID_1 ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n register_example #(\n\t .REGISTER_WIDTH (32) // Default not defined 2^32-2 value will be used as default. \n ) Insecure_Device_ID_2 ( \n\t .Data_in (Data_in), \n\t .Data_out (Insecure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n endmodule \n```"},{"BodyText":"These example instantiations show how, in a hardware design, it would be possible to instantiate the register module with insecure defaults and parameters."},{"BodyText":"In the example design, both registers will be software writable since Secure_mode is defined as zero."},{"Nature":"Good","Language":"Verilog","ExampleCode":"register_example #( \n\n```\n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1225) // Correct default value set, to enable Secure_mode \n ) Secure_Device_ID_example ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n );\n```"}]},{"Entries":[{"IntroText":"The example code is taken from the fuse memory inside the buggy OpenPiton SoC of HACK@DAC'21 [REF-1356]. Fuse memory can be used to store key hashes, password hashes, and configuration information. For example, the password hashes of JTAG and HMAC are stored in the fuse memory in the OpenPiton design."},{"BodyText":"During the firmware setup phase, data in the Fuse memory are transferred into the registers of the corresponding SoC peripherals for initialization. However, if the offset to access the password hash is set incorrectly, programs cannot access the correct password hash from the fuse memory, breaking the functionalities of the peripherals and even exposing sensitive information through other peripherals."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"**parameter MEM_SIZE = 100;** \n\n **localparam JTAG_OFFSET = 81;** \n\n const logic [MEM_SIZE-1:0][31:0] mem = {\n\n```\n\t // JTAG expected hamc hash\n\t 32'h49ac13af, 32'h1276f1b8, 32'h6703193a, 32'h65eb531b,\n\t 32'h3025ccca, 32'h3e8861f4, 32'h329edfe5, 32'h98f763b4,\n ...\n assign jtag_hash_o = {mem[JTAG_OFFSET-1],mem[JTAG_OFFSET-2],mem[JTAG_OFFSET-3],\n mem[JTAG_OFFSET-4],mem[JTAG_OFFSET-5],mem[JTAG_OFFSET-6],mem[JTAG_OFFSET-7],mem[JTAG_OFFSET-8]};\n ...\n```"},{"BodyText":"The following vulnerable code accesses the JTAG password hash from the fuse memory. However, the JTAG_OFFSET is incorrect, and the fuse memory outputs the wrong values to jtag_hash_o. Moreover, setting incorrect offset gives the ability to attackers to access JTAG by knowing other low-privileged peripherals' passwords."},{"BodyText":"To mitigate this, change JTAG_OFFSET to the correct address of the JTAG key [REF-1357]."},{"Nature":"Good","Language":"Verilog","ExampleCode":"parameter MEM_SIZE = 100;\n\n **localparam JTAG_OFFSET = 100;**"}]},{"ID":"DX-222","Entries":[{"IntroText":"The following example code is excerpted from the Access Control module, acct_wrapper, in the Hack@DAC'21 buggy OpenPiton System-on-Chip (SoC). Within this module, a set of memory-mapped I/O registers, referred to as acct_mem, each 32-bit wide, is utilized to store access control permissions for peripherals [REF-1437]. Access control registers are typically used to define and enforce permissions and access rights for various system resources."},{"BodyText":"However, in the buggy SoC, these registers are all enabled at reset, i.e., essentially granting unrestricted access to all system resources [REF-1438]. This will introduce security vulnerabilities and risks to the system, such as privilege escalation or exposing sensitive information to unauthorized users or processes."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module acct_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~rst_6))\n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j \u003c AcCt_MEM_SIZE; j=j+1)\n\t\t\t\t\t\t begin\n```\nacct_mem[j] \u003c= 32'hffffffff;** \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\t\t ..."},{"BodyText":"To fix this issue, the access control registers must be properly initialized during the reset phase of the SoC. Correct initialization values should be established to maintain the system's integrity, security, predictable behavior, and allow proper control of peripherals. The specifics of what values should be set depend on the SoC's design and the requirements of the system. To address the problem depicted in the bad code example [REF-1438], the default value for \"acct_mem\" should be set to 32'h00000000 (see good code example [REF-1439]). This ensures that during startup or after any reset, access to protected data is restricted until the system setup is complete and security procedures properly configure the access control settings."},{"Nature":"Good","Language":"Verilog","ExampleCode":"module acct_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~rst_6)) \n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j \u003c AcCt_MEM_SIZE; j=j+1)\n\t\t\t\t\t\t begin\n```\nacct_mem[j] \u003c= 32'h00000000;** \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\t\t ..."}]}],"RelatedAttackPatterns":["166"],"References":[{"ExternalReferenceID":"REF-1356","Title":"fuse_mem.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/main/piton/design/chip/tile/ariane/src/fuse_mem/fuse_mem.sv#L14-L15","URLDate":"2023-07-15"},{"ExternalReferenceID":"REF-1357","Title":"fix CWE 1221 in fuse_mem.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/compare/main...cwe_1221_in_fuse_mem#diff-d7275edeac22f76691a31c83f005d0177359ad710ad6549ece3d069ed043ef21","URLDate":"2023-07-24"},{"ExternalReferenceID":"REF-1437","Title":"acct_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/65d0ffdab7426da4509c98d62e163bcce642f651/piton/design/chip/tile/ariane/src/acct/acct_wrapper.sv#L39"},{"ExternalReferenceID":"REF-1438","Title":"Bad Code acct_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/65d0ffdab7426da4509c98d62e163bcce642f651/piton/design/chip/tile/ariane/src/acct/acct_wrapper.sv#L79C1-L86C16"},{"ExternalReferenceID":"REF-1439","Title":"Good Code acct_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/062de4f25002d2dcbdb0a82af36b80a517592612/piton/design/chip/tile/ariane/src/acct/acct_wrapper.sv#L84"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2019-12-12","SubmissionVersion":"4.0","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Demonstrative_Examples, Description, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-02-29","ModificationComment":"updated Demonstrative_Examples","ModificationVersion":"4.14","ModificationReleaseDate":"2024-02-29"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-07-16","ModificationComment":"updated Demonstrative_Examples, References","ModificationVersion":"4.15","ModificationReleaseDate":"2024-07-16"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-12-11","ModificationComment":"updated Detection_Factors, Potential_Mitigations, Weakness_Ordinalities","ModificationVersion":"4.19","ModificationReleaseDate":"2025-12-11"},{"Type":"Contribution","ContributionName":"Chen Chen, Rahul Kande, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Chen Chen, Rahul Kande, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"}]}