{"ID":"1429","Name":"Missing Security-Relevant Feedback for Unexecuted Operations in Hardware Interface","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product has a hardware interface that silently discards operations\n\t\t\tin situations for which feedback would be security-relevant, such as\n\t\t\tthe timely detection of failures or attacks.","ExtendedDescription":"\n\nWhile some systems intentionally withhold feedback as a security measure, this approach must be strictly controlled to ensure it does not obscure operational failures that require prompt detection and remediation. Without these essential confirmations, failures go undetected, increasing the risk of data loss, security vulnerabilities, and overall system instability. Even when withholding feedback is an intentional part of a security policy designed, for example, to prevent attackers from gleaning sensitive internal details, the absence of expected feedback becomes a critical weakness when it masks operational failures that require prompt detection and remediation.\n\n\nFor instance, certain encryption algorithms always return ciphertext regardless of errors to prevent attackers from gaining insight into internal state details. However, if such an algorithm fails to generate the expected ciphertext and provides no error feedback, the system cannot distinguish between a legitimate output and a malfunction. This can lead to undetected cryptographic failures, potentially compromising data security and system reliability. Without proper notification, a critical failure might remain hidden, undermining both the reliability and security of the process.\n\n\nTherefore, this weakness captures issues across various hardware interfaces where operations are discarded without any feedback, error handling, or logging. Such omissions can lead to data loss, security vulnerabilities, and system instability, with potential impacts ranging from minor to catastrophic.\n\n\nFor some kinds of hardware products, some errors may be correctly identified and subsequently discarded, and the lack of feedback may have been an intentional design decision. However, this could result in a weakness if system operators or other authorized entities are not provided feedback about security-critical operations or failures that could prevent the operators from detecting and responding to an attack.\n\n\nFor example:\n\n\n  - In a System-on-Chip (SoC) platform, write operations to reserved memory addresses might be correctly identified as invalid and subsequently discarded. However, if no feedback is provided to system operators, they may misinterpret the device's state, failing to recognize conditions that could lead to broader failures or security vulnerabilities. For example, if an attacker attempts unauthorized writes to protected regions, the system may silently discard these writes without alerting security mechanisms. This lack of feedback could obscure intrusion attempts or misconfigurations, increasing the risk of unnoticed system compromise\n\n  - Microcontroller Interrupt Systems: When interrupts are silently ignored due to priority conflicts or internal errors without notifying higher-level control, it becomes challenging to diagnose system failures or detect potential security breaches in a timely manner.\n\n  - Network Interface Controllers: Dropping packets - perhaps due to buffer overflows - without any error feedback can not only cause data loss but may also contribute to exploitable timing discrepancies that reveal sensitive internal processing details.\n\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"223","ViewID":"1000","Ordinal":"Primary"},{"Nature":"PeerOf","CweID":"392","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"},{"Type":"Language","Name":"Verilog","Prevalence":"Undetermined"},{"Type":"Language","Class":"Hardware Description Language","Prevalence":"Undetermined"},{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Name":"ARM","Prevalence":"Undetermined"},{"Type":"Architecture","Name":"x86","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Embedded","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Security Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Processor Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Microcontroller Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Class":"System on Chip","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"\n\nThis weakness can be introduced during the architecture and design phase when the system does not incorporate proper mechanisms for error reporting or feedback for discarded operations, such as when handling reserved addresses or unexecuted instructions.\n"},{"Phase":"Implementation","Note":"\n\nIt can also arise during implementation if developers fail to include appropriate feedback or logging for critical operations. This leads to silent failures in certain scenarios like interrupt handling or network buffer overflows.\n"},{"Phase":"Requirements","Note":"\n\nA further layer of complexity emerges when considering specifications. The weakness may stem either from ambiguous product design specifications that fail to delineate when feedback should occur or from implementations that do not adhere to existing requirements. In either case, the result is the same: feedback that is critical for detecting operational failures or security breaches is missing.\n"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory","Read Files or Directories"],"Likelihood":["Medium"],"Note":"\n\nCritical data may be exposed if operations are unexecuted or discarded silently, allowing attackers to exploit the lack of feedback.\n"},{"Scope":["Integrity"],"Impact":["Modify Memory","Modify Files or Directories"],"Likelihood":["Medium"],"Note":"\n\nOperations may proceed based on incorrect assumptions, potentially causing data corruption or incorrect system behavior. In integrity-sensitive contexts, failing to signal that an operation did not occur as expected can mask errors that disrupt data consistency. Without feedback, the mitigation measures that should ensure updates have been performed cannot be verified, leaving the system vulnerable to both accidental and malicious data alterations\n"},{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (Memory)","DoS: Crash, Exit, or Restart"],"Likelihood":["High"],"Note":"\n\nUnhandled discarded operations can lead to resource exhaustion, triggering system crashes or denial of service. For availability, consistent feedback is crucial. Without proper notification of discarded operations, administrators or other authorized entities might miss early warning signs of resource imbalances. This delayed detection could allow a DoS condition to develop, compromising the system's ability to serve legitimate requests and maintain continuous operations.\n"}],"DetectionMethods":[{"Method":"Automated Static Analysis - Source Code","Description":"\n\nScans code for missing error handling or feedback mechanisms.\n","Effectiveness":"High","EffectivenessNotes":"\n\nThis identify common issues early in the development phase.\n"},{"Method":"Manual Static Analysis - Source Code","Description":"\n\nExperts manually inspect the code for unhandled operations.\n","Effectiveness":"Moderate","EffectivenessNotes":"\n\nUseful for identifying design-level omissions.\n"}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"\n\nIncorporate logging and feedback mechanisms during the design phase to ensure proper handling of discarded operations.\n","Effectiveness":"High","EffectivenessNotes":"\n\nAddressing the issue at the design stage prevents the weakness from manifesting later.\n"},{"Phase":["Implementation"],"Description":"\n\nDevelopers should ensure that every critical operation includes proper logging or error feedback mechanisms.\n","Effectiveness":"Moderate","EffectivenessNotes":"\n\nImplementation-level checks complement design-phase measures.\n"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"This code creates an interrupt handler. If the interrupt's priority is lower than the currently active one, the interrupt is discarded without any feedback, perhaps due to resource constraints."},{"Nature":"Bad","Language":"C","ExampleCode":"void interrupt_handler(int irq) {\n\n```\n\t if (irq_priority[irq] \u003c current_priority) {\n\t\t return;\n\t }\n\t process_interrupt(irq);\n }\n```"},{"BodyText":"The omission of feedback for the dropped lower-priority interrupt can cause developers to misinterpret the state of the system, leading to incorrect assumptions and potential system failures, such as missed sensor readings.\n\n\nAttackers might leverage this lack of visibility to induce conditions that lead to timing side-channels. For example, an attacker could intentionally flood the system with high-priority interrupts, forcing the system to discard lower-priority interrupts consistently. If these discarded interrupts correspond to processes executing critical security functions (e.g., cryptographic key handling), an attacker might measure system timing variations to infer when and how those functions are executing. This creates a timing side channel that could be used to extract sensitive information. Moreover, since these lower-priority interrupts are not reported, the system remains unaware that critical tasks such as sensor data collection or maintenance routines, are being starved of execution. Over time, this can lead to functional failures or watchdog time resets in real-time systems.\n\n\nOne way to address this problem could be to use structured logging to provide visibility into discarded interrupts. This allows administrators, developers, or other authorized entities to track missed interrupts and optimize the system."},{"Nature":"Good","Language":"C","ExampleCode":"// Priority threshold for active interrupts\n int current_priority = 3;\n // Simulated priority levels for different IRQs\n int irq_priority[5] = {1, 2, 3, 4, 5};\n void process_interrupt(int irq) {\n\n```\n\t printf(\"Processing interrupt %d\\n\", irq);\n }\n void interrupt_handler(int irq) {\n\t if (irq_priority[irq] \u003c current_priority) {\n\t\t // Log the dropped interrupt using structured feedback\n\t\t fprintf(stderr, \"Warning: Interrupt %d dropped (Priority: %d \u003c Current: %d)\\n\", \n\t\t\t irq, irq_priority[irq], current_priority);\n\t\t exit(EXIT_FAILURE); // Exit with failure status to indicate a critical issue.\n\t }\n\t process_interrupt(irq);\n }\n```"}]},{"Entries":[{"IntroText":"Consider a SoC design with these component IPs:\n\n\nIP 1. Execution Core \u003c--\u003e IP 2 SoC Fabric (NoC, tile etc. ) \u003c--\u003e IP 3 Memory Controller \u003c--\u003e External/ internal memory.\n\n\nThe Core executes operations that trigger transactions that traverse the HW fabric links to read/write to the final memory module.\n\n\nThere can be unexpected errors in each link. For adding reliability and redundance, features like ECCs are used in these transactions. Error correction capabilities have to define how many error bits can be detected and which errors can be corrected, and which are uncorrectable errors. In design, often the severity level and response on different errors is allowed to be configured by system firmware modules like BIOS."},{"Nature":"Bad","ExampleCode":"If an uncorrectable error occurs, the design does not explicitly trigger an alert back to the execution core."},{"BodyText":"For system security, if an uncorrectable error occurs but is not reported to the execution core and handled before the core attempts to consume the data that is read/written through the corrupted transactions, then this could enable silent data corruption (SDC) attacks.\n\n\nIn the case of confidential compute technologies where system firmware is not a trusted component, error handling controls can be misconfigured to trigger this weakness and attack the assets protected by confidential compute."},{"Nature":"Good","ExampleCode":"Modify the design so that any uncorrectable error triggers an alert back to the execution core and gets handled before the core can consume the data read/written through the corrupted transactions. Update design access control policies to ensure that alerts sent to execution core on uncorrectable errors cannot be disabled or masked by untrusted software/firmware."}]}],"ObservedExamples":[{"Reference":"[REF-1468]","Description":"Open source silicon root of trust (RoT) product does not immediately report when an integrity check fails for memory requests, causing the product to accept and continue processing data [REF-1468]","Link":"https://github.com/lowRISC/opentitan/issues/11336"}],"References":[{"ExternalReferenceID":"REF-1468","Authors":["GregAC"],"Title":"OpenTitan issue: [rv_core_ibex] Bus errors on integrity check failure","PublicationYear":"2022","PublicationMonth":"03","PublicationDay":"09","URL":"https://github.com/lowRISC/opentitan/issues/11336","URLDate":"2025-04-02"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Amisha Srivastava","SubmissionOrganization":"University of Texas at Dallas","SubmissionDate":"2023-12-20","SubmissionVersion":"4.17","SubmissionReleaseDate":"2025-04-03"},{"Type":"Contribution","ContributionName":"Hareesh Khattri","ContributionOrganization":"Intel Corporation","ContributionDate":"2025-03-25","ContributionComment":"Contributed an observed example and a demonstrative example.","ContributionType":"Content","ContributionVersion":"4.17","ContributionReleaseDate":"2025-04-03"}]}