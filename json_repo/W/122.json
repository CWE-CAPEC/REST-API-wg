{"ID":"122","Name":"Heap-based Buffer Overflow","Abstraction":"Variant","Structure":"Simple","Status":"Draft","Description":"A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().","LikelihoodOfExploit":"High","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"788","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"787","ViewID":"1000"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Crash, Exit, or Restart","DoS: Resource Consumption (CPU)","DoS: Resource Consumption (Memory)"],"Note":"Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."},{"Scope":["Integrity","Confidentiality","Availability","Access Control"],"Impact":["Execute Unauthorized Code or Commands","Bypass Protection Mechanism","Modify Memory"],"Note":"Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Besides important user data, heap-based overflows can be used to overwrite function pointers that may be living in memory, pointing it to the attacker's code. Even in applications that do not explicitly use function pointers, the run-time will usually leave many in memory. For example, object methods in C++ are generally implemented using function pointers. Even in C programs, there is often a global offset table used by the underlying runtime."},{"Scope":["Integrity","Confidentiality","Availability","Access Control","Other"],"Impact":["Execute Unauthorized Code or Commands","Bypass Protection Mechanism","Other"],"Note":"When the consequence is arbitrary code execution, this can often be used to subvert any other security service."}],"DetectionMethods":[{"DetectionMethodID":"DM-13","Method":"Fuzzing","Description":"Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.","Effectiveness":"High"}],"PotentialMitigations":[{"Description":"Pre-design: Use a language or compiler that performs automatic bounds checking."},{"Phase":["Architecture and Design"],"Description":"Use an abstraction library to abstract away risky APIs. Not a complete solution."},{"MitigationID":"MIT-10","Phase":["Operation","Build and Compilation"],"Strategy":"Environment Hardening","Description":"\n\nUse automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. \n\n\n D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"\n\n This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. \n"},{"MitigationID":"MIT-11","Phase":["Operation","Build and Compilation"],"Strategy":"Environment Hardening","Description":"\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]"},{"Phase":["Implementation"],"Description":"Implement and perform bounds checking on input."},{"Phase":["Implementation"],"Strategy":"Libraries or Frameworks","Description":"Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary."},{"Phase":["Operation"],"Description":"Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"While buffer overflow examples can be rather complex, it is possible to have very simple, yet still exploitable, heap-based buffer overflows:"},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t#define BUFSIZE 256\n\tint main(int argc, char **argv) {\n\t\tchar *buf;\n\t\tbuf = (char *)malloc(sizeof(char)*BUFSIZE);\n\t\tstrcpy(buf, argv[1]);\n\t}\n```"},{"BodyText":"The buffer is allocated heap memory with a fixed size, but there is no guarantee the string in argv[1] will not exceed this size and cause an overflow."}]},{"ID":"DX-19","Entries":[{"IntroText":"This example applies an encoding procedure to an input string and stores it into a buffer."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar * copy_input(char *user_supplied_string){\n\t\t\tint i, dst_index;\n\t\t\tchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\n\t\t\tif ( MAX_SIZE \u003c= strlen(user_supplied_string) ){\n\t\t\t\tdie(\"user string too long, die evil hacker!\");\n\t\t\t}\n\t\t\tdst_index = 0;\n\t\t\tfor ( i = 0; i \u003c strlen(user_supplied_string); i++ ){\n\t\t\t\t\tif( '\u0026' == user_supplied_string[i] ){\n\t\t\t\t\t\tdst_buf[dst_index++] = '\u0026';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'a';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'm';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'p';\n\t\t\t\t\t\tdst_buf[dst_index++] = ';';\n\t\t\t\t\t}\n\t\t\t\t\telse if ('\u003c' == user_supplied_string[i] ){\n```\n/* encode to \u0026lt; */* \n\t\t\t\t\t\t\t}\n\t\t\t\t\telse dst_buf[dst_index++] = user_supplied_string[i];}\n\t\t\treturn dst_buf;}"},{"BodyText":"The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."}]}],"ObservedExamples":[{"Reference":"CVE-2021-43537","Description":"Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)","Link":"https://www.cve.org/CVERecord?id=CVE-2021-43537"},{"Reference":"CVE-2007-4268","Description":"Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)","Link":"https://www.cve.org/CVERecord?id=CVE-2007-4268"},{"Reference":"CVE-2009-2523","Description":"Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2523"},{"Reference":"CVE-2021-29529","Description":"Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339)","Link":"https://www.cve.org/CVERecord?id=CVE-2021-29529"},{"Reference":"CVE-2010-1866","Description":"Chain: integer overflow (CWE-190) causes a negative signed value, which later bypasses a maximum-only check (CWE-839), leading to heap-based buffer overflow (CWE-122).","Link":"https://www.cve.org/CVERecord?id=CVE-2010-1866"}],"AffectedResources":["Memory"],"TaxonomyMappings":[{"TaxonomyName":"CLASP","EntryName":"Heap overflow"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP8","EntryName":"Faulty Buffer Access"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"STR31-C","EntryName":"Guarantee that storage for strings has sufficient space for character data and the null terminator","MappingFit":"CWE More Specific"},{"TaxonomyName":"ISA/IEC 62443","EntryID":"Part 4-2","EntryName":"Req CR 3.5"},{"TaxonomyName":"ISA/IEC 62443","EntryID":"Part 3-3","EntryName":"Req SR 3.5"},{"TaxonomyName":"ISA/IEC 62443","EntryID":"Part 4-1","EntryName":"Req SI-1"},{"TaxonomyName":"ISA/IEC 62443","EntryID":"Part 4-1","EntryName":"Req SI-2"},{"TaxonomyName":"ISA/IEC 62443","EntryID":"Part 4-1","EntryName":"Req SVV-1"},{"TaxonomyName":"ISA/IEC 62443","EntryID":"Part 4-1","EntryName":"Req SVV-3"}],"RelatedAttackPatterns":["92"],"References":[{"ExternalReferenceID":"REF-7","Section":"Chapter 5, \"Heap Overruns\" Page 138","Authors":["Michael Howard","David LeBlanc"],"Title":"Writing Secure Code","Edition":"2nd Edition","PublicationYear":"2002","PublicationMonth":"12","PublicationDay":"04","Publisher":"Microsoft Press","URL":"https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"},{"ExternalReferenceID":"REF-44","Section":"\"Sin 5: Buffer Overruns.\" Page 89","Authors":["Michael Howard","David LeBlanc","John Viega"],"Title":"24 Deadly Sins of Software Security","Publication":"McGraw-Hill","PublicationYear":"2010"},{"ExternalReferenceID":"REF-62","Section":"Chapter 3, \"Nonexecutable Stack\", Page 76","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-62","Section":"Chapter 5, \"Protection Mechanisms\", Page 189","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-58","Authors":["Michael Howard"],"Title":"Address Space Layout Randomization in Windows Vista","URL":"https://learn.microsoft.com/en-us/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-60","Title":"PaX","URL":"https://en.wikipedia.org/wiki/Executable_space_protection#PaX","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-64","Authors":["Grant Murphy"],"Title":"Position Independent Executables (PIE)","PublicationYear":"2012","PublicationMonth":"11","PublicationDay":"28","Publisher":"Red Hat","URL":"https://www.redhat.com/en/blog/position-independent-executables-pie","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-18","Authors":["Secure Software, Inc."],"Title":"The CLASP Application Security Process","PublicationYear":"2005","URL":"https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf"},{"ExternalReferenceID":"REF-1337","Section":"Memory information leaks","Authors":["Alexander Sotirov and Mark Dowd"],"Title":"Bypassing Browser Memory Protections: Setting back browser security by 10 years","PublicationYear":"2008","URL":"https://www.blackhat.com/presentations/bh-usa-08/Sotirov_Dowd/bh08-sotirov-dowd.pdf","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1332","Authors":["John Richard Moser"],"Title":"Prelink and address space randomization","PublicationYear":"2006","PublicationMonth":"07","PublicationDay":"05","URL":"https://lwn.net/Articles/190139/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1333","Authors":["Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh"],"Title":"Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR","PublicationYear":"2016","URL":"http://www.cs.ucr.edu/~nael/pubs/micro16.pdf","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1334","Authors":["D3FEND"],"Title":"Stack Frame Canary Validation (D3-SFCV)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:StackFrameCanaryValidation/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1335","Authors":["D3FEND"],"Title":"Segment Address Offset Randomization (D3-SAOR)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:SegmentAddressOffsetRandomization/","URLDate":"2023-04-26"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"Notes":[{"Type":"Relationship","Note":"Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CLASP","SubmissionDate":"2006-07-19","SubmissionVersion":"Draft 3","SubmissionReleaseDate":"2006-07-19"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Potential_Mitigations, Time_of_Introduction"},{"Type":"Modification","ModificationOrganization":"KDM Analytics","ModificationDate":"2008-08-01","ModificationComment":"added/updated white box definitions"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Applicable_Platforms, Common_Consequences, Relationships, Other_Notes, Taxonomy_Mappings, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Common_Consequences, Other_Notes, Relationship_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-01-12","ModificationComment":"updated Common_Consequences, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-10-29","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-02-16","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-10-30","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2013-02-21","ModificationComment":"updated Demonstrative_Examples, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-06-23","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Causal_Nature, Likelihood_of_Exploit, Observed_Examples, References, Relationships, Taxonomy_Mappings, White_Box_Definitions"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2018-03-27","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Potential_Mitigations, References, Relationships, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-02-29","ModificationComment":"updated Observed_Examples, Taxonomy_Mappings","ModificationVersion":"4.14","ModificationReleaseDate":"2024-02-29"},{"Type":"Contribution","ContributionName":"participants in the CWE ICS/OT SIG 62443 Mapping Fall Workshop","ContributionDate":"2023-11-14","ContributionComment":"Contributed or reviewed taxonomy mappings for ISA/IEC 62443","ContributionType":"Content","ContributionVersion":"4.14","ContributionReleaseDate":"2024-02-29"}]}