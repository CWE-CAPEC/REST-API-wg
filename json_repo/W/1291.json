{"ID":"1291","Name":"Public Key Re-Use for Signing both Debug and Production Code","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The same public key is used for signing both debug and production code.","ExtendedDescription":"\n\nA common usage of public-key cryptography is to verify the integrity and authenticity of another entity (for example a firmware binary). If a company wants to ensure that its firmware runs only on its own hardware, before the firmware runs, an encrypted hash of the firmware image will be decrypted with the public key and then verified against the now-computed hash of the firmware image. This means that the public key forms the root of trust, which necessitates that the public key itself must be protected and used properly.\n\n\nDuring the development phase, debug firmware enables many hardware debug hooks, debug modes, and debug messages for testing. Those debug facilities provide significant, additional views about the firmware's capability and, in some cases, additional capability into the chip or SoC. If compromised, these capabilities could be exploited by an attacker to take full control of the system.\n\n\nOnce the product exits the manufacturing stage and enters production, it is good practice to use a different public key. Debug firmware images are known to leak. With the debug key being reused as the production key, the debug image will also work on the production image. Thus, it will open all the internal, debug capabilities to the attacker.\n\n\nIf a different public key is used for the production image, even if the attacker gains access to the debug firmware image, they will not be able to run it on a production machine. Thus, damage will be limited to the intellectual property leakage resulting from the debug image.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"693","ViewID":"1000","Ordinal":"Primary"},{"Nature":"PeerOf","CweID":"321","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability","Access Control","Accountability","Authentication","Authorization","Non-Repudiation","Other"],"Impact":["Read Memory","Modify Memory","Execute Unauthorized Code or Commands","Gain Privileges or Assume Identity","Varies by Context"],"Likelihood":["High"]}],"DetectionMethods":[{"Method":"Architecture or Design Review","Description":"\n\nCompare the debug key with the production key to make sure that they are not the same.\n","Effectiveness":"High"},{"Method":"Dynamic Analysis with Manual Results Interpretation","Description":"\n\nCompare the debug key with the production key to make sure that they are not the same.\n","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Use different keys for Production and Debug"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"This example illustrates the danger of using the same public key for debug and production."},{"Nature":"Bad","Language":"Other","ExampleCode":"Suppose the product design requires frugality of silicon real estate. Assume that originally the architecture allows just enough storage for two 2048-bit RSA keys in the fuse: one to be used for debug and the other for production. However, in the meantime, a business decision is taken to make the security future-proof beyond 2030, which means the architecture needs to use the NIST-recommended 3072-bit keys instead of the originally-planned 2048-bit keys. This means that, at most, one key can be fully stored in the fuses, not two. So the product design team decides to use the same public key for debug and production."},{"Nature":"Informative","Language":"Other","ExampleCode":"Increase the storage so that two different keys of the required size can be stored."}]}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Parbati Kumar Manna, Hareesh Khattri, Arun Kanuparthi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-05-26","SubmissionVersion":"4.2","SubmissionReleaseDate":"2020-08-20"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}