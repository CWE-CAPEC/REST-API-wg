{"ID":"1262","Name":"Improper Access Control for Register Interface","Abstraction":"Base","Structure":"Simple","Status":"Stable","Description":"The product uses memory-mapped I/O registers that act as an interface to hardware functionality from software, but there is improper access control to those registers.","ExtendedDescription":"\n\nSoftware commonly accesses peripherals in a System-on-Chip (SoC) or other device through a memory-mapped register interface. Malicious software could tamper with any security-critical hardware data that is accessible directly or indirectly through the register interface, which could lead to a loss of confidentiality and integrity.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"284","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"This weakness may be exploited if the register interface design does not adequately protect hardware assets from software."},{"Phase":"Implementation","Note":"Mis-implementation of access control policies may inadvertently allow access to hardware assets through the register interface."}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity"],"Impact":["Read Memory","Read Application Data","Modify Memory","Modify Application Data","Gain Privileges or Assume Identity","Bypass Protection Mechanism","Unexpected State","Alter Execution Logic"],"Note":"Confidentiality of hardware assets may be violated if the protected information can be read out by software through the register interface. Registers storing security state, settings, other security-critical data may be corruptible by software without correctly implemented protections."}],"DetectionMethods":[{"Method":"Manual Analysis","Description":"This is applicable in the Architecture phase before implementation started. Make sure access policy is specified for the entire memory map. Manual analysis may not ensure the implementation is correct.","Effectiveness":"Moderate"},{"Method":"Manual Analysis","Description":"Registers controlling hardware should have access control implemented. This access control may be checked manually for correct implementation. Items to check consist of how are trusted parties set, how are trusted parties verified, how are accesses verified, etc. Effectiveness of a manual analysis will vary depending upon how complicated the interface is constructed.","Effectiveness":"Moderate"},{"Method":"Simulation / Emulation","Description":"Functional simulation is applicable during the Implementation Phase. Testcases must be created and executed for memory mapped registers to verify adherence to the access control policy. This method can be effective, since functional verification needs to be performed on the design, and verification for this weakness will be included. There can be difficulty covering the entire memory space during the test.","Effectiveness":"Moderate"},{"Method":"Formal Verification","Description":"Formal verification is applicable during the Implementation phase. Assertions need to be created in order to capture illegal register access scenarios and prove that they cannot occur. Formal methods are exhaustive and can be very effective, but creating the cases for large designs may be complex and difficult.","Effectiveness":"High"},{"Method":"Automated Analysis","Description":"Information flow tracking can be applicable during the Implementation phase. Security sensitive data (assets) - for example, as stored in registers - is automatically tracked over time through the design to verify the data doesn't reach illegal destinations that violate the access policies for the memory map. This method can be very effective when used together with simulation and emulation, since detecting violations doesn't rely on specific scenarios or data values. This method does rely on simulation and emulation, so testcases must exist in order to use this method.","Effectiveness":"High"},{"Method":"Architecture or Design Review","Description":"Manual documentation review of the system memory map, register specification, and permissions associated with accessing security-relevant functionality exposed via memory-mapped registers.","Effectiveness":"Moderate"},{"Method":"Fuzzing","Description":"Perform penetration testing (either manual or semi-automated with fuzzing) to verify that access control mechanisms such as the memory protection units or on-chip bus firewall settings adequately protect critical hardware registers from software access.","Effectiveness":"Moderate"}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"Design proper policies for hardware register access from software."},{"Phase":["Implementation"],"Description":"Ensure that access control policies for register access are implemented in accordance with the specified design."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The register interface provides software access to hardware functionality. This functionality is an attack surface. This attack surface may be used to run untrusted code on the system through the register interface. As an example, cryptographic accelerators require a mechanism for software to select modes of operation and to provide plaintext or ciphertext data to be encrypted or decrypted as well as other functions. This functionality is commonly provided through registers."},{"Nature":"Bad","ExampleCode":"Cryptographic key material stored in registers inside the cryptographic accelerator can be accessed by software."},{"Nature":"Good","ExampleCode":"Key material stored in registers should never be accessible to software. Even if software can provide a key, all read-back paths to software should be disabled."}]},{"Entries":[{"IntroText":"The example code is taken from the Control/Status Register (CSR) module inside the processor core of the HACK@DAC'19 buggy CVA6 SoC [REF-1340]. In RISC-V ISA [REF-1341], the CSR file contains different sets of registers with different privilege levels, e.g., user mode (U), supervisor mode (S), hypervisor mode (H), machine mode (M), and debug mode (D), with different read-write policies, read-only (RO) and read-write (RW). For example, machine mode, which is the highest privilege mode in a RISC-V system, registers should not be accessible in user, supervisor, or hypervisor modes."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"```\n\tif (csr_we || csr_read) begin \n```\nif ((riscv::priv_lvl_t'(priv_lvl_o \u0026 csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl) \u0026\u0026 !(csr_addr.address==riscv::CSR_MEPC)) begin** \n\t\t\n\t\t```\n\t\t\t csr_exception_o.cause = riscv::ILLEGAL_INSTR;\n\t\t\t csr_exception_o.valid = 1'b1;\n\t\t end\n\t\t // check access to debug mode only CSRs\n\t\t if (csr_addr_i[11:4] == 8'h7b \u0026\u0026 !debug_mode_q) begin\n\t\t\t csr_exception_o.cause = riscv::ILLEGAL_INSTR;\n\t\t\t csr_exception_o.valid = 1'b1;\n\t\t end \n\t end \n```"},{"BodyText":"The vulnerable example code allows the machine exception program counter (MEPC) register to be accessed from a user mode program by excluding the MEPC from the access control check. MEPC as per the RISC-V specification can be only written or read by machine mode code. Thus, the attacker in the user mode can run code in machine mode privilege (privilege escalation)."},{"BodyText":"To mitigate the issue, fix the privilege check so that it throws an Illegal Instruction Exception for user mode accesses to the MEPC register. [REF-1345]"},{"Nature":"Good","Language":"Verilog","ExampleCode":"```\n\tif (csr_we || csr_read) begin \n```\nif ((riscv::priv_lvl_t'(priv_lvl_o \u0026 csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl)) begin** \n\t\t\n\t\t```\n\t\t\t csr_exception_o.cause = riscv::ILLEGAL_INSTR;\n\t\t\t csr_exception_o.valid = 1'b1;\n\t\t end\n\t\t // check access to debug mode only CSRs\n\t\t if (csr_addr_i[11:4] == 8'h7b \u0026\u0026 !debug_mode_q) begin\n\t\t\t csr_exception_o.cause = riscv::ILLEGAL_INSTR;\n\t\t\t csr_exception_o.valid = 1'b1;\n\t\t end \n\t end \n```"}]}],"ObservedExamples":[{"Reference":"CVE-2014-2915","Description":"virtualization product does not restrict access to debug and other processor registers in the hardware, allowing a crash of the host or guest OS","Link":"https://www.cve.org/CVERecord?id=CVE-2014-2915"},{"Reference":"CVE-2021-3011","Description":"virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code","Link":"https://www.cve.org/CVERecord?id=CVE-2021-3011"},{"Reference":"CVE-2020-12446","Description":"Driver exposes access to Model Specific Register (MSR) registers, allowing admin privileges.","Link":"https://www.cve.org/CVERecord?id=CVE-2020-12446"},{"Reference":"CVE-2015-2150","Description":"Virtualization product does not restrict access to PCI command registers, allowing host crash from the guest.","Link":"https://www.cve.org/CVERecord?id=CVE-2015-2150"}],"RelatedAttackPatterns":["680"],"References":[{"ExternalReferenceID":"REF-1340","Title":"Hackatdac19 csr_regfile.sv","PublicationYear":"2019","URL":"https://github.com/HACK-EVENT/hackatdac19/blob/619e9fb0ef32ee1e01ad76b8732a156572c65700/src/csr_regfile.sv#L854:L857","URLDate":"2023-06-21"},{"ExternalReferenceID":"REF-1341","Authors":["Andrew Waterman","Yunsup Lee","Rimas Avižienis","David Patterson","Krste Asanović"],"Title":"The RISC-V Instruction Set Manual","Edition":"Volume II: Privileged Architecture","PublicationYear":"2016","PublicationMonth":"11","PublicationDay":"04","URL":"https://people.eecs.berkeley.edu/~krste/papers/riscv-privileged-v1.9.1.pdf","URLDate":"2023-06-21"},{"ExternalReferenceID":"REF-1345","Authors":["Florian Zaruba","Michael Schaffner","Andreas Traber"],"Title":"csr_regfile.sv","PublicationYear":"2019","URL":"https://github.com/openhwgroup/cva6/blob/7951802a0147aedb21e8f2f6dc1e1e9c4ee857a2/src/csr_regfile.sv#L868:L871","URLDate":"2023-06-21"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Nicole Fern","SubmissionOrganization":"Cycuity (originally submitted as Tortuga Logic)","SubmissionDate":"2020-05-08","SubmissionVersion":"4.1","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Description, Maintenance_Notes, Modes_of_Introduction, Potential_Mitigations, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Description, Detection_Factors, Name, Observed_Examples, Potential_Mitigations, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Demonstrative_Examples, Mapping_Notes, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Contribution","ContributionName":"Anders Nordstrom, Alric Althoff","ContributionOrganization":"Cycuity (originally submitted as Tortuga Logic)","ContributionDate":"2021-10-11","ContributionComment":"Provided detection methods and observed examples","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Nicole Fern","ContributionOrganization":"Riscure","ContributionDate":"2021-10-12","ContributionComment":"Provided detection methods","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Pouya Mahmoody, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Rahul Kande, Chen Chen, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Rename","PreviousEntryName":"Register Interface Allows Software Access to Sensitive Data or Security Settings","Date":"2021-10-28"}]}