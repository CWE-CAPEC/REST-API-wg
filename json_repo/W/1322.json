{"ID":"1322","Name":"Use of Blocking Code in Single-threaded, Non-blocking Context","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product uses a non-blocking model that relies on a single threaded process\n\t\t\tfor features such as scalability, but it contains code that can block when it is invoked.","ExtendedDescription":"\n\nWhen an attacker can directly invoke the blocking code, or the blocking code can be affected by environmental conditions that can be influenced by an attacker, then this can lead to a denial of service by causing unexpected hang or freeze of the code. Examples of blocking code might be an expensive computation or calling blocking library calls, such as those that perform exclusive file operations or require a successful network operation.\n\n\nDue to limitations in multi-thread models, single-threaded models are used to overcome the resource constraints that are caused by using many threads. In such a model, all code should generally be non-blocking. If blocking code is called, then the event loop will effectively be stopped, which can be undesirable or dangerous. Such models are used in Python asyncio, Vert.x, and Node.js, or other custom event loop code.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"834","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"835","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (CPU)"],"Note":"An unexpected call to blocking code can trigger an infinite loop, or a large loop that causes the software to pause and wait indefinitely."}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Generally speaking, blocking calls should be replaced with non-blocking alternatives that can be used asynchronously. Expensive computations should be passed off to worker threads, although the correct approach depends on the framework being used."},{"Phase":["Implementation"],"Description":"For expensive computations, consider breaking them up into multiple smaller computations. Refer to the documentation of the framework being used for guidance."}],"RelatedAttackPatterns":["25"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Joe Harvey","SubmissionDate":"2019-10-25","SubmissionVersion":"4.3","SubmissionReleaseDate":"2020-12-10"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-12-11","ModificationComment":"updated Applicable_Platforms, Weakness_Ordinalities","ModificationVersion":"4.19","ModificationReleaseDate":"2025-12-11"}]}