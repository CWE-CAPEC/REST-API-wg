{"ID":"1244","Name":"Internal Asset Exposed to Unsafe Debug Access Level or State","Abstraction":"Base","Structure":"Simple","Status":"Stable","Description":"The product uses physical debug or test\n        interfaces with support for multiple access levels, but it\n        assigns the wrong debug access level to an internal asset,\n        providing unintended access to the asset from untrusted debug\n        agents.","ExtendedDescription":"\n\nDebug authorization can have multiple levels of access, defined such that different system internal assets are accessible based on the current authorized debug level. Other than debugger authentication (e.g., using passwords or challenges), the authorization can also be based on the system state or boot stage. For example, full system debug access might only be allowed early in boot after a system reset to ensure that previous session data is not accessible to the authenticated debugger.\n\n\nIf this protection mechanism does not ensure that internal assets have the correct debug access level during each boot stage or change in system state, an attacker could obtain sensitive information from the internal asset using a debugger.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"863","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"System on Chip","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory"]},{"Scope":["Integrity"],"Impact":["Modify Memory"]},{"Scope":["Authorization","Access Control"],"Impact":["Gain Privileges or Assume Identity","Bypass Protection Mechanism"]}],"DetectionMethods":[{"Method":"Manual Analysis","Description":"Check 2 devices for their passcode to authenticate access to JTAG/debugging ports. If the passcodes are missing or the same, update the design to fix and retest. Check communications over JTAG/debugging ports for encryption. If the communications are not encrypted, fix the design and retest.","Effectiveness":"Moderate"}],"PotentialMitigations":[{"Phase":["Architecture and Design","Implementation"],"Description":"\n\nFor security-sensitive assets accessible over debug/test interfaces, only allow trusted agents.\n","Effectiveness":"High"},{"Phase":["Architecture and Design"],"Description":"Apply blinding [REF-1219] or masking techniques in strategic areas.","Effectiveness":"Limited"},{"Phase":["Implementation"],"Description":"Add shielding or tamper-resistant protections to the device, which increases the difficulty and cost for accessing debug/test interfaces.","Effectiveness":"Limited"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The JTAG interface is used to perform debugging and provide CPU core access for developers. JTAG-access protection is implemented as part of the JTAG_SHIELD bit in the hw_digctl_ctrl register. This register has no default value at power up and is set only after the system boots from ROM and control is transferred to the user software."},{"Nature":"Bad","Language":"Other","ExampleCode":"|  | \n|\n| 1 bit | 0x0 = JTAG debugger is enabled (default)  |\n| JTAG_SHIELD | 0x1 = JTAG debugger is disabled  |"},{"BodyText":"This means that since the end user has access to JTAG at system reset and during ROM code execution before control is transferred to user software, a JTAG user can modify the boot flow and subsequently disclose all CPU information, including data-encryption keys."},{"Nature":"Informative","ExampleCode":"```\n\tThe default value of this register bit should be set to 1 to prevent the JTAG from being enabled at system reset.\n```"}]},{"Entries":[{"IntroText":"The example code below is taken from the CVA6 processor core of the HACK@DAC'21 buggy OpenPiton SoC. Debug access allows users to access internal hardware registers that are otherwise not exposed for user access or restricted access through access control protocols. Hence, requests to enter debug mode are checked and authorized only if the processor has sufficient privileges. In addition, debug accesses are also locked behind password checkers. Thus, the processor enters debug mode only when the privilege level requirement is met, and the correct debug password is provided."},{"BodyText":"The following code [REF-1377] illustrates an instance of a vulnerable implementation of debug mode. The core correctly checks if the debug requests have sufficient privileges and enables the debug_mode_d and debug_mode_q signals. It also correctly checks for debug password and enables umode_i signal."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module csr_regfile #(\n ...\n\n```\n\t // check that we actually want to enter debug depending on the privilege level we are currently in\n\t unique case (priv_lvl_o)\n\t\t riscv::PRIV_LVL_M: begin\n\t\t\t debug_mode_d = dcsr_q.ebreakm;\n ...\n\t\t riscv::PRIV_LVL_U: begin\n\t\t\t debug_mode_d = dcsr_q.ebreaku;\n ...\n```\nassign priv_lvl_o = (debug_mode_q || umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;** \n\t ...\n\n```\n\t debug_mode_q \u003c= debug_mode_d;\n ...\n```"},{"BodyText":"However, it grants debug access and changes the privilege level, priv_lvl_o, even when one of the two checks is satisfied and the other is not. Because of this, debug access can be granted by simply requesting with sufficient privileges (i.e., debug_mode_q is enabled) and failing the password check (i.e., umode_i is disabled). This allows an attacker to bypass the debug password checking and gain debug access to the core, compromising the security of the processor."},{"BodyText":"A fix to this issue is to only change the privilege level of the processor when both checks are satisfied, i.e., the request has enough privileges (i.e., debug_mode_q is enabled) and the password checking is successful (i.e., umode_i is enabled) [REF-1378]."},{"Nature":"Good","Language":"Verilog","ExampleCode":"module csr_regfile #(\n ...\n\n```\n\t // check that we actually want to enter debug depending on the privilege level we are currently in\n\t unique case (priv_lvl_o)\n\t\t riscv::PRIV_LVL_M: begin\n\t\t\t debug_mode_d = dcsr_q.ebreakm;\n ...\n\t\t riscv::PRIV_LVL_U: begin\n\t\t\t debug_mode_d = dcsr_q.ebreaku;\n ...\n\t assign priv_lvl_o = \n```\n(debug_mode_q \u0026\u0026 umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;** \n\t ...\n\n```\n\t debug_mode_q \u003c= debug_mode_d;\n ...\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2019-18827","Description":"After ROM code execution, JTAG access is disabled. But before the ROM code is executed, JTAG access is possible, allowing a user full system access. This allows a user to modify the boot flow and successfully bypass the secure-boot process.","Link":"https://www.cve.org/CVERecord?id=CVE-2019-18827"}],"RelatedAttackPatterns":["114"],"References":[{"ExternalReferenceID":"REF-1056","Authors":["F-Secure Labs"],"Title":"Multiple Vulnerabilities in Barco Clickshare: JTAG access is not permanently disabled","URL":"https://labs.f-secure.com/advisories/multiple-vulnerabilities-in-barco-clickshare/"},{"ExternalReferenceID":"REF-1057","Authors":["Kurt Rosenfeld","Ramesh Karri"],"Title":"Attacks and Defenses for JTAG","URL":"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=\u0026arnumber=5406671"},{"ExternalReferenceID":"REF-1219","Authors":["Monodeep Kar","Arvind Singh","Santosh Ghosh","Sanu Mathew","Anand Rajan","Vivek De","Raheem Beyah","Saibal Mukhopadhyay"],"Title":"Blindsight: Blinding EM Side-Channel Leakage using Built-In Fully Integrated Inductive Voltage Regulator","PublicationYear":"2018","PublicationMonth":"02","URL":"https://arxiv.org/pdf/1802.09096.pdf","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-1377","Title":"csr_regile.sv line 938","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac19/blob/57e7b2109c1ea2451914878df2e6ca740c2dcf34/src/csr_regfile.sv#L938","URLDate":"2023-12-13"},{"ExternalReferenceID":"REF-1378","Title":"Fix for csr_regfile.sv line 938","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac19/blob/a7b61209e56c48eec585eeedea8413997ec71e4a/src/csr_regfile.sv#L938C31-L938C56","URLDate":"2023-12-13"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"Notes":[{"Type":"Relationship","Note":"CWE-1191 and CWE-1244 both involve physical debug access, but the weaknesses are different. CWE-1191 is effectively about missing authorization for a debug interface, i.e. JTAG. CWE-1244 is about providing internal assets with the wrong debug access level, exposing the asset to untrusted debug agents."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-02-12","SubmissionVersion":"4.0","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Demonstrative_Examples, Name, Observed_Examples, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Maintenance_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Name, Observed_Examples, Potential_Mitigations, References, Relationship_Notes, Relationships, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-02-29","ModificationComment":"updated Demonstrative_Examples, References","ModificationVersion":"4.14","ModificationReleaseDate":"2024-02-29"},{"Type":"Contribution","ContributionName":"Hareesh Khattri","ContributionOrganization":"Intel Corporation","ContributionDate":"2021-10-22","ContributionComment":"clarified differences between CWE-1191 and CWE-1244, and suggested rephrasing of descriptions and names.","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Chen Chen, Rahul Kande, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Rename","PreviousEntryName":"Improper Authorization on Physical Debug and Test Interfaces","Date":"2020-08-20"},{"Type":"Rename","PreviousEntryName":"Improper Access to Sensitive Information Using Debug and Test Interfaces","Date":"2021-10-28"}]}