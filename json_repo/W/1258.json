{"ID":"1258","Name":"Exposure of Sensitive System Information Due to Uncleared Debug Information","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The hardware does not fully clear security-sensitive values, such as keys and intermediate values in cryptographic operations, when debug mode is entered.","ExtendedDescription":"\n\nSecurity sensitive values, keys, intermediate steps of cryptographic operations, etc. are stored in temporary registers in the hardware. If these values are not cleared when debug mode is entered they may be accessed by a debugger allowing sensitive information to be accessible by untrusted parties.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"212","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory"]},{"Scope":["Access Control"],"Impact":["Bypass Protection Mechanism"]}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"\n\nWhenever debug mode is enabled, all registers containing sensitive assets must be cleared.\n"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"A cryptographic core in a System-On-a-Chip (SoC) is used for cryptographic acceleration and implements several cryptographic operations (e.g., computation of AES encryption and decryption, SHA-256, HMAC, etc.). The keys for these operations or the intermediate values are stored in registers internal to the cryptographic core. These internal registers are in the Memory Mapped Input Output (MMIO) space and are blocked from access by software and other untrusted agents on the SoC. These registers are accessible through the debug and test interface."},{"Nature":"Bad","Language":"Other","ExampleCode":"In the above scenario, registers that store keys and intermediate values of cryptographic operations are not cleared when system enters debug mode. An untrusted actor running a debugger may read the contents of these registers and gain access to secret keys and other sensitive cryptographic information."},{"Nature":"Good","Language":"Other","ExampleCode":"Whenever the chip enters debug mode, all registers containing security-sensitive data are be cleared rendering them unreadable."}]},{"Entries":[{"IntroText":"The following code example is extracted from the AES wrapper module, aes1_wrapper, of the Hack@DAC'21 buggy OpenPiton System-on-Chip (SoC). Within this wrapper module are four memory-mapped registers: core_key, core_key0, core_key1, and core_key2. Core_key0, core_key1, and core_key2 hold encryption/decryption keys. The core_key register selects a key and sends it to the underlying AES module to execute encryption/decryption operations.\n\n\nDebug mode in processors and SoCs facilitates design debugging by granting access to internal signal/register values, including physical pin values of peripherals/core, fabric bus data transactions, and inter-peripheral registers. Debug mode allows users to gather detailed, low-level information about the design to diagnose potential issues. While debug mode is beneficial for diagnosing processors or SoCs, it also introduces a new attack surface for potential attackers. For instance, if an attacker gains access to debug mode, they could potentially read any content transmitted through the fabric bus or access encryption/decryption keys stored in cryptographic peripherals.\n\n\nTherefore, it is crucial to clear the contents of secret registers upon entering debug mode. In the provided example of flawed code below, when debug_mode_i is activated, the register core_key0 is set to zero to prevent AES key leakage during debugging. However, this protective measure is not applied to the core_key1 register [REF-1435], leaving its contents uncleared during debug mode. This oversight enables a debugger to access sensitive information. Failing to clear sensitive data during debug mode may lead to unauthorized access to secret keys and compromise system security."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module aes1_wrapper #(\n ...\n\n```\n\t assign core_key0 = debug_mode_i ? 'b0 : { \n\t\t key_reg0[7],\n\t\t key_reg0[6],\n\t\t key_reg0[5],\n\t\t key_reg0[4],\n\t\t key_reg0[3],\n\t\t key_reg0[2],\n\t\t key_reg0[1],\n\t\t key_reg0[0]};\n```\nassign core_key1 = { ** \n\t\n\t```\n```\nkey_reg1[7],** \n\t\t\n\t\t **key_reg1[6],** \n\t\t\n\t\t **key_reg1[5],** \n\t\t\n\t\t **key_reg1[4],** \n\t\t\n\t\t **key_reg1[3],** \n\t\t\n\t\t **key_reg1[2],** \n\t\t\n\t\t **key_reg1[1],** \n\t\t\n\t\t **key_reg1[0]};** \n\t\t ...\n endmodule"},{"BodyText":"To address the issue, it is essential to ensure that the register is cleared and zeroized after activating debug mode on the SoC. In the correct implementation illustrated in the good code below, core_keyx registers are set to zero when debug mode is activated [REF-1436]."},{"Nature":"Good","Language":"Verilog","ExampleCode":"module aes1_wrapper #(\n ...\n\n```\n\t assign core_key0 = debug_mode_i ? 'b0 : { \n\t\t key_reg0[7],\n\t\t key_reg0[6],\n\t\t key_reg0[5],\n\t\t key_reg0[4],\n\t\t key_reg0[3],\n\t\t key_reg0[2],\n\t\t key_reg0[1],\n\t\t key_reg0[0]};\n\t assign core_key1 = \n```\ndebug_mode_i ? 'b0 :**  { \n\t\n\t```\n\t\t key_reg1[7],\n\t\t key_reg1[6],\n\t\t key_reg1[5],\n\t\t key_reg1[4],\n\t\t key_reg1[3],\n\t\t key_reg1[2],\n\t\t key_reg1[1],\n\t\t key_reg1[0]};\n ...\n endmodule\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2021-33080","Description":"Uncleared debug information in memory accelerator for SSD product exposes sensitive system information","Link":"https://www.cve.org/CVERecord?id=CVE-2021-33080"},{"Reference":"CVE-2022-31162","Description":"Rust library leaks Oauth client details in application debug logs","Link":"https://www.cve.org/CVERecord?id=CVE-2022-31162"}],"RelatedAttackPatterns":["150","204","37","545"],"References":[{"ExternalReferenceID":"REF-1435","Title":"Bad Code aes1_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/bcae7aba7f9daee8ad2cfd47b997ac7ad6611034/piton/design/chip/tile/ariane/src/aes1/aes1_wrapper.sv#L149:L155"},{"ExternalReferenceID":"REF-1436","Title":"Good Code aes1_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/e3234bb15f07f213de08ec91a9ec08d2a16b5714/piton/design/chip/tile/ariane/src/aes1/aes1_wrapper.sv#L149:L155"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-02-12","SubmissionVersion":"4.1","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Demonstrative_Examples, Description, Name, Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-07-16","ModificationComment":"updated Demonstrative_Examples, References","ModificationVersion":"4.15","ModificationReleaseDate":"2024-07-16"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-12-11","ModificationComment":"updated Relationships, Weakness_Ordinalities","ModificationVersion":"4.19","ModificationReleaseDate":"2025-12-11"},{"Type":"Contribution","ContributionName":"Mohamadreza Rostami, Shaza Zeitouni, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Rahul Kande, Chen Chen, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Rename","PreviousEntryName":"Sensitive Information Uncleared During Hardware Debug Flows","Date":"2020-08-20"}]}