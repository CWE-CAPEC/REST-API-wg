{"ID":"665","Name":"Improper Initialization","Abstraction":"Class","Structure":"Simple","Status":"Draft","Description":"The product does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used.","ExtendedDescription":"This can have security implications when the associated resource is expected to have certain properties or values, such as a variable that determines whether a user has been authenticated or not.","LikelihoodOfExploit":"Medium","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"664","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"},{"Ordinality":"Resultant"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation","Note":"This weakness can occur in code paths that are not well-tested, such as rare error conditions. This is because the use of uninitialized data would be noticed as a bug during frequently-used functionality."},{"Phase":"Operation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory","Read Application Data"],"Note":"When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party."},{"Scope":["Access Control"],"Impact":["Bypass Protection Mechanism"],"Note":"If security-critical decisions rely on a variable having a \"0\" or equivalent value, and the programming language performs this initialization on behalf of the programmer, then a bypass of security may occur."},{"Scope":["Availability"],"Impact":["DoS: Crash, Exit, or Restart"],"Note":"The uninitialized data may contain values that cause program flow to change in ways that the programmer did not intend. For example, if an uninitialized variable is used as an array index in C, then its previous contents may produce an index that is outside the range of the array, possibly causing a crash or an exit in other environments."}],"DetectionMethods":[{"DetectionMethodID":"DM-2","Method":"Automated Dynamic Analysis","Description":"\n\nThis weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.\n\n\nInitialization problems may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.\n","Effectiveness":"Moderate"},{"DetectionMethodID":"DM-12","Method":"Manual Dynamic Analysis","Description":"Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself."},{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"MitigationID":"MIT-3","Phase":["Requirements"],"Strategy":"Language Selection","Description":"\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, in Java, if the programmer does not explicitly initialize a variable, then the code could produce a compile-time error (if the variable is local) or automatically initialize the variable to the default value for the variable's type. In Perl, if explicit initialization is not performed, then a default value of undef is assigned, which is interpreted as 0, false, or an equivalent value depending on the context in which the variable is accessed.\n"},{"Phase":["Architecture and Design"],"Description":"Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values."},{"Phase":["Implementation"],"Description":"Explicitly initialize all your variables and other data stores, either during declaration or just before the first usage."},{"Phase":["Implementation"],"Description":"Pay close attention to complex conditionals that affect initialization, since some conditions might not perform the initialization."},{"Phase":["Implementation"],"Description":"Avoid race conditions (CWE-362) during initialization routines."},{"Phase":["Build and Compilation"],"Description":"Run or compile your product with settings that generate warnings about uninitialized variables or data."},{"Phase":["Testing"],"Description":"Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."}],"DemonstrativeExamples":[{"ID":"DX-105","Entries":[{"IntroText":"Here, a boolean initiailized field is consulted to ensure that initialization tasks are only completed once. However, the field is mistakenly set to true during static initialization, so the initialization code is never reached."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tprivate boolean initialized = true;\n\tpublic void someMethod() {\n\t\t\tif (!initialized) {\n```\n// perform initialization tasks* \n\t\t\t\t\t...\n\t\t\t\t\t\n\t\t\t\t\tinitialized = true;}"}]},{"ID":"DX-54","Entries":[{"IntroText":"The following code intends to limit certain operations to the administrator only."},{"Nature":"Bad","Language":"Perl","ExampleCode":"```\n\t$username = GetCurrentUser();\n\t$state = GetStateData($username);\n\tif (defined($state)) {\n\t\t$uid = ExtractUserID($state);\n\t}\n```\n# do stuff* \n\tif ($uid == 0) {\n\t```\n\t\tDoAdminThings();\n\t}\n```"},{"BodyText":"If the application is unable to extract the state information - say, due to a database timeout - then the $uid variable will not be explicitly set by the programmer. This will cause $uid to be regarded as equivalent to \"0\" in the conditional, allowing the original user to perform administrator actions. Even if the attacker cannot directly influence the state data, unexpected errors could cause incorrect privileges to be assigned to a user just by accident."}]},{"ID":"DX-106","Entries":[{"IntroText":"The following code intends to concatenate a string to a variable and print the string."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar str[20];\n\tstrcat(str, \"hello world\");\n\tprintf(\"%s\", str);\n```"},{"BodyText":"This might seem innocent enough, but str was not initialized, so it contains random memory. As a result, str[0] might not contain the null terminator, so the copy might start at an offset other than 0. The consequences can vary, depending on the underlying memory."},{"BodyText":"If a null terminator is found before str[8], then some bytes of random garbage will be printed before the \"hello world\" string. The memory might contain sensitive information from previous uses, such as a password (which might occur as a result of CWE-14 or CWE-244). In this example, it might not be a big deal, but consider what could happen if large amounts of memory are printed out before the null terminator is found."},{"BodyText":"If a null terminator isn't found before str[8], then a buffer overflow could occur, since strcat will first look for the null terminator, then copy 12 bytes starting with that location. Alternately, a buffer over-read might occur (CWE-126) if a null terminator isn't found before the end of the memory segment is reached, leading to a segmentation fault and crash."}]}],"ObservedExamples":[{"Reference":"CVE-2001-1471","Description":"chain: an invalid value prevents a library file from being included, skipping initialization of key variables, leading to resultant eval injection.","Link":"https://www.cve.org/CVERecord?id=CVE-2001-1471"},{"Reference":"CVE-2008-3637","Description":"Improper error checking in protection mechanism produces an uninitialized variable, allowing security bypass and code execution.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-3637"},{"Reference":"CVE-2008-4197","Description":"Use of uninitialized memory may allow code execution.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-4197"},{"Reference":"CVE-2008-2934","Description":"Free of an uninitialized pointer leads to crash and possible code execution.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-2934"},{"Reference":"CVE-2007-3749","Description":"OS kernel does not reset a port when starting a setuid program, allowing local users to access the port and gain privileges.","Link":"https://www.cve.org/CVERecord?id=CVE-2007-3749"},{"Reference":"CVE-2008-0063","Description":"Product does not clear memory contents when generating an error message, leading to information leak.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-0063"},{"Reference":"CVE-2008-0062","Description":"Lack of initialization triggers NULL pointer dereference or double-free.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-0062"},{"Reference":"CVE-2008-0081","Description":"Uninitialized variable leads to code execution in popular desktop application.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-0081"},{"Reference":"CVE-2008-3688","Description":"chain: Uninitialized variable leads to infinite loop.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-3688"},{"Reference":"CVE-2008-3475","Description":"chain: Improper initialization leads to memory corruption.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-3475"},{"Reference":"CVE-2008-5021","Description":"Composite: race condition allows attacker to modify an object while it is still being initialized, causing software to access uninitialized memory.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-5021"},{"Reference":"CVE-2005-1036","Description":"Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap","Link":"https://www.cve.org/CVERecord?id=CVE-2005-1036"},{"Reference":"CVE-2008-3597","Description":"chain: game server can access player data structures before initialization has happened leading to NULL dereference","Link":"https://www.cve.org/CVERecord?id=CVE-2008-3597"},{"Reference":"CVE-2009-2692","Description":"chain: uninitialized function pointers can be dereferenced allowing code execution","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2692"},{"Reference":"CVE-2009-0949","Description":"chain: improper initialization of memory can lead to NULL dereference","Link":"https://www.cve.org/CVERecord?id=CVE-2009-0949"},{"Reference":"CVE-2009-3620","Description":"chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference","Link":"https://www.cve.org/CVERecord?id=CVE-2009-3620"}],"TaxonomyMappings":[{"TaxonomyName":"PLOVER","EntryName":"Incorrect initialization"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"ARR02-C","EntryName":"Explicitly specify array bounds, even if implicitly defined by an initializer"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"DCL00-J","EntryName":"Prevent class initialization cycles"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP4","EntryName":"Unchecked Status Condition"}],"RelatedAttackPatterns":["26","29"],"References":[{"ExternalReferenceID":"REF-436","Authors":["mercy"],"Title":"Exploiting Uninitialized Data","PublicationYear":"2006","PublicationMonth":"01","URL":"http://www.felinemenace.org/~mercy/papers/UBehavior/UBehavior.zip"},{"ExternalReferenceID":"REF-437","Authors":["Microsoft Security Vulnerability Research \u0026 Defense"],"Title":"MS08-014 : The Case of the Uninitialized Stack Variable Vulnerability","PublicationYear":"2008","PublicationMonth":"03","PublicationDay":"11","URL":"https://msrc.microsoft.com/blog/2008/03/ms08-014-the-case-of-the-uninitialized-stack-variable-vulnerability/","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-62","Section":"Chapter 7, \"Variable Initialization\", Page 312","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"}],"MappingNotes":{"Usage":"Discouraged","Rationale":"This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate","Comments":"Examine children of this entry to see if there is a better fit","Reasons":["Abstraction"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"PLOVER","SubmissionDate":"2008-04-11","SubmissionVersion":"Draft 9","SubmissionReleaseDate":"2008-04-11"},{"Type":"Modification","ModificationName":"Sean Eidemiller","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"added/updated demonstrative examples"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Potential_Mitigations, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-01-12","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Description, Likelihood_of_Exploit, Modes_of_Introduction, Name, Observed_Examples, Potential_Mitigations, References, Relationships, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-03-10","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-05-27","ModificationComment":"updated Description, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-07-27","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-10-29","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-02-16","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-04-05","ModificationComment":"updated Applicable_Platforms"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-06-21","ModificationComment":"updated Detection_Factors, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-09-27","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2013-02-21","ModificationComment":"updated Demonstrative_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2015-12-07","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-01-19","ModificationComment":"updated Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated References, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Related_Attack_Patterns, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-06-25","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description, Potential_Mitigations, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-02-29","ModificationComment":"updated Mapping_Notes","ModificationVersion":"4.14","ModificationReleaseDate":"2024-02-29"},{"Type":"Rename","PreviousEntryName":"Incorrect or Incomplete Initialization","Date":"2009-01-12"}]}