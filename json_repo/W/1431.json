{"ID":"1431","Name":"Driving Intermediate Cryptographic State/Results to Hardware Module Outputs","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product uses a hardware module implementing a cryptographic\n\t\t  algorithm that writes sensitive information about the intermediate\n\t\t  state or results of its cryptographic operations via one of its output\n\t\t  wires (typically the output port containing the final result).","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"200","ViewID":"1000","Ordinal":"Primary"},{"Nature":"PeerOf","CweID":"497","ViewID":"1000"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"System on Chip","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation","Note":"\n\nThis can occur when intermediate cryptographic states are directly assigned to output wires or ports.\n"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory","Read Application Data"],"Likelihood":["Unknown"],"Note":"\n\nMathematically sound cryptographic algorithms rely on their correct implementation for security. These assumptions might break when a hardware crypto module leaks intermediate encryption states or results such that they can be observed by an adversary. If intermediate state is observed, it might be possible for an attacker to identify the secrets used in the cryptographic operation.\n"}],"DetectionMethods":[{"Method":"Automated Static Analysis - Source Code","Description":"\n\nAutomated static analysis can find some instances of this weakness by analyzing source register-transfer level (RTL) code without having to simulate it or analyze it with a formal verification engine. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (signals with intermediate cryptographic state/results) with \"sinks\" (hardware module outputs and other signals outside of trusted cryptographic zone) without any control flow.\n","Effectiveness":"High","EffectivenessNotes":"\n\nStatic code analysis can sometimes lead to false positives.\n"},{"Method":"Simulation / Emulation","Description":"\n\nSimulation/emulation based analysis can find some instances of this weakness by simulating source register-transfer level (RTL) code along with a set of assertions that incorporate the simulated values of relevant design signals. Typically, these assertions will capture desired or undesired behavior. Analysis can be improved by using simulation-based information flow tracking (IFT) to more precisely detect unexpected results.\n","Effectiveness":"High","EffectivenessNotes":"\n\nSimulation/emulation based analysis can sometimes lead to false negatives if the testbench does not drive the design to a design state in which the assertion would fail.\n"},{"Method":"Formal Verification","Description":"\n\nFormal verification can find some instances of this weakness by exhaustively analyzing whether a given assertion holds true for a given hardware design specified in register-transfer level (RTL) code. Typically, these assertions will capture desired or undesired behavior. For this weakness, an assertion should check for undesired behavior in which one output is a signal that captures when a cryptographic algorithm has completely finished; another output is a signal with intermediate cryptographic state/results; and there is an assignment to a hardware module output or other signal outside of a trusted cryptographic zone.\n\n\nAlternatively, when using a formal IFT verification, the same undesired behavior can be detected by checking if computation results can ever leak to an output when the cryptographic result is not copmlete.\n","Effectiveness":"High","EffectivenessNotes":"\n\nFormal verification may not scale for RTL designs with a large state space.\n"},{"Method":"Manual Analysis","Description":"\n\nManual analysis can find some instances of this weakness by manually reviewing relevant lines of source register-transfer level (RTL) code to detect potentially-vulnerable patterns. Typically, the reviewer will trace the sequence of assignments that connect \"sources\" (signals with intermediate cryptographic state/results) with \"sinks\" (hardware module outputs and other signals outside of trusted cryptographic zone). If this sequence of assignments is missing adequate control flow, then the weakness is likely to exist.\n","Effectiveness":"Opportunistic","EffectivenessNotes":"\n\nManual analysis of source code is prone to errors (false positives and false negatives) and highly opportunistic.\n"}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"\n\nDesigners/developers should add or modify existing control flow logic along any data flow paths that connect \"sources\" (signals with intermediate cryptographic state/results) with \"sinks\" (hardware module outputs and other signals outside of trusted cryptographic zone). The control flow logic should only allow cryptographic results to be driven to \"sinks\" when appropriate conditions are satisfied (typically when the final result for a cryptographic operation has been generated). When the appropriate conditions are not satisfied (i.e., before or during a cryptographic operation), the control flow logic should drive a safe default value to \"sinks\".\n","Effectiveness":"High"},{"Phase":["Implementation"],"Description":"\n\nDesigners/developers should add or modify existing control flow logic along any data flow paths that connect \"sources\" (signals with intermediate cryptographic state/results) with \"sinks\" (hardware module outputs and other signals outside of trusted cryptographic zone). The control flow logic should only allow cryptographic results to be driven to \"sinks\" when appropriate conditions are satisfied (typically when the final result for a cryptographic operation has been generated). When the appropriate conditions are not satisfied (i.e., before or during a cryptographic operation), the control flow logic should drive a safe default value to \"sinks\".\n","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The following SystemVerilog code is a crypto module that takes input data and encrypts it by processing the data through multiple encryption rounds. Note: this example is derived from [REF-1469]."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"01 | module crypto_core_with_leakage\n 02 | (\n\n```\n\t 03 | input clk,\n\t 04 | input rst,\n\t 05 | input [127:0] data_i,\n\t 06 | output [127:0] data_o,\n\t 07 | output valid\n 08 | );\n 09 |\n 10 | localparam int total_rounds = 10;\n 11 | logic [3:0] round_id_q;\n 12 | logic [127:0] data_state_q, data_state_d;\n 13 | logic [127:0] key_state_q, key_state_d;\n 14 |\n 15 | crypto_algo_round u_algo_round (\n\t 16 | .clk (clk),\n\t 17 | .rst (rst),\n\t 18 | .round_i (round_id_q ),\n\t 19 | .key_i (key_state_q ),\n\t 20 | .data_i (data_state_q),\n\t 21 | .key_o (key_state_d ),\n\t 22 | .data_o (data_state_d)\n 23 | );\n 24 |\n 25 | always @(posedge clk) begin\n\t 26 | if (rst) begin\n\t\t 27 | data_state_q \u003c= 0;\n\t\t 28 | key_state_q \u003c= 0;\n\t\t 29 | round_id_q \u003c= 0;\n\t 30 | end\n\t 31 | else begin\n\t\t 32 | case (round_id_q)\n\t\t\t 33 | total_rounds: begin\n\t\t\t\t 34 | data_state_q \u003c= 0;\n\t\t\t\t 35 | key_state_q \u003c= 0;\n\t\t\t\t 36 | round_id_q \u003c= 0;\n\t\t\t 37 | end\n\t\t\t 38 |\n\t\t\t 39 | default: begin\n\t\t\t\t 40 | data_state_q \u003c= data_state_d;\n\t\t\t\t 41 | key_state_q \u003c= key_state_d;\n\t\t\t\t 42 | round_id_q \u003c= round_id_q + 1;\n\t\t\t 43 | end\n\t\t 44 | endcase\n\t 45 | end\n 46 | end\n 47 |\n 48 | assign valid = (round_id_q == total_rounds) ? 1'b1 : 1'b0;\n 49 |\n 50 | assign data_o = data_state_q;\n 51 |\n 52 | endmodule\n```"},{"BodyText":"In line 50 above, data_state_q is assigned to data_o. Since data_state_q contains intermediate state/results, this allows an attacker to obtain these results through data_o."},{"BodyText":"In line 50 of the fixed logic below, while \"data_state_q\" does not contain the final result, a \"sanitizing\" mechanism drives a safe default value (i.e., 0) to \"data_o\" instead of the value of \"data_state_q\". In doing so, the mechanism prevents the exposure of intermediate state/results which could be used to break soundness of the cryptographic operation being performed. A real-world example of this weakness and mitigation can be seen in a pull request that was submitted to the OpenTitan Github repository [REF-1469]."},{"Nature":"Good","Language":"Verilog","ExampleCode":"01 | module crypto_core_without_leakage\n 02 | (\n\n```\n\t 03 | input clk,\n\t 04 | input rst,\n\t 05 | input [127:0] data_i,\n\t 06 | output [127:0] data_o,\n\t 07 | output valid\n\t 08 | );\n 09 |\n 10 | localparam int total_rounds = 10;\n 11 | logic [3:0] round_id_q;\n 12 | logic [127:0] data_state_q, data_state_d;\n 13 | logic [127:0] key_state_q, key_state_d;\n 14 |\n 15 | crypto_algo_round u_algo_round (\n\t 16 | .clk (clk),\n\t 17 | .rst (rst),\n\t 18 | .round_i (round_id_q ),\n\t 19 | .key_i (key_state_q ),\n\t 20 | .data_i (data_state_q),\n\t 21 | .key_o (key_state_d ),\n\t 22 | .data_o (data_state_d)\n 23 | );\n 24 |\n 25 | always @(posedge clk) begin\n\t 26 | if (rst) begin\n\t\t 27 | data_state_q \u003c= 0;\n\t\t 28 | key_state_q \u003c= 0;\n\t\t 29 | round_id_q \u003c= 0;\n\t 30 | end\n\t 31 | else begin\n\t\t 32 | case (round_id_q)\n\t\t\t 33 | total_rounds: begin\n\t\t\t\t 34 | data_state_q \u003c= 0;\n\t\t\t\t 35 | key_state_q \u003c= 0;\n\t\t\t\t 36 | round_id_q \u003c= 0;\n\t\t\t 37 | end\n\t\t\t 38 |\n\t\t\t 39 | default: begin\n\t\t\t\t 40 | data_state_q \u003c= data_state_d;\n\t\t\t\t 41 | key_state_q \u003c= key_state_d;\n\t\t\t\t 42 | round_id_q \u003c= round_id_q + 1;\n\t\t\t 43 | end\n\t\t 44 | endcase\n\t 45 | end\n 46 | end\n 47 |\n 48 | assign valid = (round_id_q == total_rounds) ? 1'b1 : 1'b0;\n 49 |\n 50 | assign data_o = (valid) ? data_state_q : 0;\n 51 |\n 52 | endmodule\n```"}]}],"References":[{"ExternalReferenceID":"REF-1469","Authors":["Andres Meza"],"Title":"OpenTitan issue: [otp_ctrl] Prevent broadcast of scrambler's input/intermediate values #13043","PublicationYear":"2022","PublicationMonth":"06","PublicationDay":"03","URL":"https://github.com/lowRISC/opentitan/pull/13043","URLDate":"2025-04-02"},{"ExternalReferenceID":"REF-1470","Authors":["Andres Meza","Francesco Restuccia","Jason Oberg","Dominic Rizzo","Ryan Kastner"],"Title":"Security Verification of the OpenTitan Hardware Root of Trust","PublicationYear":"2023","PublicationMonth":"04","PublicationDay":"20","URL":"https://ieeexplore.ieee.org/document/10106105","URLDate":"2025-04-02"},{"ExternalReferenceID":"REF-1471","Authors":["Jason Oberg"],"Title":"Security Verification of an Open Source Hardware Root of Trust","PublicationYear":"2022","PublicationMonth":"08","PublicationDay":"03","URL":"https://cycuity.com/type/blog/security-verification-of-an-open-source-hardware-root-of-trust/","URLDate":"2025-04-02"},{"ExternalReferenceID":"REF-1472","Authors":["Christophe Clavier","Quentin Isorez","Damien Marion","Antoine Wurcker"],"Title":"Complete reverse-engineering of AES-like block ciphers by SCARE and FIRE attacks","PublicationYear":"2014","PublicationMonth":"10","PublicationDay":"23","URL":"https://doi.org/10.1007/s12095-014-0112-7","URLDate":"2025-04-02"},{"ExternalReferenceID":"REF-1473","Authors":["Dirmanto Jap","Shivam Bhasin"],"Title":"Practical Reverse Engineering of Secret Sboxes by Side-Channel Analysis","PublicationYear":"2020","PublicationMonth":"10","URL":"https://doi.org/10.1109/ISCAS45731.2020.9180848","URLDate":"2025-04-02"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Andres Meza","SubmissionOrganization":"University of California, San Diego","SubmissionDate":"2022-08-15","SubmissionVersion":"4.17","SubmissionReleaseDate":"2025-04-03"}]}