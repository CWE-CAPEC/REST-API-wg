{"ID":"786","Name":"Access of Memory Location Before Start of Buffer","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.","ExtendedDescription":"This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"119","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1305","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1340","Ordinal":"Primary"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory"],"Note":"For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."},{"Scope":["Integrity","Availability"],"Impact":["Modify Memory","DoS: Crash, Exit, or Restart"],"Note":"Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash."},{"Scope":["Integrity"],"Impact":["Modify Memory","Execute Unauthorized Code or Commands"],"Note":"If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code. If the corrupted memory is data rather than instructions, the system will continue to function with improper changes, possibly in violation of an implicit or explicit policy."}],"DetectionMethods":[{"DetectionMethodID":"DM-13","Method":"Fuzzing","Description":"Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.","Effectiveness":"High"}],"DemonstrativeExamples":[{"ID":"DX-87","Entries":[{"IntroText":"In the following C/C++ example, a utility function is used to trim trailing whitespace from a character string. The function copies the input string to a local character string and uses a while statement to remove the trailing whitespace by moving backward through the string and overwriting whitespace with a NUL character."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar* trimTrailingWhitespace(char *strMessage, int length) {\n\t\t\tchar *retMessage;\n\t\t\tchar *message = malloc(sizeof(char)*(length+1));\n```\n// copy input string to a temporary string* \n\t\t\tchar message[length+1];\n\t\t\tint index;\n\t\t\tfor (index = 0; index \u003c length; index++) {\n\t\t\t```\n\t\t\t\tmessage[index] = strMessage[index];\n\t\t\t}\n\t\t\tmessage[index] = '\\0';\n```\n// trim trailing whitespace* \n\t\t\tint len = index-1;\n\t\t\twhile (isspace(message[len])) {\n\t\t\t```\n\t\t\t\tmessage[len] = '\\0';\n\t\t\t\tlen--;\n\t\t\t}\n```\n// return string without trailing whitespace* \n\t\t\tretMessage = message;\n\t\t\treturn retMessage;}"},{"BodyText":"However, this function can cause a buffer underwrite if the input character string contains all whitespace. On some systems the while statement will move backwards past the beginning of a character string and will call the isspace() function on an address outside of the bounds of the local buffer."}]},{"ID":"DX-90","Entries":[{"IntroText":"The following example asks a user for an offset into an array to select an item."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint main (int argc, char **argv) {\n\t\tchar *items[] = {\"boat\", \"car\", \"truck\", \"train\"};\n\t\tint index = GetUntrustedOffset();\n\t\tprintf(\"You selected %s\\n\", items[index-1]);\n\t}\n```"},{"BodyText":"The programmer allows the user to specify which element in the list to select, however an attacker can provide an out-of-bounds offset, resulting in a buffer over-read (CWE-126)."}]},{"ID":"DX-88","Entries":[{"IntroText":"The following is an example of code that may result in a buffer underwrite. This code is attempting to replace the substring \"Replace Me\" in destBuf with the string stored in srcBuf. It does so by using the function strstr(), which returns a pointer to the found substring in destBuf. Using pointer arithmetic, the starting index of the substring is found."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint main() { \n\t\t...\n\t\t char *result = strstr(destBuf, \"Replace Me\");\n\t\t int idx = result - destBuf;\n\t\t strcpy(\u0026destBuf[idx], srcBuf);\n\t\t ...\n\t} \n```"},{"BodyText":"In the case where the substring is not found in destBuf, strstr() will return NULL, causing the pointer arithmetic to be undefined, potentially setting the value of idx to a negative number. If idx is negative, this will result in a buffer underwrite of destBuf."}]}],"ObservedExamples":[{"Reference":"CVE-2002-2227","Description":"Unchecked length of SSLv2 challenge value leads to buffer underflow.","Link":"https://www.cve.org/CVERecord?id=CVE-2002-2227"},{"Reference":"CVE-2007-4580","Description":"Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130)","Link":"https://www.cve.org/CVERecord?id=CVE-2007-4580"},{"Reference":"CVE-2007-1584","Description":"Buffer underflow from an all-whitespace string, which causes a counter to be decremented before the buffer while looking for a non-whitespace character.","Link":"https://www.cve.org/CVERecord?id=CVE-2007-1584"},{"Reference":"CVE-2007-0886","Description":"Buffer underflow resultant from encoded data that triggers an integer overflow.","Link":"https://www.cve.org/CVERecord?id=CVE-2007-0886"},{"Reference":"CVE-2006-6171","Description":"Product sets an incorrect buffer size limit, leading to \"off-by-two\" buffer underflow.","Link":"https://www.cve.org/CVERecord?id=CVE-2006-6171"},{"Reference":"CVE-2006-4024","Description":"Negative value is used in a memcpy() operation, leading to buffer underflow.","Link":"https://www.cve.org/CVERecord?id=CVE-2006-4024"},{"Reference":"CVE-2004-2620","Description":"Buffer underflow due to mishandled special characters","Link":"https://www.cve.org/CVERecord?id=CVE-2004-2620"}],"TaxonomyMappings":[{"TaxonomyName":"CERT C Secure Coding","EntryID":"ARR30-C","EntryName":"Do not form or use out-of-bounds pointers or array subscripts","MappingFit":"CWE More Specific"}],"MappingNotes":{"Usage":"Discouraged","Rationale":"The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.","Comments":"If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.","Reasons":["Potential Deprecation","Frequent Misuse"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2009-10-21","SubmissionVersion":"1.6","SubmissionReleaseDate":"2009-10-29"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Observed_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-02-29","ModificationComment":"updated Demonstrative_Examples","ModificationVersion":"4.14","ModificationReleaseDate":"2024-02-29"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-07-16","ModificationComment":"updated Common_Consequences","ModificationVersion":"4.15","ModificationReleaseDate":"2024-07-16"}]}