{"ID":"191","Name":"Integer Underflow (Wrap or Wraparound)","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.","ExtendedDescription":"This can happen in signed and unsigned cases.","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"682","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"682","ViewID":"1003","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"},{"Ordinality":"Resultant"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"},{"Type":"Language","Name":"Java","Prevalence":"Undetermined"},{"Type":"Language","Name":"C#","Prevalence":"Undetermined"}],"AlternateTerms":[{"Term":"Integer underflow","Description":"\n\n\"Integer underflow\" is sometimes used to identify signedness errors in which an originally positive number becomes negative as a result of subtraction. However, there are cases of bad subtraction in which unsigned integers are involved, so it's not always a signedness issue.\n\n\n\"Integer underflow\" is occasionally used to describe array index errors in which the index is negative.\n"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Crash, Exit, or Restart","DoS: Resource Consumption (CPU)","DoS: Resource Consumption (Memory)","DoS: Instability"],"Note":"This weakness will generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high."},{"Scope":["Integrity"],"Impact":["Modify Memory"],"Note":"If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the wrap around results in other conditions such as buffer overflows, further memory corruption may occur."},{"Scope":["Confidentiality","Availability","Access Control"],"Impact":["Execute Unauthorized Code or Commands","Bypass Protection Mechanism"],"Note":"This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy."}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The following example subtracts from a 32 bit signed integer."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t#include \u003cstdio.h\u003e\n\t#include \u003cstdbool.h\u003e\n\tmain (void)\n\t{\n\t\tint i;\n\t\ti = -2147483648;\n\t\ti = i - 1;\n\t\treturn 0;\n\t}\n```"},{"BodyText":"The example has an integer underflow. The value of i is already at the lowest negative value possible, so after subtracting 1, the new value of i is 2147483647."}]},{"ID":"DX-137","Entries":[{"IntroText":"This code performs a stack allocation based on a length calculation."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t int a = 5, b = 6;\n\t size_t len = a - b;\n\t char buf[len]; // Just blows up the stack \n }\n```"},{"BodyText":"Since a and b are declared as signed ints, the \"a - b\" subtraction gives a negative result (-1). However, since len is declared to be unsigned, len is cast to an extremely large positive number (on 32-bit systems - 4294967295). As a result, the buffer buf[len] declaration uses an extremely large size to allocate on the stack, very likely more than the entire computer's memory space."},{"BodyText":"Miscalculations usually will not be so obvious. The calculation will either be complicated or the result of an attacker's input to attain the negative value."}]}],"ObservedExamples":[{"Reference":"CVE-2004-0816","Description":"Integer underflow in firewall via malformed packet.","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0816"},{"Reference":"CVE-2004-1002","Description":"Integer underflow by packet with invalid length.","Link":"https://www.cve.org/CVERecord?id=CVE-2004-1002"},{"Reference":"CVE-2005-0199","Description":"Long input causes incorrect length calculation.","Link":"https://www.cve.org/CVERecord?id=CVE-2005-0199"},{"Reference":"CVE-2005-1891","Description":"Malformed icon causes integer underflow in loop counter variable.","Link":"https://www.cve.org/CVERecord?id=CVE-2005-1891"}],"TaxonomyMappings":[{"TaxonomyName":"PLOVER","EntryName":"Integer underflow (wrap or wraparound)"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP1","EntryName":"Glitch in computation"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"INT30-C","EntryName":"Ensure that unsigned integer operations do not wrap","MappingFit":"Imprecise"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"INT32-C","EntryName":"Ensure that operations on signed integers do not result in overflow","MappingFit":"Imprecise"}],"References":[{"ExternalReferenceID":"REF-44","Section":"\"Sin 7: Integer Overflows.\" Page 119","Authors":["Michael Howard","David LeBlanc","John Viega"],"Title":"24 Deadly Sins of Software Security","Publication":"McGraw-Hill","PublicationYear":"2010"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"PLOVER","SubmissionDate":"2006-07-19","SubmissionVersion":"Draft 3","SubmissionReleaseDate":"2006-07-19"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Demonstrative_Example"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Alternate_Terms, Applicable_Platforms, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-10-14","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-05-27","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-27","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Common_Consequences, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Demonstrative_Examples, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2015-12-07","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Research_Gaps"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-12-11","ModificationComment":"updated Weakness_Ordinalities","ModificationVersion":"4.19","ModificationReleaseDate":"2025-12-11"}]}