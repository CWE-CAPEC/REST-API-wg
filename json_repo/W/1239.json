{"ID":"1239","Name":"Improper Zeroization of Hardware Register","Abstraction":"Variant","Structure":"Simple","Status":"Draft","Description":"The hardware product does not properly clear sensitive information from built-in registers when the user of the hardware block changes.","ExtendedDescription":"Hardware logic operates on data stored in registers local to the hardware block. Most hardware IPs, including cryptographic accelerators, rely on registers to buffer I/O, store intermediate values, and interface with software. The result of this is that sensitive information, such as passwords or encryption keys, can exist in locations not transparent to the user of the hardware logic. When a different entity obtains access to the IP due to a change in operating mode or conditions, the new entity can extract information belonging to the previous user if no mechanisms are in place to clear register contents. It is important to clear information stored in the hardware if a physical attack on the product is detected, or if the user of the hardware block changes. The process of clearing register contents in a hardware IP is referred to as zeroization in standards for cryptographic hardware modules such as FIPS-140-2 [REF-267].","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"226","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"226","ViewID":"1194","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"System on Chip","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"Lack of hardware mechanisms to zeroize or clear registers in the design or specification."},{"Phase":"Implementation","Note":"Mechanisms to zeroize and clear registers are in the design but implemented incorrectly."},{"Phase":"Operation","Note":"Hardware-provided zeroization mechanisms are not used appropriately by the IP user (ex. firmware), or data remanence issues are not taken into account."}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Varies by Context"],"Note":"The consequences will depend on the information disclosed due to the vulnerability."}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"Every register potentially containing sensitive information must have a policy specifying how and when information is cleared, in addition to clarifying if it is the responsibility of the hardware logic or IP user to initiate the zeroization procedure at the appropriate time.","EffectivenessNotes":"Unfortunately, data disclosure can occur even after information has been overwritten/zeroized from the digital perspective. Physical characteristics of the memory can reveal the history of previously written data. For example, if the same value is written repeatedly to a memory location, the corresponding memory cells can become physically altered to a degree that even if the original data is erased it can still be recovered through physical characterization of the memory cells [REF-1055]."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"Suppose a hardware IP for implementing an encryption routine works as expected, but it leaves the intermediate results in some registers that can be accessed. Exactly why this access happens is immaterial - it might be unintentional or intentional, where the designer wanted a \"quick fix\" for something."}]},{"Entries":[{"IntroText":"The example code below [REF-1379] is taken from the SHA256 Interface/wrapper controller module of the HACK@DAC'21 buggy OpenPiton SoC. Within the wrapper module there are a set of 16 memory-mapped registers referenced data[0] to data[15]. These registers are 32 bits in size and are used to store the data received on the AXI Lite interface for hashing. Once both the message to be hashed and a request to start the hash computation are received, the values of these registers will be forwarded to the underlying SHA256 module for processing. Once forwarded, the values in these registers no longer need to be retained. In fact, if not cleared or overwritten, these sensitive values can be read over the AXI Lite interface, potentially compromising any previously confidential data stored therein."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"...\n\n```\n\t // Implement SHA256 I/O memory map interface\n\t // Write side\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~rst_3))\n\t\t\t\t begin\n\t\t\t\t\t startHash \u003c= 0;\n\t\t\t\t\t newMessage \u003c= 0;\n\t\t\t\t\t data[0] \u003c= 0;\n\t\t\t\t\t data[1] \u003c= 0;\n\t\t\t\t\t data[2] \u003c= 0;\n\t\t\t\t\t ...\n\t\t\t\t\t data[14] \u003c= 0;\n\t\t\t\t\t data[15] \u003c= 0;\n ...\n```"},{"BodyText":"In the previous code snippet [REF-1379] there is the lack of a data clearance mechanism for the memory-mapped I/O registers after their utilization. These registers get cleared only when a reset condition is met. This condition is met when either the global negative-edge reset input signal (rst_ni) or the dedicated reset input signal for SHA256 peripheral (rst_3) is active. In other words, if either of these reset signals is true, the registers will be cleared. However, in cases where there is not a reset condition these registers retain their values until the next hash operation. It is during the time between an old hash operation and a new hash operation that that data is open to unauthorized disclosure."},{"BodyText":"To correct the issue of data persisting between hash operations, the memory mapped I/O registers need to be cleared once the values written in these registers are propagated to the SHA256 module. This could be done for example by adding a new condition to zeroize the memory mapped I/O registers once the hash value is computed, i.e., hashValid signal asserted, as shown in the good code example below [REF-1380]. This fix will clear the memory-mapped I/O registers after the data has been provided as input to the SHA engine."},{"Nature":"Good","Language":"Verilog","ExampleCode":"...\n\n```\n\t // Implement SHA256 I/O memory map interface\n\t // Write side\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~rst_3))\n\t\t\t\t begin\n\t\t\t\t\t startHash \u003c= 0;\n\t\t\t\t\t newMessage \u003c= 0;\n\t\t\t\t\t data[0] \u003c= 0;\n\t\t\t\t\t data[1] \u003c= 0;\n\t\t\t\t\t data[2] \u003c= 0;\n\t\t\t\t\t ...\n\t\t\t\t\t data[14] \u003c= 0;\n\t\t\t\t\t data[15] \u003c= 0;\n\t\t\t\t end\n```\nelse if(hashValid \u0026\u0026 ~hashValid_r)** \n\t\t\t```\n```\nbegin** \n\t\t\t\t```\n```\ndata[0] \u003c= 0;** \n\t\t\t\t\t\n\t\t\t\t\t **data[1] \u003c= 0;** \n\t\t\t\t\t\n\t\t\t\t\t **data[2] \u003c= 0;** \n\t\t\t\t\t\n\t\t\t\t\t **...** \n\t\t\t\t\t\n\t\t\t\t\t **data[14] \u003c= 0;** \n\t\t\t\t\t\n\t\t\t\t\t **data[15] \u003c= 0;** \n\t\t\t\t\t end\n\t\t\t\t ..."}]}],"RelatedAttackPatterns":["150","204","37","545"],"References":[{"ExternalReferenceID":"REF-267","Authors":["Information Technology Laboratory, National Institute of Standards and Technology"],"Title":"SECURITY REQUIREMENTS FOR CRYPTOGRAPHIC MODULES","PublicationYear":"2001","PublicationMonth":"05","PublicationDay":"25","URL":"https://csrc.nist.gov/csrc/media/publications/fips/140/2/final/documents/fips1402.pdf","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-1055","Authors":["Peter Gutmann"],"Title":"Data Remanence in Semiconductor Devices","Publication":"10th USENIX Security Symposium","PublicationYear":"2001","PublicationMonth":"08","URL":"https://www.usenix.org/legacy/events/sec01/full_papers/gutmann/gutmann.pdf"},{"ExternalReferenceID":"REF-1379","Title":"sha256_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/b9ecdf6068445d76d6bee692d163fededf7a9d9b/piton/design/chip/tile/ariane/src/sha256/sha256_wrapper.sv#L94-L116","URLDate":"2023-12-13"},{"ExternalReferenceID":"REF-1380","Title":"Fix for sha256_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/e8ba396b5c7cec9031e0e0e18ac547f32cd0ed50/piton/design/chip/tile/ariane/src/sha256/sha256_wrapper.sv#L98C1-L139C18","URLDate":"2023-12-13"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Nicole Fern","SubmissionOrganization":"Tortuga Logic","SubmissionDate":"2020-02-08","SubmissionVersion":"4.0","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-02-29","ModificationComment":"updated Demonstrative_Examples, References","ModificationVersion":"4.14","ModificationReleaseDate":"2024-02-29"},{"Type":"Contribution","ContributionName":"Chen Chen, Rahul Kande, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"}]}