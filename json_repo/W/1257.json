{"ID":"1257","Name":"Improper Access Control Applied to Mirrored or Aliased Memory Regions","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"Aliased or mirrored memory regions in hardware designs may have inconsistent read/write permissions enforced by the hardware. A possible result is that an untrusted agent is blocked from accessing a memory region but is not blocked from accessing the corresponding aliased memory region.\n\t\t\t","ExtendedDescription":"\n\nHardware product designs often need to implement memory protection features that enable privileged software to define isolated memory regions and access control (read/write) policies. Isolated memory regions can be defined on different memory spaces in a design (e.g. system physical address, virtual address, memory mapped IO).\n\n\nEach memory cell should be mapped and assigned a system address that the core software can use to read/write to that memory. It is possible to map the same memory cell to multiple system addresses such that read/write to any of the aliased system addresses would be decoded to the same memory cell.\n\n\nThis is commonly done in hardware designs for redundancy and simplifying address decoding logic. If one of the memory regions is corrupted or faulty, then that hardware can switch to using the data in the mirrored memory region. Memory aliases can also be created in the system address map if the address decoder unit ignores higher order address bits when mapping a smaller address region into the full system address.\n\n\nA common security weakness that can exist in such memory mapping is that aliased memory regions could have different read/write access protections enforced by the hardware such that an untrusted agent is blocked from accessing a memory address but is not blocked from accessing the corresponding aliased memory address. Such inconsistency can then be used to bypass the access protection of the primary memory block and read or modify the protected memory.\n\n\nAn untrusted agent could also possibly create memory aliases in the system address map for malicious purposes if it is able to change the mapping of an address region or modify memory region sizes.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"284","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"119","ViewID":"1000"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Memory Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Processor Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Microcontroller Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Network on Chip Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Class":"System on Chip","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory"],"Likelihood":["High"]},{"Scope":["Integrity"],"Impact":["Modify Memory"],"Likelihood":["High"]},{"Scope":["Availability"],"Impact":["DoS: Instability"],"Likelihood":["High"]}],"PotentialMitigations":[{"Phase":["Architecture and Design","Implementation"],"Description":"The checks should be applied for consistency access rights between primary memory regions and any mirrored or aliased memory regions. If different memory protection units (MPU) are protecting the aliased regions, their protected range definitions and policies should be synchronized."},{"Phase":["Architecture and Design","Implementation"],"Description":"The controls that allow enabling memory aliases or changing the size of mapped memory regions should only be programmable by trusted software components."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"In a System-on-a-Chip (SoC) design the system fabric uses 16 bit addresses. An IP unit (Unit_A) has 4 kilobyte of internal memory which is mapped into a 16 kilobyte address range in the system fabric address map.\n\n|  | \n|\n|  System Address  |  Mapped to   |\n|  0x0000 - 0x3FFF  |  Unit_A registers : 0x0000 - 0x0FFF   |\n|  0x4000 - 0xFFFF  |  Other IPs \u0026 Memory   |\n\n\t\n To protect the register controls in Unit_A unprivileged software is blocked from accessing addresses between 0x0000 - 0x0FFF. \n\n\t\n The address decoder of Unit_A masks off the higher order address bits and decodes only the lower 12 bits for computing the offset into the 4 kilobyte internal memory space."},{"Nature":"Bad","Language":"Other","ExampleCode":"In this design the aliased memory address ranges are these:\n\n\n\n0x0000 - 0x0FFF\n\n\n0x1000 - 0x1FFF\n\n\n0x2000 - 0x2FFF\n\n\n0x3000 - 0x3FFF\n\n\n The same register can be accessed using four different addresses: 0x0000, 0x1000, 0x2000, 0x3000. \n\n\n The system address filter only blocks access to range 0x0000 - 0x0FFF and does not block access to the aliased addresses in 0x1000 - 0x3FFF range. Thus, untrusted software can leverage the aliased memory addresses to bypass the memory protection."},{"Nature":"Good","Language":"Other","ExampleCode":"In this design the aliased memory addresses (0x1000 - 0x3FFF) could be blocked from all system software access since they are not used by software. \n\n\n Alternately, the MPU logic can be changed to apply the memory protection policies to the full address range mapped to Unit_A (0x0000 - 0x3FFF)."}]}],"RelatedAttackPatterns":["456","679"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-04-29","SubmissionVersion":"4.1","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Demonstrative_Examples, Description, Modes_of_Introduction, Potential_Mitigations, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Applicable_Platforms, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-06-28","ModificationComment":"updated Applicable_Platforms"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}