{"ID":"1421","Name":"Exposure of Sensitive Information in Shared Microarchitectural Structures during Transient Execution","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"\n\t\t\tA processor event may allow transient operations to access\n\t\t\tarchitecturally restricted data (for example, in another address\n\t\t\tspace) in a shared microarchitectural structure (for example, a CPU\n\t\t\tcache), potentially exposing the data over a covert channel.\n\t\t  ","ExtendedDescription":"\n\nMany commodity processors have Instruction Set Architecture (ISA) features that protect software components from one another. These features can include memory segmentation, virtual memory, privilege rings, trusted execution environments, and virtual machines, among others. For example, virtual memory provides each process with its own address space, which prevents processes from accessing each other's private data. Many of these features can be used to form hardware-enforced security boundaries between software components.\n\n\nMany commodity processors also share microarchitectural resources that cache (temporarily store) data, which may be confidential. These resources may be shared across processor contexts, including across SMT threads, privilege rings, or others.\n\n\nWhen transient operations allow access to ISA-protected data in a shared microarchitectural resource, this might violate users' expectations of the ISA feature that is bypassed. For example, if transient operations can access a victim's private data in a shared microarchitectural resource, then the operations' microarchitectural side effects may correspond to the accessed data. If an attacker can trigger these transient operations and observe their side effects through a covert channel [REF-1400], then the attacker may be able to infer the victim's private data. Private data could include sensitive program data, OS/VMM data, page table data (such as memory addresses), system configuration data (see Demonstrative Example 3), or any other data that the attacker does not have the required privileges to access.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"1420","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"1420","ViewID":"1194","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"\n\nThis weakness can be introduced during hardware architecture and design if a data path allows architecturally restricted data to propagate to operations that execute before an older mis-prediction or processor event (such as an exception) is caught.\n"},{"Phase":"Implementation","Note":"\n\nThis weakness can be introduced during system software implementation if state-sanitizing operations are not invoked when switching from one context to another, according to the hardware vendor's recommendations for mitigating the weakness.\n"},{"Phase":"System Configuration","Note":"\n\nThis weakness can be introduced if the system has not been configured according to the hardware vendor's recommendations for mitigating the weakness.\n"},{"Phase":"Architecture and Design","Note":"\n\nThis weakness can be introduced when an access control check (for example, checking page permissions) can proceed in parallel with the access operation (for example, a load) that is being checked. If the processor can allow the access operation to execute before the check completes, this race condition may allow subsequent transient operations to expose sensitive information.\n"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory"],"Likelihood":["Medium"],"Note":"\n\n\u003c\u003cput the information here\u003e\u003e\n"}],"DetectionMethods":[{"Method":"Manual Analysis","Description":"\n\nThis weakness can be detected in hardware by manually inspecting processor specifications. Features that exhibit this weakness may include microarchitectural predictors, access control checks that occur out-of-order, or any other features that can allow operations to execute without committing to architectural state. Academic researchers have demonstrated that new hardware weaknesses can be discovered by examining publicly available patent filings, for example [REF-1405] and [REF-1406]. Hardware designers can also scrutinize aspects of the instruction set architecture that have undefined behavior; these can become a focal point when applying other detection methods. \n","Effectiveness":"Moderate","EffectivenessNotes":"Manual analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."},{"Method":"Automated Analysis","Description":"\n\nThis weakness can be detected (pre-discovery) in hardware by employing static or dynamic taint analysis methods [REF-1401]. These methods can label data in one context (for example, kernel data) and perform information flow analysis (or a simulation, etc.) to determine whether tainted data can appear in another context (for example, user mode). Alternatively, stale or invalid data in shared microarchitectural resources can be marked as tainted, and the taint analysis framework can identify when transient operations encounter tainted data.\n","Effectiveness":"Moderate","EffectivenessNotes":"Automated static or dynamic taint analysis may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."},{"Method":"Automated Analysis","Description":"\n\nSoftware vendors can release tools that detect presence of known weaknesses (post-discovery) on a processor. For example, some of these tools can attempt to transiently execute a vulnerable code sequence and detect whether code successfully leaks data in a manner consistent with the weakness under test. Alternatively, some hardware vendors provide enumeration for the presence of a weakness (or lack of a weakness). These enumeration bits can be checked and reported by system software. For example, Linux supports these checks for many commodity processors:\n\n\n$ cat /proc/cpuinfo | grep bugs | head -n 1\n\n\nbugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa itlb_multihit srbds mmio_stale_data retbleed\n","Effectiveness":"High","EffectivenessNotes":"This method can be useful for detecting whether a processor if affected by known weaknesses, but it may not be useful for detecting unknown weaknesses."},{"Method":"Fuzzing","Description":"Academic researchers have demonstrated that this weakness can be detected in hardware using software fuzzing tools that treat the underlying hardware as a black box ([REF-1406], [REF-1430])","Effectiveness":"Opportunistic","EffectivenessNotes":"Fuzzing may not reveal all weaknesses in a processor specification and should be combined with other detection methods to improve coverage."}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"\n\nHardware designers may choose to engineer the processor's pipeline to prevent architecturally restricted data from being used by operations that can execute transiently.\n","Effectiveness":"High"},{"Phase":["Architecture and Design"],"Description":"\n\nHardware designers may choose not to share microarchitectural resources that can contain sensitive data, such as fill buffers and store buffers.\n","Effectiveness":"Moderate","EffectivenessNotes":"\n\nThis can be highly effective at preventing this weakness from being exposed across different SMT threads or different processor cores. It is generally less practical to isolate these resources between different contexts (for example, user and kernel) that may execute on the same SMT thread or processor core.\n"},{"Phase":["Architecture and Design"],"Description":"\n\nHardware designers may choose to sanitize specific microarchitectural state (for example, store buffers) when the processor transitions to a different context, such as whenever a system call is invoked. Alternatively, the hardware may expose instruction(s) that allow software to sanitize microarchitectural state according to the user or system administrator's threat model. These mitigation approaches are similar to those that address CWE-226; however, sanitizing microarchitectural state may not be the optimal or best way to mitigate this weakness on every processor design.\n","Effectiveness":"Moderate","EffectivenessNotes":"\n\nSanitizing shared state on context transitions may not be practical for all processors, especially when the amount of shared state affected by the weakness is relatively large. Additionally, this technique may not be practical unless there is a synchronous transition between two processor contexts that would allow the affected resource to be sanitized. For example, this technique alone may not suffice to mitigate asynchronous access to a resource that is shared by two SMT threads.\n"},{"Phase":["Architecture and Design"],"Description":"\n\nThe hardware designer can attempt to prevent transient execution from causing observable discrepancies in specific covert channels.\n","Effectiveness":"Limited","EffectivenessNotes":"\n\nThis technique has many pitfalls. For example, InvisiSpec was an early attempt to mitigate this weakness by blocking \"micro-architectural covert and side channels through the multiprocessor data cache hierarchy due to speculative loads\" [REF-1417]. Commodity processors and SoCs have many covert and side channels that exist outside of the data cache hierarchy. Even when some of these channels are blocked, others (such as execution ports [REF-1418]) may allow an attacker to infer confidential data. Mitigation strategies that attempt to prevent transient execution from causing observable discrepancies also have other pitfalls, for example, see [REF-1419].\n"},{"Phase":["Architecture and Design"],"Description":"\n\nSoftware architects may design software to enforce strong isolation between different contexts. For example, kernel page table isolation (KPTI) mitigates the Meltdown vulnerability [REF-1401] by separating user-mode page tables from kernel-mode page tables, which prevents user-mode processes from using Meltdown to transiently access kernel memory [REF-1404].\n","Effectiveness":"Limited","EffectivenessNotes":"\n\nIsolating different contexts across a process boundary (or another kind of architectural boundary) may only be effective for some weaknesses.\n"},{"Phase":["Build and Compilation"],"Description":"\n\nIf the weakness is exposed by a single instruction (or a small set of instructions), then the compiler (or JIT, etc.) can be configured to prevent the affected instruction(s) from being generated, and instead generate an alternate sequence of instructions that is not affected by the weakness.\n","Effectiveness":"Limited","EffectivenessNotes":"\n\nThis technique may only be fully effective if it is applied to all software that runs on the system. Also, relatively few observed examples of this weakness have exposed data through only a single instruction.\n"},{"Phase":["Build and Compilation"],"Description":"\n\nUse software techniques (including the use of serialization instructions) that are intended to reduce the number of instructions that can be executed transiently after a processor event or misprediction.\n","Effectiveness":"Incidental","EffectivenessNotes":"\n\nSome transient execution weaknesses can be exploited even if a single instruction is executed transiently after a processor event or mis-prediction. This mitigation strategy has many other pitfalls that prevent it from eliminating this weakness entirely. For example, see [REF-1389].\n"},{"Phase":["Implementation"],"Description":"\n\nSystem software can mitigate this weakness by invoking state-sanitizing operations when switching from one context to another, according to the hardware vendor's recommendations.\n","Effectiveness":"Limited","EffectivenessNotes":"\n\nThis technique may not be able to mitigate weaknesses that arise from resource sharing across SMT threads.\n"},{"Phase":["System Configuration"],"Description":"\n\nSome systems may allow the user to disable (for example, in the BIOS) sharing of the affected resource.\n","Effectiveness":"Limited","EffectivenessNotes":"\n\nDisabling resource sharing (for example, by disabling SMT) may result in significant performance overhead.\n"},{"Phase":["System Configuration"],"Description":"\n\nSome systems may allow the user to disable (for example, in the BIOS) microarchitectural features that allow transient access to architecturally restricted data.\n","Effectiveness":"Limited","EffectivenessNotes":"\n\nDisabling microarchitectural features such as predictors may result in significant performance overhead.\n"},{"Phase":["Patching and Maintenance"],"Description":"\n\nThe hardware vendor may provide a patch to sanitize the affected shared microarchitectural state when the processor transitions to a different context.\n","Effectiveness":"Moderate","EffectivenessNotes":"\n\nThis technique may not be able to mitigate weaknesses that arise from resource sharing across SMT threads.\n"},{"Phase":["Patching and Maintenance"],"Description":"\n\nThis kind of patch may not be feasible or implementable for all processors or all weaknesses.\n","Effectiveness":"Limited"},{"Phase":["Requirements"],"Description":"\n\nProcessor designers, system software vendors, or other agents may choose to restrict the ability of unprivileged software to access to high-resolution timers that are commonly used to monitor covert channels.\n","Effectiveness":"Defense in Depth","EffectivenessNotes":"\n\nSpecific software algorithms can be used by an attacker to compensate for a lack of a high-resolution time source [REF-1420].\n"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"Some processors may perform access control checks in parallel with memory read/write operations. For example, when a user-mode program attempts to read data from memory, the processor may also need to check whether the memory address is mapped into user space or kernel space. If the processor performs the access concurrently with the check, then the access may be able to transiently read kernel data before the check completes. This race condition is demonstrated in the following code snippet from [REF-1408], with additional annotations:"},{"Nature":"Bad","Language":"x86 Assembly","ExampleCode":"1 ; rcx = kernel address, rbx = probe array\n 2 xor rax, rax # set rax to 0\n 3 retry:\n 4 mov al, byte [rcx] # attempt to read kernel memory\n 5 shl rax, 0xc # multiply result by page size (4KB)\n 6 jz retry # if the result is zero, try again\n 7 mov rbx, qword [rbx + rax] # transmit result over a cache covert channel"},{"BodyText":"Vulnerable processors may return kernel data from a shared microarchitectural resource in line 4, for example, from the processor's L1 data cache. Since this vulnerability involves a race condition, the mov in line 4 may not always return kernel data (that is, whenever the check \"wins\" the race), in which case this demonstration code re-attempts the access in line 6. The accessed data is multiplied by 4KB, a common page size, to make it easier to observe via a cache covert channel after the transmission in line 7. The use of cache covert channels to observe the side effects of transient execution has been described in [REF-1408]."}]},{"Entries":[{"IntroText":"Many commodity processors share microarchitectural fill buffers between sibling hardware threads on simultaneous multithreaded (SMT) processors. Fill buffers can serve as temporary storage for data that passes to and from the processor's caches. Microarchitectural Fill Buffer Data Sampling (MFBDS) is a vulnerability that can allow a hardware thread to access its sibling's private data in a shared fill buffer. The access may be prohibited by the processor's ISA, but MFBDS can allow the access to occur during transient execution, in particular during a faulting operation or an operation that triggers a microcode assist.\n\n\nMore information on MFBDS can be found in [REF-1405] and [REF-1409]."}]},{"Entries":[{"IntroText":"Some processors may allow access to system registers (for example, system coprocessor registers or model-specific registers) during transient execution. This scenario is depicted in the code snippet below. Under ordinary operating circumstances, code in exception level 0 (EL0) is not permitted to access registers that are restricted to EL1, such as TTBR0_EL1. However, on some processors an earlier mis-prediction can cause the MRS instruction to transiently read the value in an EL1 register. In this example, a conditional branch (line 2) can be mis-predicted as \"not taken\" while waiting for a slow load (line 1). This allows MRS (line 3) to transiently read the value in the TTBR0_EL1 register. The subsequent memory access (line 6) can allow the restricted register's value to become observable, for example, over a cache covert channel.\n\n\nCode snippet is from [REF-1410]. See also [REF-1411]."},{"Nature":"Bad","Language":"x86 Assembly","ExampleCode":"1 LDR X1, [X2] ; arranged to miss in the cache\n 2 CBZ X1, over ; This will be taken \n 3 MRS X3, TTBR0_EL1; \n 4 LSL X3, X3, #imm \n 5 AND X3, X3, #0xFC0\n 6 LDR X5, [X6,X3] ; X6 is an EL0 base address\n 7 over"}]}],"ObservedExamples":[{"Reference":"CVE-2017-5715","Description":"A fault may allow transient user-mode operations to access kernel data cached in the L1D, potentially exposing the data over a covert channel.","Link":"https://www.cve.org/CVERecord?id=CVE-2017-5715"},{"Reference":"CVE-2018-3615","Description":"A fault may allow transient non-enclave operations to access SGX enclave data cached in the L1D, potentially exposing the data over a covert channel.","Link":"https://www.cve.org/CVERecord?id=CVE-2018-3615"},{"Reference":"CVE-2019-1135","Description":"A TSX Asynchronous Abort may allow transient operations to access architecturally restricted data, potentially exposing the data over a covert channel.","Link":"https://www.cve.org/CVERecord?id=CVE-2019-1135"}],"References":[{"ExternalReferenceID":"REF-1404","Authors":["The kernel development community"],"Title":"Page Table Isolation (PTI)","PublicationYear":"2023","PublicationMonth":"01","PublicationDay":"30","URL":"https://kernel.org/doc/html/next/x86/pti.html","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1405","Authors":["Stephan van Schaik","Alyssa Milburn","Sebastian Österlund","Pietro Frigo","Giorgi Maisuradze","Kaveh Razavi","Herbert Bos","Cristiano Giuffrida"],"Title":"RIDL: Rogue In-Flight Data Load","PublicationYear":"2019","PublicationMonth":"05","PublicationDay":"19","URL":"https://mdsattacks.com/files/ridl.pdf","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1406","Authors":["Daniel Moghimi"],"Title":"Downfall: Exploiting Speculative Data Gathering","PublicationYear":"2023","PublicationMonth":"08","PublicationDay":"09","URL":"https://www.usenix.org/system/files/usenixsecurity23-moghimi.pdf","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1401","Authors":["Neta Bar Kama","Roope Kaivola"],"Title":"Hardware Security Leak Detection by Symbolic Simulation","PublicationYear":"2021","PublicationMonth":"11","URL":"https://ieeexplore.ieee.org/document/9617727","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1408","Authors":["Moritz Lipp","Michael Schwarz","Daniel Gruss","Thomas Prescher","Werner Haas","Stefan Mangard","Paul Kocher","Daniel Genkin","Yuval Yarom","Mike Hamburg"],"Title":"Meltdown: Reading Kernel Memory from User Space","PublicationYear":"2020","PublicationMonth":"05","PublicationDay":"21","URL":"https://meltdownattack.com/meltdown.pdf","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1409","Authors":["Intel Corporation"],"Title":"Microarchitectural Data Sampling","PublicationYear":"2021","PublicationMonth":"03","PublicationDay":"11","URL":"https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/technical-documentation/intel-analysis-microarchitectural-data-sampling.html","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1410","Authors":["ARM"],"Title":"Cache Speculation Side-channels","PublicationYear":"2018","PublicationMonth":"01","URL":"https://armkeil.blob.core.windows.net/developer/Files/pdf/Cache_Speculation_Side-channels.pdf","URLDate":"2024-02-22"},{"ExternalReferenceID":"REF-1411","Authors":["Intel Corporation"],"Title":"Rogue System Register Read/CVE-2018-3640/INTEL-SA-00115","PublicationYear":"2018","PublicationMonth":"05","PublicationDay":"01","URL":"https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/rogue-system-register-read.html","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1400","Authors":["Intel Corporation"],"Title":"Refined Speculative Execution Terminology","PublicationYear":"2022","PublicationMonth":"03","PublicationDay":"11","URL":"https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/refined-speculative-execution-terminology.html","URLDate":"2024-02-13"},{"ExternalReferenceID":"REF-1389","Authors":["Alyssa Milburn","Ke Sun","Henrique Kawakami"],"Title":"You Cannot Always Win the Race: Analyzing the LFENCE/JMP Mitigation for Branch Target Injection","PublicationYear":"2022","PublicationMonth":"03","PublicationDay":"08","URL":"https://arxiv.org/abs/2203.04277","URLDate":"2024-02-22"},{"ExternalReferenceID":"REF-1430","Authors":["Daniel Moghimi","Moritz Lipp","Berk Sunar","Michael Schwarz"],"Title":"Medusa: Microarchitectural: Data Leakage via Automated Attack Synthesis","PublicationYear":"2020","PublicationMonth":"08","URL":"https://www.usenix.org/conference/usenixsecurity20/presentation/moghimi-medusa","URLDate":"2024-02-27"},{"ExternalReferenceID":"REF-1417","Authors":["Mengjia Yan","Jiho Choi","Dimitrios Skarlatos","Adam Morrison","Christopher W. Fletcher","Josep Torrella"],"Title":"InvisiSpec: making speculative execution invisible in the cache hierarchy.","PublicationYear":"2019","PublicationMonth":"05","URL":"https://iacoma.cs.uiuc.edu/iacoma-papers/micro18.pdf","URLDate":"2025-08-04"},{"ExternalReferenceID":"REF-1418","Authors":["Alejandro Cabrera Aldaya","Billy Bob Brumley","Sohaib ul Hassan","Cesar Pereida García","Nicola Tuveri"],"Title":"Port Contention for Fun and Profit","PublicationYear":"2019","PublicationMonth":"05","URL":"https://eprint.iacr.org/2018/1060.pdf","URLDate":"2024-02-14"},{"ExternalReferenceID":"REF-1419","Authors":["Mohammad Behnia","Prateek Sahu","Riccardo Paccagnella","Jiyong Yu","Zirui Zhao","Xiang Zou","Thomas Unterluggauer","Josep Torrellas","Carlos Rozas","Adam Morrison","Frank Mckeen","Fangfei Liu","Ron Gabor","Christopher W. Fletcher","Abhishek Basak","Alaa Alameldeen"],"Title":"Speculative Interference Attacks: Breaking Invisible Speculation Schemes","PublicationYear":"2021","PublicationMonth":"04","URL":"https://arxiv.org/abs/2007.11818","URLDate":"2024-02-14"},{"ExternalReferenceID":"REF-1420","Authors":["Ross Mcilroy","Jaroslav Sevcik","Tobias Tebbi","Ben L. Titzer","Toon Verwaest"],"Title":"Spectre is here to stay: An analysis of side-channels and speculative execution","PublicationYear":"2019","PublicationMonth":"02","PublicationDay":"14","URL":"https://arxiv.org/pdf/1902.05178","URLDate":"2025-08-04"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities","Comments":"If a weakness can potentially be exploited to infer data that is accessible inside or outside the current processor context, then the weakness could map to CWE-1421 and to another CWE such as CWE-1420.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Scott D. Constable","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2023-09-19","SubmissionVersion":"4.14","SubmissionReleaseDate":"2024-02-29"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-09-09","ModificationComment":"updated References, Relationships","ModificationVersion":"4.18","ModificationReleaseDate":"2025-09-09"},{"Type":"Contribution","ContributionName":"David Kaplan","ContributionOrganization":"AMD","ContributionDate":"2024-01-22","ContributionComment":"Member of Microarchitectural Weaknesses Working Group","ContributionType":"Content","ContributionVersion":"4.14","ContributionReleaseDate":"2024-02-29"},{"Type":"Contribution","ContributionName":"Rafael Dossantos, Abraham Fernandez Rubio, Alric Althoff, Lyndon Fawcett","ContributionOrganization":"Arm","ContributionDate":"2024-01-22","ContributionComment":"Members of Microarchitectural Weaknesses Working Group","ContributionType":"Content","ContributionVersion":"4.14","ContributionReleaseDate":"2024-02-29"},{"Type":"Contribution","ContributionName":"Jason Oberg","ContributionOrganization":"Cycuity","ContributionDate":"2024-01-22","ContributionComment":"Member of Microarchitectural Weaknesses Working Group","ContributionType":"Content","ContributionVersion":"4.14","ContributionReleaseDate":"2024-02-29"},{"Type":"Contribution","ContributionName":"Priya B. Iyer","ContributionOrganization":"Intel Corporation","ContributionDate":"2024-01-22","ContributionComment":"Member of Microarchitectural Weaknesses Working Group","ContributionType":"Content","ContributionVersion":"4.14","ContributionReleaseDate":"2024-02-29"},{"Type":"Contribution","ContributionName":"Nicole Fern","ContributionOrganization":"Riscure","ContributionDate":"2024-01-22","ContributionComment":"Member of Microarchitectural Weaknesses Working Group","ContributionType":"Content","ContributionVersion":"4.14","ContributionReleaseDate":"2024-02-29"}]}