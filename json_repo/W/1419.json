{"ID":"1419","Name":"Incorrect Initialization of Resource","Abstraction":"Class","Structure":"Simple","Status":"Incomplete","Description":"The product attempts to initialize a resource but does not correctly do so, which might leave the resource in an unexpected, incorrect, or insecure state when it is accessed.","ExtendedDescription":"\n\nThis can have security implications when the associated resource is expected to have certain properties or values. Examples include a variable that determines whether a user has been authenticated or not, or a register or fuse value that determines the security state of the product.\n\n\nFor software, this weakness can frequently occur when implicit initialization is used, meaning the resource is not explicitly set to a specific value. For example, in C, memory is not necessarily cleared when it is allocated on the stack, and many scripting languages use a default empty, null value, or zero value when a variable is not explicitly initialized.\n\n\nFor hardware, this weakness frequently appears with reset values and fuses. After a product reset, hardware may initialize registers incorrectly. During different phases of a product lifecycle, fuses may be set to incorrect values. Even if fuses are set to correct values, the lines to the fuse could be broken or there might be hardware on the fuse line that alters the fuse value to be incorrect.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"665","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"},{"Phase":"Manufacturing"},{"Phase":"Installation"},{"Phase":"System Configuration"},{"Phase":"Operation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory","Read Application Data","Unexpected State"],"Likelihood":["Unknown"]},{"Scope":["Authorization","Integrity"],"Impact":["Gain Privileges or Assume Identity"]},{"Scope":["Other"],"Impact":["Varies by Context"],"Note":"The technical impact can vary widely based on how the resource is used in the product, and whether its contents affect security decisions."}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Choose the safest-possible initialization for security-related resources."},{"Phase":["Implementation"],"Description":"Ensure that each resource (whether variable, memory buffer, register, etc.) is fully initialized."},{"Phase":["Implementation"],"Description":"Pay close attention to complex conditionals or reset sources that affect initialization, since some paths might not perform the initialization."},{"Phase":["Architecture and Design"],"Description":"Ensure that the design and architecture clearly identify what the initialization should be, and that the initialization does not have security implications."}],"DemonstrativeExamples":[{"ID":"DX-162","Entries":[{"IntroText":"Consider example design module system verilog code shown below. The register_example module is an example parameterized module that defines two parameters, REGISTER_WIDTH and REGISTER_DEFAULT. Register_example module defines a Secure_mode setting, which when set makes the register content read-only and not modifiable by software writes. register_top module instantiates two registers, Insecure_Device_ID_1 and Insecure_Device_ID_2. Generally, registers containing device identifier values are required to be read only to prevent any possibility of software modifying these values."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"// Parameterized Register module example \n // Secure_mode : REGISTER_DEFAULT[0] : When set to 1 register is read only and not writable// \n module register_example \n #( \n parameter REGISTER_WIDTH = 8, // Parameter defines width of register, default 8 bits \n parameter [REGISTER_WIDTH-1:0] REGISTER_DEFAULT = 2**REGISTER_WIDTH -2 // Default value of register computed from Width. Sets all bits to 1s except bit 0 (Secure _mode) \n ) \n ( \n input [REGISTER_WIDTH-1:0] Data_in, \n input Clk, \n input resetn, \n input write, \n output reg [REGISTER_WIDTH-1:0] Data_out \n ); \n\n reg Secure_mode; \n\n always @(posedge Clk or negedge resetn) \n\n```\n\t if (~resetn) \n\t begin \n\t\t Data_out \u003c= REGISTER_DEFAULT; // Register content set to Default at reset \n\t\t Secure_mode \u003c= REGISTER_DEFAULT[0]; // Register Secure_mode set at reset \n\t end \n\t else if (write \u0026 ~Secure_mode) \n\t begin \n\t\t Data_out \u003c= Data_in; \n\t end \n endmodule \n module register_top \n ( \n input Clk, \n input resetn, \n input write, \n input [31:0] Data_in, \n output reg [31:0] Secure_reg, \n output reg [31:0] Insecure_reg \n ); \n register_example #( \n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1224) // Incorrect Default value used bit 0 is 0. \n ) Insecure_Device_ID_1 ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n register_example #(\n\t .REGISTER_WIDTH (32) // Default not defined 2^32-2 value will be used as default. \n ) Insecure_Device_ID_2 ( \n\t .Data_in (Data_in), \n\t .Data_out (Insecure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n endmodule \n```"},{"BodyText":"These example instantiations show how, in a hardware design, it would be possible to instantiate the register module with insecure defaults and parameters."},{"BodyText":"In the example design, both registers will be software writable since Secure_mode is defined as zero."},{"Nature":"Good","Language":"Verilog","ExampleCode":"register_example #( \n\n```\n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1225) // Correct default value set, to enable Secure_mode \n ) Secure_Device_ID_example ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n );\n```"}]},{"ID":"DX-163","Entries":[{"IntroText":"This code attempts to login a user using credentials from a POST request:"},{"Nature":"Bad","Language":"PHP","ExampleCode":"```\n```\n// $user and $pass automatically set from POST request* \n\tif (login_user($user,$pass)) {\n\t```\n\t\t$authorized = true;\n\t}\n```\n...* \n\t\n\tif ($authorized) {\n\t```\n\t\tgeneratePage();\n\t}\n```"},{"BodyText":"Because the $authorized variable is never initialized, PHP will automatically set $authorized to any value included in the POST request if register_globals is enabled. An attacker can send a POST request with an unexpected third value 'authorized' set to 'true' and gain authorized status without supplying valid credentials."},{"BodyText":"Here is a fixed version:"},{"Nature":"Good","Language":"PHP","ExampleCode":"```\n\t$user = $_POST['user'];\n\t$pass = $_POST['pass'];\n\t$authorized = false;\n\tif (login_user($user,$pass)) {\n\t\t$authorized = true;\n\t}\n```\n...*"},{"BodyText":"This code avoids the issue by initializing the $authorized variable to false and explicitly retrieving the login credentials from the $_POST variable. Regardless, register_globals should never be enabled and is disabled by default in current versions of PHP."}]},{"ID":"DX-222","Entries":[{"IntroText":"The following example code is excerpted from the Access Control module, acct_wrapper, in the Hack@DAC'21 buggy OpenPiton System-on-Chip (SoC). Within this module, a set of memory-mapped I/O registers, referred to as acct_mem, each 32-bit wide, is utilized to store access control permissions for peripherals [REF-1437]. Access control registers are typically used to define and enforce permissions and access rights for various system resources."},{"BodyText":"However, in the buggy SoC, these registers are all enabled at reset, i.e., essentially granting unrestricted access to all system resources [REF-1438]. This will introduce security vulnerabilities and risks to the system, such as privilege escalation or exposing sensitive information to unauthorized users or processes."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module acct_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~rst_6))\n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j \u003c AcCt_MEM_SIZE; j=j+1)\n\t\t\t\t\t\t begin\n```\nacct_mem[j] \u003c= 32'hffffffff;** \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\t\t ..."},{"BodyText":"To fix this issue, the access control registers must be properly initialized during the reset phase of the SoC. Correct initialization values should be established to maintain the system's integrity, security, predictable behavior, and allow proper control of peripherals. The specifics of what values should be set depend on the SoC's design and the requirements of the system. To address the problem depicted in the bad code example [REF-1438], the default value for \"acct_mem\" should be set to 32'h00000000 (see good code example [REF-1439]). This ensures that during startup or after any reset, access to protected data is restricted until the system setup is complete and security procedures properly configure the access control settings."},{"Nature":"Good","Language":"Verilog","ExampleCode":"module acct_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~rst_6)) \n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j \u003c AcCt_MEM_SIZE; j=j+1)\n\t\t\t\t\t\t begin\n```\nacct_mem[j] \u003c= 32'h00000000;** \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t end\n\t\t\t\t ..."}]}],"ObservedExamples":[{"Reference":"CVE-2020-27211","Description":"Chain: microcontroller system-on-chip uses a register value stored in flash to set product protection state on the memory bus and does not contain protection against fault injection (CWE-1319) which leads to an incorrect initialization of the memory bus (CWE-1419) causing the product to be in an unprotected state.","Link":"https://www.cve.org/CVERecord?id=CVE-2020-27211"},{"Reference":"CVE-2023-25815","Description":"chain: a change in an underlying package causes the gettext function to use implicit initialization with a hard-coded path (CWE-1419) under the user-writable C:\\ drive, introducing an untrusted search path element (CWE-427) that enables spoofing of messages.","Link":"https://www.cve.org/CVERecord?id=CVE-2023-25815"},{"Reference":"CVE-2022-43468","Description":"WordPress module sets internal variables based on external inputs, allowing false reporting of the number of views","Link":"https://www.cve.org/CVERecord?id=CVE-2022-43468"},{"Reference":"CVE-2022-36349","Description":"insecure default variable initialization in BIOS firmware for a hardware board allows DoS","Link":"https://www.cve.org/CVERecord?id=CVE-2022-36349"},{"Reference":"CVE-2015-7763","Description":"distributed filesystem only initializes part of the variable-length padding for a packet, allowing attackers to read sensitive information from previously-sent packets in the same memory location","Link":"https://www.cve.org/CVERecord?id=CVE-2015-7763"}],"References":[{"ExternalReferenceID":"REF-1437","Title":"acct_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/65d0ffdab7426da4509c98d62e163bcce642f651/piton/design/chip/tile/ariane/src/acct/acct_wrapper.sv#L39"},{"ExternalReferenceID":"REF-1438","Title":"Bad Code acct_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/65d0ffdab7426da4509c98d62e163bcce642f651/piton/design/chip/tile/ariane/src/acct/acct_wrapper.sv#L79C1-L86C16"},{"ExternalReferenceID":"REF-1439","Title":"Good Code acct_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/062de4f25002d2dcbdb0a82af36b80a517592612/piton/design/chip/tile/ariane/src/acct/acct_wrapper.sv#L84"}],"MappingNotes":{"Usage":"Allowed-with-Review","Rationale":"This CWE entry is a Class and might have Base-level children that would be more appropriate","Comments":"Examine children of this entry to see if there is a better fit","Reasons":["Abstraction"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2023-10-11","SubmissionVersion":"4.13","SubmissionReleaseDate":"2023-10-26"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-07-16","ModificationComment":"updated Demonstrative_Examples, References","ModificationVersion":"4.15","ModificationReleaseDate":"2024-07-16"},{"Type":"Contribution","ContributionName":"Anonymous External Contributor","ContributionDate":"2023-10-13","ContributionComment":"Provided HW specific comments for Extended Description","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Mohan Lal","ContributionOrganization":"NVIDIA","ContributionDate":"2023-10-13","ContributionComment":"Provided HW specific comments for Extended Description","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Chen Chen, Rahul Kande, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"}]}