{"ID":"1234","Name":"Hardware Internal or Debug Modes Allow Override of Locks","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"System configuration protection may be bypassed during debug mode.","ExtendedDescription":"\n\nDevice configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set, disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, modification of the lock protection may be allowed allowing access and modification of configuration information.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"667","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Access Control"],"Impact":["Bypass Protection Mechanism"],"Likelihood":["High"],"Note":"Bypass of lock bit allows access and modification of system configuration even when the lock bit is set."}],"PotentialMitigations":[{"Phase":["Architecture and Design","Implementation","Testing"],"Description":"\n\n  - Security Lock bit protections should be reviewed for any bypass/override modes supported.\n\n  - Any supported override modes either should be removed or protected using authenticated debug modes.\n\n  - Security lock programming flow and lock properties should be tested in pre-silicon and post-silicon testing.\n\n","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"For example, consider the example Locked_override_register example. This register module supports a lock mode that blocks any writes after lock is set to 1. \n However, it also allows override of the lock protection when scan_mode or debug_unlocked modes are active."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module Locked_register_example\n (\n input [15:0] Data_in,\n input Clk,\n input resetn,\n input write,\n input Lock,\n input scan_mode,\n input debug_unlocked,\n output reg [15:0] Data_out\n );\n\n reg lock_status;\n\n always @(posedge Clk or negedge resetn)\n\n```\n\t if (~resetn) // Register is reset resetn\n\t begin\n\t\t lock_status \u003c= 1'b0;\n\t end\n\t else if (Lock)\n\t begin\n\t\t lock_status \u003c= 1'b1;\n\t end\n\t else if (~Lock)\n\t begin\n\t\t lock_status \u003c= lock_status\n\t end\n always @(posedge Clk or negedge resetn)\n\t if (~resetn) // Register is reset resetn\n\t begin\n\t\t Data_out \u003c= 16'h0000;\n\t end\n\t else if (write \u0026 (~lock_status | scan_mode | debug_unlocked) ) // Register protected by Lock bit input, overrides supported for scan_mode \u0026 debug_unlocked\n\t begin\n\t\t Data_out \u003c= Data_in;\n\t end\n\t else if (~write)\n\t begin\n\t\t Data_out \u003c= Data_out;\n\t end\n endmodule\n```"},{"BodyText":"If either the scan_mode or the debug_unlocked modes can be triggered by software, then the lock protection may be bypassed."},{"Nature":"Good","Language":"Other","ExampleCode":"Either remove the debug and scan mode overrides or protect enabling of these modes so that only trusted and authorized users may enable these modes."}]},{"Entries":[{"IntroText":"The following example code [REF-1375] is taken from the register lock security peripheral of the HACK@DAC'21 buggy OpenPiton SoC. It demonstrates how to lock read or write access to security-critical hardware registers (e.g., crypto keys, system integrity code, etc.). The configuration to lock all the sensitive registers in the SoC is managed through the reglk_mem registers. These reglk_mem registers are reset when the hardware powers up and configured during boot up. Malicious users, even with kernel-level software privilege, do not get access to the sensitive contents that are locked down. Hence, the security of the entire system can potentially be compromised if the register lock configurations are corrupted or if the register locks are disabled."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"...\n always @(posedge clk_i)\n\n```\n\t begin\n```\nif(~(rst_ni \u0026\u0026 ~jtag_unlock \u0026\u0026 ~rst_9))** \n\t\t\n\t\t```\n\t\t\t begin\n\t\t\t\t for (j=0; j \u003c 6; j=j+1) begin\n\t\t\t\t\t reglk_mem[j] \u003c= 'h0;\n\t\t\t\t end\n\t\t\t end\n ...\n```"},{"BodyText":"The example code [REF-1375] illustrates an instance of a vulnerable implementation of register locks in the SoC. In this flawed implementation [REF-1375], the reglk_mem registers are also being reset when the system enters debug mode (indicated by the jtag_unlock signal). Consequently, users can simply put the processor in debug mode to access sensitive contents that are supposed to be protected by the register lock feature."},{"BodyText":"This can be mitigated by excluding debug mode signals from the reset logic of security-critical register locks as demonstrated in the following code snippet [REF-1376]."},{"Nature":"Good","Language":"Verilog","ExampleCode":"...\n always @(posedge clk_i)\n\n```\n\t begin\n```\nif(~(rst_ni \u0026\u0026 ~rst_9))** \n\t\t\n\t\t```\n\t\t\t begin\n\t\t\t\t for (j=0; j \u003c 6; j=j+1) begin\n\t\t\t\t\t reglk_mem[j] \u003c= 'h0;\n\t\t\t\t end\n\t\t\t end\n ...\n```"}]}],"RelatedAttackPatterns":["176"],"References":[{"ExternalReferenceID":"REF-1375","Title":"reglk_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/cde1d9d6888bffab21d4b405ccef61b19c58dd3c/piton/design/chip/tile/ariane/src/reglk/reglk_wrapper.sv#L80C1-L80C48","URLDate":"2023-12-13"},{"ExternalReferenceID":"REF-1376","Title":"Fix for reglk_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/20238068b385d7ab704cabfb95ff95dd6e56e1c2/piton/design/chip/tile/ariane/src/reglk/reglk_wrapper.sv#L80","URLDate":"2023-12-13"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-01-15","SubmissionVersion":"4.0","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Description, Modes_of_Introduction, Potential_Mitigations, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-02-29","ModificationComment":"updated Demonstrative_Examples, References","ModificationVersion":"4.14","ModificationReleaseDate":"2024-02-29"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-09-09","ModificationComment":"updated Relationships","ModificationVersion":"4.18","ModificationReleaseDate":"2025-09-09"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-12-11","ModificationComment":"updated Demonstrative_Examples, Weakness_Ordinalities","ModificationVersion":"4.19","ModificationReleaseDate":"2025-12-11"},{"Type":"Contribution","ContributionName":"Chen Chen, Rahul Kande, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"}]}