{"ID":"667","Name":"Improper Locking","Abstraction":"Class","Structure":"Simple","Status":"Draft","Description":"The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.","ExtendedDescription":"\n\nLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"662","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"662","ViewID":"1003","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"662","ViewID":"1305","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"662","ViewID":"1340","Ordinal":"Primary"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (CPU)"],"Note":"Inconsistent locking discipline can lead to deadlock."}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Implementation"],"Strategy":"Libraries or Frameworks","Description":"Use industry standard APIs to implement locking mechanism."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"In the following Java snippet, methods are defined to get and set a long field in an instance of a class that is shared across multiple threads. Because operations on double and long are nonatomic in Java, concurrent access may cause unexpected behavior. Thus, all operations on long and double fields should be synchronized."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tprivate long someLongValue;\n\tpublic long getLongValue() {\n\t\treturn someLongValue;\n\t}\n\tpublic void setLongValue(long l) {\n\t\tsomeLongValue = l;\n\t}\n```"}]},{"ID":"DX-69","Entries":[{"IntroText":"This code tries to obtain a lock for a file, then writes to it."},{"Nature":"Bad","Language":"PHP","ExampleCode":"```\n\tfunction writeToLog($message){\n\t\t$logfile = fopen(\"logFile.log\", \"a\");\n```\n//attempt to get logfile lock* \n\t\tif (flock($logfile, LOCK_EX)) {\n\t\t```\n\t\t\tfwrite($logfile,$message);\n```\n// unlock logfile* \n\t\t\tflock($logfile, LOCK_UN);}\n\t\telse {\n\t\t```\n\t\t\tprint \"Could not obtain lock on logFile.log, message not recorded\\n\";\n\t\t}\n\t}\n\tfclose($logFile);\n```"},{"BodyText":"PHP by default will wait indefinitely until a file lock is released. If an attacker is able to obtain the file lock, this code will pause execution, possibly leading to denial of service for other users. Note that in this case, if an attacker can perform an flock() on the file, they may already have privileges to destroy the log file. However, this still impacts the execution of other programs that depend on flock()."}]},{"ID":"DX-24","Entries":[{"IntroText":"The following function attempts to acquire a lock in order to perform operations on a shared resource."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tvoid f(pthread_mutex_t *mutex) {\n\t\t\tpthread_mutex_lock(mutex);\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\tpthread_mutex_unlock(mutex);}"},{"BodyText":"However, the code does not check the value returned by pthread_mutex_lock() for errors. If pthread_mutex_lock() cannot acquire the mutex for any reason, the function may introduce a race condition into the program and result in undefined behavior."},{"BodyText":"In order to avoid data races, correctly written programs must check the result of thread synchronization functions and appropriately handle all errors, either by attempting to recover from them or reporting them to higher levels."},{"Nature":"Good","Language":"C","ExampleCode":"```\n\tint f(pthread_mutex_t *mutex) {\n\t\t\tint result;\n\t\t\tresult = pthread_mutex_lock(mutex);\n\t\t\tif (0 != result)\n\t\t\t\treturn result;\n```\n/* access shared resource */* \n\t\t\t\n\t\t\t\n\t\t\treturn pthread_mutex_unlock(mutex);}"}]},{"ID":"DX-70","Entries":[{"IntroText":"It may seem that the following bit of code achieves thread safety while avoiding unnecessary synchronization..."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tif (helper == null) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (helper == null) {\n\t\t\t\t\thelper = new Helper();\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn helper;\n```"},{"BodyText":"The programmer wants to guarantee that only one Helper() object is ever allocated, but does not want to pay the cost of synchronization every time this code is called."},{"BodyText":"Suppose that helper is not initialized. Then, thread A sees that helper==null and enters the synchronized block and begins to execute:"},{"Nature":"Bad","ExampleCode":"```\n\thelper = new Helper();\n```"},{"BodyText":"If a second thread, thread B, takes over in the middle of this call and helper has not finished running the constructor, then thread B may make calls on helper while its fields hold incorrect values."}]}],"ObservedExamples":[{"Reference":"CVE-2021-1782","Description":"Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.","Link":"https://www.cve.org/CVERecord?id=CVE-2021-1782"},{"Reference":"CVE-2009-0935","Description":"Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice","Link":"https://www.cve.org/CVERecord?id=CVE-2009-0935"},{"Reference":"CVE-2010-4210","Description":"function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.","Link":"https://www.cve.org/CVERecord?id=CVE-2010-4210"},{"Reference":"CVE-2008-4302","Description":"Chain: OS kernel does not properly handle a failure of a function call (CWE-755), leading to an unlock of a resource that was not locked (CWE-832), with resultant crash.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-4302"},{"Reference":"CVE-2009-1243","Description":"OS kernel performs an unlock in some incorrect circumstances, leading to panic.","Link":"https://www.cve.org/CVERecord?id=CVE-2009-1243"},{"Reference":"CVE-2009-2857","Description":"OS deadlock","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2857"},{"Reference":"CVE-2009-1961","Description":"OS deadlock involving 3 separate functions","Link":"https://www.cve.org/CVERecord?id=CVE-2009-1961"},{"Reference":"CVE-2009-2699","Description":"deadlock in library","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2699"},{"Reference":"CVE-2009-4272","Description":"deadlock triggered by packets that force collisions in a routing table","Link":"https://www.cve.org/CVERecord?id=CVE-2009-4272"},{"Reference":"CVE-2002-1850","Description":"read/write deadlock between web server and script","Link":"https://www.cve.org/CVERecord?id=CVE-2002-1850"},{"Reference":"CVE-2004-0174","Description":"web server deadlock involving multiple listening connections","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0174"},{"Reference":"CVE-2009-1388","Description":"multiple simultaneous calls to the same function trigger deadlock.","Link":"https://www.cve.org/CVERecord?id=CVE-2009-1388"},{"Reference":"CVE-2006-5158","Description":"chain: other weakness leads to NULL pointer dereference (CWE-476) or deadlock (CWE-833).","Link":"https://www.cve.org/CVERecord?id=CVE-2006-5158"},{"Reference":"CVE-2006-4342","Description":"deadlock when an operation is performed on a resource while it is being removed.","Link":"https://www.cve.org/CVERecord?id=CVE-2006-4342"},{"Reference":"CVE-2006-2374","Description":"Deadlock in device driver triggered by using file handle of a related device.","Link":"https://www.cve.org/CVERecord?id=CVE-2006-2374"},{"Reference":"CVE-2006-2275","Description":"Deadlock when large number of small messages cannot be processed quickly enough.","Link":"https://www.cve.org/CVERecord?id=CVE-2006-2275"},{"Reference":"CVE-2005-3847","Description":"OS kernel has deadlock triggered by a signal during a core dump.","Link":"https://www.cve.org/CVERecord?id=CVE-2005-3847"},{"Reference":"CVE-2005-3106","Description":"Race condition leads to deadlock.","Link":"https://www.cve.org/CVERecord?id=CVE-2005-3106"},{"Reference":"CVE-2005-2456","Description":"Chain: array index error (CWE-129) leads to deadlock (CWE-833)","Link":"https://www.cve.org/CVERecord?id=CVE-2005-2456"},{"Reference":"CVE-2001-0682","Description":"Program can not execute when attacker obtains a mutex.","Link":"https://www.cve.org/CVERecord?id=CVE-2001-0682"},{"Reference":"CVE-2002-1914","Description":"Program can not execute when attacker obtains a lock on a critical output file.","Link":"https://www.cve.org/CVERecord?id=CVE-2002-1914"},{"Reference":"CVE-2002-1915","Description":"Program can not execute when attacker obtains a lock on a critical output file.","Link":"https://www.cve.org/CVERecord?id=CVE-2002-1915"},{"Reference":"CVE-2002-0051","Description":"Critical file can be opened with exclusive read access by user, preventing application of security policy. Possibly related to improper permissions, large-window race condition.","Link":"https://www.cve.org/CVERecord?id=CVE-2002-0051"},{"Reference":"CVE-2000-0338","Description":"Chain: predictable file names used for locking, allowing attacker to create the lock beforehand. Resultant from permissions and randomness.","Link":"https://www.cve.org/CVERecord?id=CVE-2000-0338"},{"Reference":"CVE-2000-1198","Description":"Chain: Lock files with predictable names. Resultant from randomness.","Link":"https://www.cve.org/CVERecord?id=CVE-2000-1198"},{"Reference":"CVE-2002-1869","Description":"Product does not check if it can write to a log file, allowing attackers to avoid logging by accessing the file using an exclusive lock. Overlaps unchecked error condition. This is not quite CWE-412, but close.","Link":"https://www.cve.org/CVERecord?id=CVE-2002-1869"}],"TaxonomyMappings":[{"TaxonomyName":"CERT C Secure Coding","EntryID":"CON31-C","EntryName":"Do not destroy a mutex while it is locked","MappingFit":"CWE More Abstract"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"POS48-C","EntryName":"Do not unlock or destroy another POSIX thread's mutex","MappingFit":"CWE More Abstract"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"VNA00-J","EntryName":"Ensure visibility when accessing shared primitive variables"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"VNA02-J","EntryName":"Ensure that compound operations on shared variables are atomic"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"VNA05-J","EntryName":"Ensure atomicity when reading and writing 64-bit values"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"LCK06-J","EntryName":"Do not use an instance lock to protect shared static data"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP19","EntryName":"Missing Lock"},{"TaxonomyName":"OMG ASCSM","EntryID":"ASCSM-CWE-667"}],"RelatedAttackPatterns":["25","26","27"],"References":[{"ExternalReferenceID":"REF-962","Section":"ASCSM-CWE-667","Authors":["Object Management Group (OMG)"],"Title":"Automated Source Code Security Measure (ASCSM)","PublicationYear":"2016","PublicationMonth":"01","URL":"http://www.omg.org/spec/ASCSM/1.0/"}],"MappingNotes":{"Usage":"Allowed-with-Review","Rationale":"This CWE entry is a Class and might have Base-level children that would be more appropriate","Comments":"Examine children of this entry to see if there is a better fit","Reasons":["Abstraction"]},"Notes":[{"Type":"Maintenance","Note":"Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2008-04-11","SubmissionVersion":"Draft 9","SubmissionReleaseDate":"2008-04-11"},{"Type":"Modification","ModificationName":"Sean Eidemiller","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"added/updated demonstrative examples"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Potential_Mitigations, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-03-10","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-05-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-07-27","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-09-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-12-13","ModificationComment":"updated Description, Name, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, Observed_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-10-30","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-05-03","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-09-19","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-09-23","ModificationComment":"updated Description, Maintenance_Notes, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-06-28","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Rename","PreviousEntryName":"Insufficient Locking","Date":"2010-12-13"}]}