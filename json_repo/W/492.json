{"ID":"492","Name":"Use of Inner Class Containing Sensitive Data","Abstraction":"Variant","Structure":"Simple","Status":"Draft","Description":"Inner classes are translated into classes that are accessible at package scope and may expose code that the programmer intended to keep private to attackers.","ExtendedDescription":"Inner classes quietly introduce several security concerns because of the way they are translated into Java bytecode. In Java source code, it appears that an inner class can be declared to be accessible only by the enclosing class, but Java bytecode has no concept of an inner class, so the compiler must transform an inner class declaration into a peer class with package level access to the original outer class. More insidiously, since an inner class can access private fields in its enclosing class, once an inner class becomes a peer class in bytecode, the compiler converts private fields accessed by the inner class into protected fields.","LikelihoodOfExploit":"Medium","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"668","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"Java","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Application Data"],"Note":"\"Inner Classes\" data confidentiality aspects can often be overcome."}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Using sealed classes protects object-oriented encapsulation paradigms and therefore protects code from being extended in unforeseen ways."},{"Phase":["Implementation"],"Description":"Inner Classes do not provide security. Warning: Never reduce the security of the object from an outer class, going to an inner class. If an outer class is final or private, ensure that its inner class is private as well."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The following Java Applet code mistakenly makes use of an inner class."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tpublic final class urlTool extends Applet {\n\t\tprivate final class urlHelper {\n\t\t\t...\n\t\t}\n\t\t...\n\t}\n```"}]},{"Entries":[{"IntroText":"The following example shows a basic use of inner classes. The class OuterClass contains the private member inner class InnerClass. The private inner class InnerClass includes the method concat that accesses the private member variables of the class OuterClass to output the value of one of the private member variables of the class OuterClass and returns a string that is a concatenation of one of the private member variables of the class OuterClass, the separator input parameter of the method and the private member variable of the class InnerClass."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tpublic class OuterClass {\n```\n// private member variables of OuterClass* \n\t\tprivate String memberOne;\n\t\tprivate String memberTwo;\n\t\t\n\t\t\n\t\t *// constructor of OuterClass* \n\t\tpublic OuterClass(String varOne, String varTwo) {\n\t\t```\n\t\t\tthis.memberOne = varOne;\n\t\t\tthis.memberTwo = varTwo;\n\t\t}\n```\n// InnerClass is a member inner class of OuterClass* \n\t\tprivate class InnerClass {\n\t\t```\n\t\t\tprivate String innerMemberOne;\n\t\t\tpublic InnerClass(String innerVarOne) {\n\t\t\t\tthis.innerMemberOne = innerVarOne;\n\t\t\t}\n\t\t\tpublic String concat(String separator) {\n```\n// InnerClass has access to private member variables of OuterClass* \n\t\t\t\tSystem.out.println(\"Value of memberOne is: \" + memberOne);\n\t\t\t\treturn OuterClass.this.memberTwo + separator + this.innerMemberOne;}}}"},{"BodyText":"Although this is an acceptable use of inner classes it demonstrates one of the weaknesses of inner classes that inner classes have complete access to all member variables and methods of the enclosing class even those that are declared private and protected. When inner classes are compiled and translated into Java bytecode the JVM treats the inner class as a peer class with package level access to the enclosing class."},{"BodyText":"To avoid this weakness of inner classes, consider using either static inner classes, local inner classes, or anonymous inner classes."},{"BodyText":"The following Java example demonstrates the use of static inner classes using the previous example. The inner class InnerClass is declared using the static modifier that signifies that InnerClass is a static member of the enclosing class OuterClass. By declaring an inner class as a static member of the enclosing class, the inner class can only access other static members and methods of the enclosing class and prevents the inner class from accessing nonstatic member variables and methods of the enclosing class. In this case the inner class InnerClass can only access the static member variable memberTwo of the enclosing class OuterClass but cannot access the nonstatic member variable memberOne."},{"Nature":"Good","Language":"Java","ExampleCode":"```\n\tpublic class OuterClass {\n```\n// private member variables of OuterClass* \n\t\t\tprivate String memberOne;\n\t\t\tprivate static String memberTwo;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor of OuterClass* \n\t\t\tpublic OuterClass(String varOne, String varTwo) {\n\t\t\t\n\t\t\t```\n\t\t\t\tthis.memberOne = varOne;\n\t\t\t\tthis.memberTwo = varTwo;\n\t\t\t}\n```\n// InnerClass is a static inner class of OuterClass* \n\t\t\tprivate static class InnerClass {\n\t\t\t```\n\t\t\t\t\tprivate String innerMemberOne;\n\t\t\t\t\tpublic InnerClass(String innerVarOne) {\n\t\t\t\t\t\tthis.innerMemberOne = innerVarOne;\n\t\t\t\t\t}\n\t\t\t\t\tpublic String concat(String separator) {\n```\n// InnerClass only has access to static member variables of OuterClass* \n\t\t\t\t\t\t\treturn memberTwo + separator + this.innerMemberOne;}}}"},{"BodyText":"The only limitation with using a static inner class is that as a static member of the enclosing class the inner class does not have a reference to instances of the enclosing class. For many situations this may not be ideal. An alternative is to use a local inner class or an anonymous inner class as shown in the next examples."}]},{"Entries":[{"IntroText":"In the following example the BankAccount class contains the private member inner class InterestAdder that adds interest to the bank account balance. The start method of the BankAccount class creates an object of the inner class InterestAdder, the InterestAdder inner class implements the ActionListener interface with the method actionPerformed. A Timer object created within the start method of the BankAccount class invokes the actionPerformed method of the InterestAdder class every 30 days to add the interest to the bank account balance based on the interest rate passed to the start method as an input parameter. The inner class InterestAdder needs access to the private member variable balance of the BankAccount class in order to add the interest to the bank account balance."},{"BodyText":"However as demonstrated in the previous example, because InterestAdder is a non-static member inner class of the BankAccount class, InterestAdder also has access to the private member variables of the BankAccount class - including the sensitive data contained in the private member variables for the bank account owner's name, Social Security number, and the bank account number."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(double rate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tActionListener adder = new InterestAdder(rate);\n\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\tt.start();\n\t\t\t}\n```\n// InterestAdder is an inner class of BankAccount class* \n\t\t\t\n\t\t\t\n\t\t\t *// that implements the ActionListener interface* \n\t\t\tprivate class InterestAdder implements ActionListener\n\t\t\t{\n\t\t\t```\n\t\t\t\t\tprivate double rate;\n\t\t\t\t\tpublic InterestAdder(double aRate)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.rate = aRate;\n\t\t\t\t\t}\n\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t{\n```\n// update interest* \n\t\t\t\t\t\t\tdouble interest = BankAccount.this.balance * rate / 100;\n\t\t\t\t\t\t\tBankAccount.this.balance += interest;}\n\t\t\t\t\t}}"},{"BodyText":"In the following example the InterestAdder class from the above example is declared locally within the start method of the BankAccount class. As a local inner class InterestAdder has its scope restricted to the method (or enclosing block) where it is declared, in this case only the start method has access to the inner class InterestAdder, no other classes including the enclosing class has knowledge of the inner class outside of the start method. This allows the inner class to access private member variables of the enclosing class but only within the scope of the enclosing method or block."},{"Nature":"Good","Language":"Java","ExampleCode":"```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(final double rate)\n\t\t\t{\n\t\t\t```\n```\n// InterestAdder is a local inner class* \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// that implements the ActionListener interface* \n\t\t\t\t\tclass InterestAdder implements ActionListener\n\t\t\t\t\t{\n\t\t\t\t\t```\n\t\t\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t\t\t{\n```\n// update interest* \n\t\t\t\t\t\t\t\t\tdouble interest = BankAccount.this.balance * rate / 100;\n\t\t\t\t\t\t\t\t\tBankAccount.this.balance += interest;}}\n\t\t\t\t\tActionListener adder = new InterestAdder();\n\t\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\t\tt.start();}}"},{"BodyText":"A similar approach would be to use an anonymous inner class as demonstrated in the next example. An anonymous inner class is declared without a name and creates only a single instance of the inner class object. As in the previous example the anonymous inner class has its scope restricted to the start method of the BankAccount class."},{"Nature":"Good","Language":"Java","ExampleCode":"```\n\tpublic class BankAccount {\n```\n// private member variables of BankAccount class* \n\t\t\tprivate String accountOwnerName;\n\t\t\tprivate String accountOwnerSSN;\n\t\t\tprivate int accountNumber;\n\t\t\tprivate double balance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount class* \n\t\t\tpublic BankAccount(String accountOwnerName, String accountOwnerSSN,\n\t\t\tint accountNumber, double initialBalance, int initialRate)\n\t\t\t{\n\t\t\t```\n\t\t\t\tthis.accountOwnerName = accountOwnerName;\n\t\t\t\tthis.accountOwnerSSN = accountOwnerSSN;\n\t\t\t\tthis.accountNumber = accountNumber;\n\t\t\t\tthis.balance = initialBalance;\n\t\t\t\tthis.start(initialRate);\n\t\t\t}\n```\n// start method will add interest to balance every 30 days* \n\t\t\t\n\t\t\t\n\t\t\t *// creates timer object and interest adding action listener object* \n\t\t\tpublic void start(final double rate)\n\t\t\t{\n\t\t\t```\n```\n// anonymous inner class that implements the ActionListener interface* \n\t\t\t\t\tActionListener adder = new ActionListener()\n\t\t\t\t\t{\n\t\t\t\t\t```\n\t\t\t\t\t\t\tpublic void actionPerformed(ActionEvent event)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t double interest = BankAccount.this.balance * rate / 100; \n\t\t\t\t\t\t\t\t\tBankAccount.this.balance += interest;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tTimer t = new Timer(1000 * 3600 * 24 * 30, adder);\n\t\t\t\t\tt.start();\n\t\t\t}\n\t}\n```"}]},{"Entries":[{"IntroText":"In the following Java example a simple applet provides the capability for a user to input a URL into a text field and have the URL opened in a new browser window. The applet contains an inner class that is an action listener for the submit button, when the user clicks the submit button the inner class action listener's actionPerformed method will open the URL entered into the text field in a new browser window. As with the previous examples using inner classes in this manner creates a security risk by exposing private variables and methods. Inner classes create an additional security risk with applets as applets are executed on a remote machine through a web browser within the same JVM and therefore may run side-by-side with other potentially malicious code."},{"Nature":"Bad","ExampleCode":"```\n\tpublic class UrlToolApplet extends Applet {\n```\n// private member variables for applet components* \n\t\t\tprivate Label enterUrlLabel;\n\t\t\tprivate TextField enterUrlTextField;\n\t\t\tprivate Button submitButton;\n\t\t\t\n\t\t\t\n\t\t\t *// init method that adds components to applet* \n\t\t\t\n\t\t\t\n\t\t\t *// and creates button listener object* \n\t\t\tpublic void init() {\n\t\t\t```\n\t\t\t\tsetLayout(new FlowLayout());\n\t\t\t\tenterUrlLabel = new Label(\"Enter URL: \");\n\t\t\t\tenterUrlTextField = new TextField(\"\", 20);\n\t\t\t\tsubmitButton = new Button(\"Submit\");\n\t\t\t\tadd(enterUrlLabel);\n\t\t\t\tadd(enterUrlTextField);\n\t\t\t\tadd(submitButton);\n\t\t\t\tActionListener submitButtonListener = new SubmitButtonListener();\n\t\t\t\tsubmitButton.addActionListener(submitButtonListener);\n\t\t\t}\n```\n// button listener inner class for UrlToolApplet class* \n\t\t\tprivate class SubmitButtonListener implements ActionListener {\n\t\t\t```\n\t\t\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t\t\t\t\tif (evt.getSource() == submitButton) {\n\t\t\t\t\t\t\t\tString urlString = enterUrlTextField.getText();\n\t\t\t\t\t\t\t\tURL url = null;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\turl = new URL(urlString);\n\t\t\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\t\t\tSystem.err.println(\"Malformed URL: \" + urlString);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\t\t\tgetAppletContext().showDocument(url);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"},{"BodyText":"As with the previous examples a solution to this problem would be to use a static inner class, a local inner class or an anonymous inner class. An alternative solution would be to have the applet implement the action listener rather than using it as an inner class as shown in the following example."},{"Nature":"Good","Language":"Java","ExampleCode":"```\n\tpublic class UrlToolApplet extends Applet implements ActionListener {\n```\n// private member variables for applet components* \n\t\t\tprivate Label enterUrlLabel;\n\t\t\tprivate TextField enterUrlTextField;\n\t\t\tprivate Button submitButton;\n\t\t\t\n\t\t\t\n\t\t\t *// init method that adds components to applet* \n\t\t\tpublic void init() {\n\t\t\t```\n\t\t\t\tsetLayout(new FlowLayout());\n\t\t\t\tenterUrlLabel = new Label(\"Enter URL: \");\n\t\t\t\tenterUrlTextField = new TextField(\"\", 20);\n\t\t\t\tsubmitButton = new Button(\"Submit\");\n\t\t\t\tadd(enterUrlLabel);\n\t\t\t\tadd(enterUrlTextField);\n\t\t\t\tadd(submitButton);\n\t\t\t\tsubmitButton.addActionListener(this);\n\t\t\t}\n```\n// implementation of actionPerformed method of ActionListener interface* \n\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t```\n\t\t\t\t\tif (evt.getSource() == submitButton) {\n\t\t\t\t\t\tString urlString = enterUrlTextField.getText();\n\t\t\t\t\t\tURL url = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\turl = new URL(urlString);\n\t\t\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t\t\tSystem.err.println(\"Malformed URL: \" + urlString);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\tgetAppletContext().showDocument(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t}\n```"}]}],"TaxonomyMappings":[{"TaxonomyName":"7 Pernicious Kingdoms","EntryName":"Mobile Code: Use of Inner Class"},{"TaxonomyName":"CLASP","EntryName":"Publicizing of private data when using inner classes"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"OBJ08-J","EntryName":"Do not expose private members of an outer class from within a nested class"}],"References":[{"ExternalReferenceID":"REF-6","Authors":["Katrina Tsipenyuk","Brian Chess","Gary McGraw"],"Title":"Seven Pernicious Kingdoms: A Taxonomy of Software Security Errors","Publication":"NIST Workshop on Software Security Assurance Tools Techniques and Metrics","PublicationYear":"2005","PublicationMonth":"11","PublicationDay":"07","Publisher":"NIST","URL":"https://samate.nist.gov/SSATTM_Content/papers/Seven%20Pernicious%20Kingdoms%20-%20Taxonomy%20of%20Sw%20Security%20Errors%20-%20Tsipenyuk%20-%20Chess%20-%20McGraw.pdf"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"Notes":[{"Type":"Other","Note":"Mobile code, in this case a Java Applet, is code that is transmitted across a network and executed on a remote machine. Because mobile code developers have little if any control of the environment in which their code will execute, special security concerns become relevant. One of the biggest environmental threats results from the risk that the mobile code will run side-by-side with other, potentially malicious, mobile code. Because all of the popular web browsers execute code from multiple sources together in the same JVM, many of the security guidelines for mobile code are focused on preventing manipulation of your objects' state and behavior by adversaries who have access to the same virtual machine where your program is running."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"7 Pernicious Kingdoms","SubmissionDate":"2006-07-19","SubmissionVersion":"Draft 3","SubmissionReleaseDate":"2006-07-19"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Common_Consequences, Relationships, Other_Notes, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-03-10","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-12-28","ModificationComment":"updated Demonstrative_Examples, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-06-23","ModificationComment":"updated Description, Other_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Description, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Rename","PreviousEntryName":"Mobile Code: Use of Inner Class","Date":"2008-04-11"}]}