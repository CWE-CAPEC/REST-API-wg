{"ID":"1325","Name":"Improperly Controlled Sequential Memory Allocation","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product manages a group of objects or resources and performs a separate memory allocation for each object, but it does not properly limit the total amount of memory that is consumed by all of the combined objects.","ExtendedDescription":"\n\nWhile the product might limit the amount of memory that is allocated in a single operation for a single object (such as a malloc of an array), if an attacker can cause multiple objects to be allocated in separate operations, then this might cause higher total memory consumption than the developer intended, leading to a denial of service.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"770","ViewID":"1000","Ordinal":"Primary"},{"Nature":"PeerOf","CweID":"789","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"476","ViewID":"1000"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"},{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"}],"AlternateTerms":[{"Term":"Stack Exhaustion","Description":"When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325."}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (Memory)"],"Note":"Not controlling memory allocation can result in a request for too much system memory, possibly leading to a crash of the application due to out-of-memory conditions, or the consumption of a large amount of memory on the system."}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Ensure multiple allocations of the same kind of object are properly tracked - possibly across multiple sessions, requests, or messages. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary."},{"Phase":["Operation"],"Description":"Run the program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"This example contains a small allocation of stack memory. When the program was first constructed, the number of times this memory was allocated was probably inconsequential and presented no problem. Over time, as the number of objects in the database grow, the number of allocations will grow - eventually consuming the available stack, i.e. \"stack exhaustion.\" An attacker who is able to add elements to the database could cause stack exhaustion more rapidly than assumed by the developer."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n```\n// Gets the size from the number of objects in a database, which over time can conceivably get very large* \n\t int end_limit = get_nmbr_obj_from_db();\n\t int i;\n\t int *base = NULL;\n\t int *p =base;\n\t for (i = 0; i \u003c end_limit; i++)\n\t {\n\t\n\t```\n\t\t *p = alloca(sizeof(int *)); \n```\n// Allocate memory on the stack* \n\t\t p = *p; \n\t\t *// // Point to the next location to be saved* \n\t\t }"},{"BodyText":"Since this uses alloca(), it allocates memory directly on the stack. If end_limit is large enough, then the stack can be entirely consumed."}]}],"ObservedExamples":[{"Reference":"CVE-2020-36049","Description":"JavaScript-based packet decoder uses concatenation of many small strings, causing out-of-memory (OOM) condition","Link":"https://www.cve.org/CVERecord?id=CVE-2020-36049"},{"Reference":"CVE-2019-20176","Description":"Product allocates a new buffer on the stack for each file in a directory, allowing stack exhaustion","Link":"https://www.cve.org/CVERecord?id=CVE-2019-20176"},{"Reference":"CVE-2013-1591","Description":"Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.","Link":"https://www.cve.org/CVERecord?id=CVE-2013-1591"}],"RelatedAttackPatterns":["130"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2020-12-07","SubmissionVersion":"4.3","SubmissionReleaseDate":"2020-12-10"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}