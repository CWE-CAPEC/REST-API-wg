{"ID":"120","Name":"Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Diagram":"/data/images/CWE-120-Diagram.png","Description":"The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer.","LikelihoodOfExploit":"High","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"787","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1003","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"787","ViewID":"1305","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"787","ViewID":"1340","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"123","ViewID":"1000"},{"Nature":"ChildOf","CweID":"20","ViewID":"700","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Resultant"},{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Memory-Unsafe","Prevalence":"Undetermined"},{"Type":"Language","Name":"C","Prevalence":"Often"},{"Type":"Language","Name":"C++","Prevalence":"Often"},{"Type":"Language","Class":"Assembly","Prevalence":"Undetermined"}],"AlternateTerms":[{"Term":"Classic Buffer Overflow","Description":"This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques."},{"Term":"Unbounded Transfer"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Integrity","Confidentiality","Availability"],"Impact":["Modify Memory","Execute Unauthorized Code or Commands"],"Note":"Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of the product's implicit security policy. This can often be used to subvert any other security service."},{"Scope":["Availability"],"Impact":["Modify Memory","DoS: Crash, Exit, or Restart","DoS: Resource Consumption (CPU)"],"Note":"Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the product into an infinite loop."}],"DetectionMethods":[{"DetectionMethodID":"DM-1","Method":"Automated Static Analysis","Description":"\n\nThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\n\n\nAutomated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\n","Effectiveness":"High","EffectivenessNotes":"Detection techniques for buffer-related errors are more mature than for most other weakness types."},{"DetectionMethodID":"DM-2","Method":"Automated Dynamic Analysis","Description":"This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."},{"DetectionMethodID":"DM-9","Method":"Manual Analysis","Description":"Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large."},{"DetectionMethodID":"DM-15","Method":"Automated Dynamic Analysis","Description":"Use tools that are integrated during compilation to insert runtime error-checking mechanisms related to memory safety errors, such as AddressSanitizer (ASan) for C/C++ [REF-1518].","Effectiveness":"Moderate","EffectivenessNotes":"Crafted inputs are necessary to reach the code containing the error, such as generated by fuzzers. Also, these tools may reduce performance, and they only report the error condition - not the original mistake that led to the error."},{"Method":"Automated Static Analysis - Binary or Bytecode","Description":"\n\nAccording to SOAR [REF-1479], the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis","Effectiveness":"High"},{"Method":"Manual Static Analysis - Binary or Bytecode","Description":"\n\nAccording to SOAR [REF-1479], the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities \u0026 anomalies","Effectiveness":"SOAR Partial"},{"Method":"Dynamic Analysis with Automated Results Interpretation","Description":"\n\nAccording to SOAR [REF-1479], the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tWeb Application Scanner\n\t\tWeb Services Scanner\n\t\tDatabase Scanners","Effectiveness":"SOAR Partial"},{"Method":"Dynamic Analysis with Manual Results Interpretation","Description":"\n\nAccording to SOAR [REF-1479], the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFuzz Tester\n\t\tFramework-based Fuzzer","Effectiveness":"SOAR Partial"},{"Method":"Manual Static Analysis - Source Code","Description":"\n\nAccording to SOAR [REF-1479], the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)","Effectiveness":"SOAR Partial"},{"Method":"Automated Static Analysis - Source Code","Description":"\n\nAccording to SOAR [REF-1479], the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer","Effectiveness":"High"},{"Method":"Architecture or Design Review","Description":"\n\nAccording to SOAR [REF-1479], the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"MitigationID":"MIT-3","Phase":["Requirements"],"Strategy":"Language Selection","Description":"\n\nUse a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nFor example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.\n\n\nBe wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.\n"},{"MitigationID":"MIT-4.1","Phase":["Architecture and Design"],"Strategy":"Libraries or Frameworks","Description":"\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nExamples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.\n","EffectivenessNotes":"This is not a complete solution, since many buffer overflows are not related to strings."},{"MitigationID":"MIT-10","Phase":["Operation","Build and Compilation"],"Strategy":"Environment Hardening","Description":"\n\nUse automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. \n\n\n D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"\n\n This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. \n"},{"MitigationID":"MIT-9","Phase":["Implementation"],"Description":"\n\nConsider adhering to the following rules when allocating and managing an application's memory:\n\n\n  - Double check that your buffer is as large as you specify.\n\n  - When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.\n\n  - Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.\n\n  - If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.\n\n"},{"MitigationID":"MIT-5","Phase":["Implementation"],"Strategy":"Input Validation","Description":"\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n"},{"MitigationID":"MIT-15","Phase":["Architecture and Design"],"Description":"For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."},{"MitigationID":"MIT-11","Phase":["Operation","Build and Compilation"],"Strategy":"Environment Hardening","Description":"\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]."},{"MitigationID":"MIT-12","Phase":["Operation"],"Strategy":"Environment Hardening","Description":"\n\n Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. \n\n\n For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."},{"Phase":["Build and Compilation","Operation"],"Description":"Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution."},{"MitigationID":"MIT-13","Phase":["Implementation"],"Description":"Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.","Effectiveness":"Moderate","EffectivenessNotes":"This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131)."},{"MitigationID":"MIT-21","Phase":["Architecture and Design"],"Strategy":"Enforcement by Conversion","Description":"When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."},{"MitigationID":"MIT-17","Phase":["Architecture and Design","Operation"],"Strategy":"Environment Hardening","Description":"Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."},{"MitigationID":"MIT-22","Phase":["Architecture and Design","Operation"],"Strategy":"Sandbox or Jail","Description":"\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n","Effectiveness":"Limited","EffectivenessNotes":"The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The following code asks the user to enter their last name and then attempts to store the value entered in the last_name array."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar last_name[20];\n\tprintf (\"Enter your last name: \");\n\tscanf (\"%s\", last_name);\n```"},{"BodyText":"The problem with the code above is that it does not restrict or limit the size of the name entered by the user. If the user enters \"Very_very_long_last_name\" which is 24 characters long, then a buffer overflow will occur since the array can only hold 20 characters total."}]},{"ID":"DX-6","Entries":[{"IntroText":"The following code attempts to create a local copy of a buffer to perform some manipulations to the data."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tvoid manipulate_string(char * string){\n\t\tchar buf[24];\n\t\tstrcpy(buf, string);\n\t\t...\n\t}\n```"},{"BodyText":"However, the programmer does not ensure that the size of the data pointed to by string will fit in the local buffer and copies the data with the potentially dangerous strcpy() function. This may result in a buffer overflow condition if an attacker can influence the contents of the string parameter."}]},{"ID":"DX-5","Entries":[{"IntroText":"The code below calls the gets() function to read in data from the command line."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t\tchar buf[24];\n\t\tprintf(\"Please enter your name and press \u003cEnter\u003e\\n\");\n\t\tgets(buf);\n\t\t...\n\t}\n```"},{"BodyText":"However, gets() is inherently unsafe, because it copies all input from STDIN to the buffer without checking size. This allows the user to provide a string that is larger than the buffer size, resulting in an overflow condition."}]},{"Entries":[{"IntroText":"In the following example, a server accepts connections from a client and processes the client request. After accepting a client connection, the program will obtain client information using the gethostbyaddr method, copy the hostname of the client that connected to a local variable and output the hostname of the client to a log file."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t...\n\t\t\tstruct hostent *clienthp;\n\t\t\tchar hostname[MAX_LEN];\n\t\t\t// create server socket, bind to server address and listen on socket\n\t\t\t...\n\t\t\t// accept client connections and process requests\n\t\t\tint count = 0;\n\t\t\tfor (count = 0; count \u003c MAX_CONNECTIONS; count++) {\n\t\t\t\t\tint clientlen = sizeof(struct sockaddr_in);\n\t\t\t\t\tint clientsocket = accept(serversocket, (struct sockaddr *)\u0026clientaddr, \u0026clientlen);\n\t\t\t\t\tif (clientsocket \u003e= 0) {\n\t\t\t\t\t\t\tclienthp = gethostbyaddr((char*) \u0026clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET);\n\t\t\t\t\t\t\tstrcpy(hostname, clienthp-\u003eh_name);\n\t\t\t\t\t\t\tlogOutput(\"Accepted client connection from host \", hostname);\n\t\t\t\t\t\t\t// process client request\n\t\t\t\t\t\t\t...\n\t\t\t\t\t\t\tclose(clientsocket);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tclose(serversocket);\n\t...\n```"},{"BodyText":"However, the hostname of the client that connected may be longer than the allocated size for the local hostname variable. This will result in a buffer overflow when copying the client hostname to the local variable using the strcpy method."}]}],"ObservedExamples":[{"Reference":"CVE-2000-1094","Description":"buffer overflow using command with long argument","Link":"https://www.cve.org/CVERecord?id=CVE-2000-1094"},{"Reference":"CVE-1999-0046","Description":"buffer overflow in local program using long environment variable","Link":"https://www.cve.org/CVERecord?id=CVE-1999-0046"},{"Reference":"CVE-2002-1337","Description":"buffer overflow in comment characters, when product increments a counter for a \"\u003e\" but does not decrement for \"\u003c\"","Link":"https://www.cve.org/CVERecord?id=CVE-2002-1337"},{"Reference":"CVE-2003-0595","Description":"By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.","Link":"https://www.cve.org/CVERecord?id=CVE-2003-0595"},{"Reference":"CVE-2001-0191","Description":"By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.","Link":"https://www.cve.org/CVERecord?id=CVE-2001-0191"}],"FunctionalAreas":["Memory Management"],"AffectedResources":["Memory"],"TaxonomyMappings":[{"TaxonomyName":"PLOVER","EntryName":"Unbounded Transfer ('classic overflow')"},{"TaxonomyName":"7 Pernicious Kingdoms","EntryName":"Buffer Overflow"},{"TaxonomyName":"CLASP","EntryName":"Buffer overflow"},{"TaxonomyName":"OWASP Top Ten 2004","EntryID":"A1","EntryName":"Unvalidated Input","MappingFit":"CWE More Specific"},{"TaxonomyName":"OWASP Top Ten 2004","EntryID":"A5","EntryName":"Buffer Overflows","MappingFit":"CWE More Specific"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"STR31-C","EntryName":"Guarantee that storage for strings has sufficient space for character data and the null terminator","MappingFit":"Exact"},{"TaxonomyName":"WASC","EntryID":"7","EntryName":"Buffer Overflow"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP8","EntryName":"Faulty Buffer Access"},{"TaxonomyName":"OMG ASCSM","EntryID":"ASCSM-CWE-120"},{"TaxonomyName":"OMG ASCRM","EntryID":"ASCRM-CWE-120"}],"RelatedAttackPatterns":["10","100","14","24","42","44","45","46","47","67","8","9","92"],"References":[{"ExternalReferenceID":"REF-7","Section":"Chapter 5, \"Public Enemy #1: The Buffer Overrun\" Page 127","Authors":["Michael Howard","David LeBlanc"],"Title":"Writing Secure Code","Edition":"2nd Edition","PublicationYear":"2002","PublicationMonth":"12","PublicationDay":"04","Publisher":"Microsoft Press","URL":"https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"},{"ExternalReferenceID":"REF-44","Section":"\"Sin 5: Buffer Overruns.\" Page 89","Authors":["Michael Howard","David LeBlanc","John Viega"],"Title":"24 Deadly Sins of Software Security","Publication":"McGraw-Hill","PublicationYear":"2010"},{"ExternalReferenceID":"REF-56","Authors":["Microsoft"],"Title":"Using the Strsafe.h Functions","URL":"https://learn.microsoft.com/en-us/windows/win32/menurc/strsafe-ovw?redirectedfrom=MSDN","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-57","Authors":["Matt Messier","John Viega"],"Title":"Safe C String Library v1.0.3","URL":"http://www.gnu-darwin.org/www001/ports-1.5a-CURRENT/devel/safestr/work/safestr-1.0.3/doc/safestr.html","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-58","Authors":["Michael Howard"],"Title":"Address Space Layout Randomization in Windows Vista","URL":"https://learn.microsoft.com/en-us/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-59","Authors":["Arjan van de Ven"],"Title":"Limiting buffer overflows with ExecShield","URL":"https://archive.is/saAFo","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-60","Title":"PaX","URL":"https://en.wikipedia.org/wiki/Executable_space_protection#PaX","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-74","Authors":["Jason Lam"],"Title":"Top 25 Series - Rank 3 - Classic Buffer Overflow","PublicationYear":"2010","PublicationMonth":"03","PublicationDay":"02","Publisher":"SANS Software Security Institute","URL":"https://www.sans.org/blog/top-25-series-rank-3-classic-buffer-overflow","URLDate":"2025-07-29"},{"ExternalReferenceID":"REF-61","Authors":["Microsoft"],"Title":"Understanding DEP as a mitigation technology part 1","URL":"https://msrc.microsoft.com/blog/2009/06/understanding-dep-as-a-mitigation-technology-part-1/","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-76","Authors":["Sean Barnum","Michael Gegick"],"Title":"Least Privilege","PublicationYear":"2005","PublicationMonth":"09","PublicationDay":"14","URL":"https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-62","Section":"Chapter 3, \"Nonexecutable Stack\", Page 76","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-62","Section":"Chapter 5, \"Protection Mechanisms\", Page 189","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-62","Section":"Chapter 8, \"C String Handling\", Page 388","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-64","Authors":["Grant Murphy"],"Title":"Position Independent Executables (PIE)","PublicationYear":"2012","PublicationMonth":"11","PublicationDay":"28","Publisher":"Red Hat","URL":"https://www.redhat.com/en/blog/position-independent-executables-pie","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-961","Section":"ASCRM-CWE-120","Authors":["Object Management Group (OMG)"],"Title":"Automated Source Code Reliability Measure (ASCRM)","PublicationYear":"2016","PublicationMonth":"01","URL":"http://www.omg.org/spec/ASCRM/1.0/"},{"ExternalReferenceID":"REF-962","Section":"ASCSM-CWE-120","Authors":["Object Management Group (OMG)"],"Title":"Automated Source Code Security Measure (ASCSM)","PublicationYear":"2016","PublicationMonth":"01","URL":"http://www.omg.org/spec/ASCSM/1.0/"},{"ExternalReferenceID":"REF-1332","Authors":["John Richard Moser"],"Title":"Prelink and address space randomization","PublicationYear":"2006","PublicationMonth":"07","PublicationDay":"05","URL":"https://lwn.net/Articles/190139/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1333","Authors":["Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh"],"Title":"Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR","PublicationYear":"2016","URL":"http://www.cs.ucr.edu/~nael/pubs/micro16.pdf","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1334","Authors":["D3FEND"],"Title":"Stack Frame Canary Validation (D3-SFCV)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:StackFrameCanaryValidation/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1335","Authors":["D3FEND"],"Title":"Segment Address Offset Randomization (D3-SAOR)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:SegmentAddressOffsetRandomization/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1336","Authors":["D3FEND"],"Title":"Process Segment Execution Prevention (D3-PSEP)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:ProcessSegmentExecutionPrevention/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1337","Section":"Memory information leaks","Authors":["Alexander Sotirov and Mark Dowd"],"Title":"Bypassing Browser Memory Protections: Setting back browser security by 10 years","PublicationYear":"2008","URL":"https://www.blackhat.com/presentations/bh-usa-08/Sotirov_Dowd/bh08-sotirov-dowd.pdf","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1479","Authors":["Gregory Larsen","E. Kenneth Hong Fong","David A. Wheeler","Rama S. Moorthy"],"Title":"State-of-the-Art Resources (SOAR) for Software Vulnerability Detection, Test, and Evaluation","PublicationYear":"2014","PublicationMonth":"07","URL":"https://www.ida.org/-/media/feature/publications/s/st/stateoftheart-resources-soar-for-software-vulnerability-detection-test-and-evaluation/p-5061.ashx","URLDate":"2025-09-05"},{"ExternalReferenceID":"REF-1518","Authors":[""],"Title":"AddressSanitizer","URL":"https://clang.llvm.org/docs/AddressSanitizer.html","URLDate":"2025-12-10"}],"MappingNotes":{"Usage":"Allowed-with-Review","Rationale":"There are some indications that this CWE ID might be misused and selected simply because it mentions \"buffer overflow\" - an increasingly vague term. This CWE entry is only appropriate for \"Buffer Copy\" operations (not buffer reads), in which where there is no \"Checking [the] Size of Input\", and (by implication of the copy) writing past the end of the buffer.","Comments":"If the vulnerability being analyzed involves out-of-bounds reads, then consider CWE-125 or descendants. For root cause analysis: if there is any input validation, consider children of CWE-20 such as CWE-1284. If there is a calculation error for buffer sizes, consider CWE-131 or similar.","Reasons":["Frequent Misuse"]},"Notes":[{"Type":"Other","Note":"A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the \"classic\" case in which the product copies the buffer without restricting how much data is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections."},{"Type":"Relationship","Note":"At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them."},{"Type":"Terminology","Note":"There is significant inconsistency regarding the \"buffer overflow\" term, which can have multiple interpretations and uses. Many people mean \"writing past the end of a buffer.\" Others mean \"writing past the end of a buffer, or before the beginning of a buffer.\" Still others might include \"read\" in the term."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"PLOVER","SubmissionDate":"2006-07-19","SubmissionVersion":"Draft 3","SubmissionReleaseDate":"2006-07-19"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Time_of_Introduction"},{"Type":"Modification","ModificationOrganization":"KDM Analytics","ModificationDate":"2008-08-01","ModificationComment":"added/updated white box definitions"},{"Type":"Modification","ModificationOrganization":"Veracode","ModificationDate":"2008-08-15","ModificationComment":"Suggested OWASP Top Ten 2004 mapping"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Alternate_Terms, Applicable_Platforms, Common_Consequences, Relationships, Observed_Example, Other_Notes, Taxonomy_Mappings, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-10-10","ModificationComment":"Changed name and description to more clearly emphasize the \"classic\" nature of the overflow."},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-10-14","ModificationComment":"updated Alternate_Terms, Description, Name, Other_Notes, Terminology_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Other_Notes, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-01-12","ModificationComment":"updated Common_Consequences, Other_Notes, Potential_Mitigations, References, Relationship_Notes, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-07-27","ModificationComment":"updated Other_Notes, Potential_Mitigations, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-10-29","ModificationComment":"updated Common_Consequences, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-02-16","ModificationComment":"updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Detection_Factors, Potential_Mitigations, References, Related_Attack_Patterns, Relationships, Taxonomy_Mappings, Time_of_Introduction, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-04-05","ModificationComment":"updated Demonstrative_Examples, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-06-21","ModificationComment":"updated Common_Consequences, Potential_Mitigations, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-09-27","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-12-13","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-03-29","ModificationComment":"updated Demonstrative_Examples, Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Potential_Mitigations, References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-10-30","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-02-18","ModificationComment":"updated Potential_Mitigations, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Detection_Factors, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Applicable_Platforms, Causal_Nature, Demonstrative_Examples, Likelihood_of_Exploit, References, Relationships, Taxonomy_Mappings, White_Box_Definitions"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2018-03-27","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Potential_Mitigations, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-06-25","ModificationComment":"updated Common_Consequences, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Alternate_Terms, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Demonstrative_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Common_Consequences, Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Potential_Mitigations, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-04-03","ModificationComment":"updated Applicable_Platforms, Relationships","ModificationVersion":"4.17","ModificationReleaseDate":"2025-04-03"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-09-09","ModificationComment":"updated Description, Detection_Factors, Diagram, Other_Notes, References","ModificationVersion":"4.18","ModificationReleaseDate":"2025-09-09"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2025-12-11","ModificationComment":"updated Applicable_Platforms, Detection_Factors, References, Terminology_Notes","ModificationVersion":"4.19","ModificationReleaseDate":"2025-12-11"},{"Type":"Rename","PreviousEntryName":"Unbounded Transfer ('Classic Buffer Overflow')","Date":"2008-10-14"}]}