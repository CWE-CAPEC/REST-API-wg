{"ID":"192","Name":"Integer Coercion Error","Abstraction":"Variant","Structure":"Simple","Status":"Incomplete","Description":"Integer coercion refers to a set of flaws pertaining to the type casting, extension, or truncation of primitive data types.","ExtendedDescription":"Several flaws fall under the category of integer coercion errors. For the most part, these errors in and of themselves result only in availability and data integrity issues. However, in some circumstances, they may result in other, more complicated security related flaws, such as buffer overflow conditions.","LikelihoodOfExploit":"Medium","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"681","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"},{"Type":"Language","Name":"Java","Prevalence":"Undetermined"},{"Type":"Language","Name":"C#","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (CPU)","DoS: Resource Consumption (Memory)","DoS: Crash, Exit, or Restart"],"Note":"Integer coercion often leads to undefined states of execution resulting in infinite loops or crashes."},{"Scope":["Integrity","Confidentiality","Availability"],"Impact":["Execute Unauthorized Code or Commands"],"Note":"In some cases, integer coercion errors can lead to exploitable buffer overflow conditions, resulting in the execution of arbitrary code."},{"Scope":["Integrity","Other"],"Impact":["Other"],"Note":"Integer coercion errors result in an incorrect value being stored for the variable in question."}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Requirements"],"Description":"A language which throws exceptions on ambiguous data casts might be chosen."},{"Phase":["Architecture and Design"],"Description":"Design objects and program flow such that multiple or complex casts are unnecessary"},{"Phase":["Implementation"],"Description":"Ensure that any data type casting that you must used is entirely understood in order to reduce the plausibility of error in use."}],"DemonstrativeExamples":[{"ID":"DX-21","Entries":[{"IntroText":"The following code is intended to read an incoming packet from a socket and extract one or more headers."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tDataPacket *packet;\n\tint numHeaders;\n\tPacketHeader *headers;\n\tsock=AcceptSocketConnection();\n\tReadPacket(packet, sock);\n\tnumHeaders =packet-\u003eheaders;\n\tif (numHeaders \u003e 100) {\n\t\tExitError(\"too many headers!\");\n\t}\n\theaders = malloc(numHeaders * sizeof(PacketHeader);\n\tParsePacketHeaders(packet, headers);\n```"},{"BodyText":"The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."}]},{"ID":"DX-23","Entries":[{"IntroText":"The following code reads a maximum size and performs validation on that size. It then performs a strncpy, assuming it will not exceed the boundaries of the array. While the use of \"short s\" is forced in this particular example, short int's are frequently used within real-world code, such as code that processes structured data."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint GetUntrustedInt () {\n\t\treturn(0x0000FFFF);\n\t}\n\tvoid main (int argc, char **argv) {\n\t\t\tchar path[256];\n\t\t\tchar *input;\n\t\t\tint i;\n\t\t\tshort s;\n\t\t\tunsigned int sz;\n\t\t\ti = GetUntrustedInt();\n\t\t\ts = i;\n\t\t\t/* s is -1 so it passes the safety check - CWE-697 */\n\t\t\tif (s \u003e 256) {\n\t\t\t\tDiePainfully(\"go away!\\n\");\n\t\t\t}\n\t\t\t/* s is sign-extended and saved in sz */\n\t\t\tsz = s;\n\t\t\t/* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */\n\t\t\tprintf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\n\t\t\tinput = GetUserInput(\"Enter pathname:\");\n\t\t\t/* strncpy interprets s as unsigned int, so it's treated as MAX_INT\n\t\t\t(CWE-195), enabling buffer overflow (CWE-119) */\n\t\t\tstrncpy(path, input, s);\n\t\t\tpath[255] = '\\0'; /* don't want CWE-170 */\n\t\t\tprintf(\"Path is: %s\\n\", path);\n\t}\n```"},{"BodyText":"This code first exhibits an example of CWE-839, allowing \"s\" to be a negative number. When the negative short \"s\" is converted to an unsigned integer, it becomes an extremely large positive integer. When this converted integer is used by strncpy() it will lead to a buffer overflow (CWE-119)."}]}],"ObservedExamples":[{"Reference":"CVE-2022-2639","Description":"Chain: integer coercion error (CWE-192) prevents a return value from indicating an error, leading to out-of-bounds write (CWE-787)","Link":"https://www.cve.org/CVERecord?id=CVE-2022-2639"}],"TaxonomyMappings":[{"TaxonomyName":"CLASP","EntryName":"Integer coercion error"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"INT02-C","EntryName":"Understand integer conversion rules"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"INT05-C","EntryName":"Do not use input functions to convert character data if they cannot handle all possible inputs"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"INT31-C","EntryName":"Ensure that integer conversions do not result in lost or misinterpreted data","MappingFit":"Exact"}],"References":[{"ExternalReferenceID":"REF-44","Section":"\"Sin 7: Integer Overflows.\" Page 119","Authors":["Michael Howard","David LeBlanc","John Viega"],"Title":"24 Deadly Sins of Software Security","Publication":"McGraw-Hill","PublicationYear":"2010"},{"ExternalReferenceID":"REF-62","Section":"Chapter 6, \"Sign Extension\", Page 248","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-18","Authors":["Secure Software, Inc."],"Title":"The CLASP Application Security Process","PublicationYear":"2005","URL":"https://cwe.mitre.org/documents/sources/TheCLASPApplicationSecurityProcess.pdf","URLDate":"2024-11-17"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"Notes":[{"Type":"Maintenance","Note":"Within C, it might be that \"coercion\" is semantically different than \"casting\", possibly depending on whether the programmer directly specifies the conversion, or if the compiler does it implicitly. This has implications for the presentation of this entry and others, such as CWE-681, and whether there is enough of a difference for these entries to be split."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CLASP","SubmissionDate":"2006-07-19","SubmissionVersion":"Draft 3","SubmissionReleaseDate":"2006-07-19"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Applicable_Platforms, Common_Consequences, Maintenance_Notes, Relationships, Other_Notes, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-12-28","ModificationComment":"updated Description, Other_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-04-05","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-10-30","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Relationships, Taxonomy_Mappings, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Demonstrative_Examples, Maintenance_Notes, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-10-26","ModificationComment":"updated Observed_Examples"}]}