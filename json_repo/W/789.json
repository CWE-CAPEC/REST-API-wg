{"ID":"789","Name":"Memory Allocation with Excessive Size Value","Abstraction":"Variant","Structure":"Simple","Status":"Draft","Description":"The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"770","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"476","ViewID":"1000"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"},{"Ordinality":"Resultant"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"},{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"}],"AlternateTerms":[{"Term":"Stack Exhaustion","Description":"When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325."}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (Memory)"],"Note":"Not controlling memory allocation can result in a request for too much system memory, possibly leading to a crash of the application due to out-of-memory conditions, or the consumption of a large amount of memory on the system."}],"DetectionMethods":[{"DetectionMethodID":"DM-13","Method":"Fuzzing","Description":"Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.","Effectiveness":"High"},{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Implementation","Architecture and Design"],"Description":"Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary."},{"Phase":["Operation"],"Description":"Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"Consider the following code, which accepts an untrusted size value and allocates a buffer to contain a string of the given size."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tunsigned int size = GetUntrustedInt();\n```\n/* ignore integer overflow (CWE-190) for this example */* \n\t\n\tunsigned int totBytes = size * sizeof(char);\n\tchar *string = (char *)malloc(totBytes);\n\tInitializeString(string);"},{"BodyText":"Suppose an attacker provides a size value of:"},{"BodyText":"```\n\t\t12345678\n```"},{"BodyText":"This will cause 305,419,896 bytes (over 291 megabytes) to be allocated for the string."}]},{"Entries":[{"IntroText":"Consider the following code, which accepts an untrusted size value and uses the size as an initial capacity for a HashMap."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tunsigned int size = GetUntrustedInt();\n\tHashMap list = new HashMap(size);\n```"},{"BodyText":"The HashMap constructor will verify that the initial capacity is not negative, however there is no check in place to verify that sufficient memory is present. If the attacker provides a large enough value, the application will run into an OutOfMemoryError."}]},{"ID":"DX-137","Entries":[{"IntroText":"This code performs a stack allocation based on a length calculation."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t int a = 5, b = 6;\n\t size_t len = a - b;\n\t char buf[len]; // Just blows up the stack \n }\n```"},{"BodyText":"Since a and b are declared as signed ints, the \"a - b\" subtraction gives a negative result (-1). However, since len is declared to be unsigned, len is cast to an extremely large positive number (on 32-bit systems - 4294967295). As a result, the buffer buf[len] declaration uses an extremely large size to allocate on the stack, very likely more than the entire computer's memory space."},{"BodyText":"Miscalculations usually will not be so obvious. The calculation will either be complicated or the result of an attacker's input to attain the negative value."}]},{"ID":"DX-138","Entries":[{"IntroText":"This example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action."},{"Nature":"Bad","Language":"C","ExampleCode":"int proc_msg(char *s, int msg_len)\n {\n\n```\n```\n// Note space at the end of the string - assume all strings have preamble with space* \n\t int pre_len = sizeof(\"preamble: \");\n\t char buf[pre_len - msg_len];\n\t\n\t *... Do processing here if we get this far*  }\n char *s = \"preamble: message\\n\";\n char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)\n int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length\n int ret_val = proc_msg (\"s\", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack"},{"BodyText":"The buffer length ends up being -1, resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations."}]},{"Entries":[{"IntroText":"The following code obtains an untrusted number that is used as an index into an array of messages."},{"Nature":"Bad","Language":"Perl","ExampleCode":"```\n\tmy $num = GetUntrustedNumber();\n\tmy @messages = ();\n\t$messages[$num] = \"Hello World\";\n```"},{"BodyText":"The index is not validated at all (CWE-129), so it might be possible for an attacker to modify an element in @messages that was not intended. If an index is used that is larger than the current size of the array, the Perl interpreter automatically expands the array so that the large index works."},{"BodyText":"If $num is a large value such as 2147483648 (1\u003c\u003c31), then the assignment to $messages[$num] would attempt to create a very large array, then eventually produce an error message such as:"},{"BodyText":"Out of memory during array extend"},{"BodyText":"This memory exhaustion will cause the Perl program to exit, possibly a denial of service. In addition, the lack of memory could also prevent many other programs from successfully running on the system."}]},{"Entries":[{"IntroText":"This example shows a typical attempt to parse a string with an error resulting from a difference in assumptions between the caller to a function and the function's action. The buffer length ends up being -1 resulting in a blown out stack. The space character after the colon is included in the function calculation, but not in the caller's calculation. This, unfortunately, is not usually so obvious but exists in an obtuse series of calculations."},{"Nature":"Bad","Language":"C","ExampleCode":"int proc_msg(char *s, int msg_len)\n {\n\n```\n\tint pre_len = sizeof(\"preamble: \"); // Note space at the end of the string - assume all strings have preamble with space\n\tchar buf[pre_len - msg_len];\n\t... Do processing here and set status\n\treturn status;\n } \n char *s = \"preamble: message\\n\";\n char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)\n int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length\n int ret_val = proc_msg (\"s\", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack\n```"},{"Nature":"Good","Language":"C","ExampleCode":"int proc_msg(char *s, int msg_len)\n {\n\n```\n\tint pre_len = sizeof(\"preamble: \"); // Note space at the end of the string - assume all strings have preamble with space\n\tif (pre_len \u003c= msg_len) { // Log error; return error_code; }\n\tchar buf[pre_len - msg_len];\n\t... Do processing here and set status\n\treturn status;\n } \n char *s = \"preamble: message\\n\";\n char *sl = strchr(s, ':'); // Number of characters up to ':' (not including space)\n int jnklen = sl == NULL ? 0 : sl - s; // If undefined pointer, use zero length\n int ret_val = proc_msg (\"s\", jnklen); // Violate assumption of preamble length, end up with negative value, blow out stack\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2022-21668","Description":"Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).","Link":"https://www.cve.org/CVERecord?id=CVE-2022-21668"},{"Reference":"CVE-2010-3701","Description":"program uses ::alloca() for encoding messages, but large messages trigger segfault","Link":"https://www.cve.org/CVERecord?id=CVE-2010-3701"},{"Reference":"CVE-2008-1708","Description":"memory consumption and daemon exit by specifying a large value in a length field","Link":"https://www.cve.org/CVERecord?id=CVE-2008-1708"},{"Reference":"CVE-2008-0977","Description":"large value in a length field leads to memory consumption and crash when no more memory is available","Link":"https://www.cve.org/CVERecord?id=CVE-2008-0977"},{"Reference":"CVE-2006-3791","Description":"large key size in game program triggers crash when a resizing function cannot allocate enough memory","Link":"https://www.cve.org/CVERecord?id=CVE-2006-3791"},{"Reference":"CVE-2004-2589","Description":"large Content-Length HTTP header value triggers application crash in instant messaging application due to failure in memory allocation","Link":"https://www.cve.org/CVERecord?id=CVE-2004-2589"}],"TaxonomyMappings":[{"TaxonomyName":"WASC","EntryID":"35","EntryName":"SOAP Array Abuse"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"MEM35-C","EntryName":"Allocate sufficient memory for an object","MappingFit":"Imprecise"},{"TaxonomyName":"SEI CERT Perl Coding Standard","EntryID":"IDS32-PL","EntryName":"Validate any integer that is used as an array index","MappingFit":"Imprecise"},{"TaxonomyName":"OMG ASCSM","EntryID":"ASCSM-CWE-789"}],"References":[{"ExternalReferenceID":"REF-62","Section":"Chapter 10, \"Resource Limits\", Page 574","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-962","Section":"ASCSM-CWE-789","Authors":["Object Management Group (OMG)"],"Title":"Automated Source Code Security Measure (ASCSM)","PublicationYear":"2016","PublicationMonth":"01","URL":"http://www.omg.org/spec/ASCSM/1.0/"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"Notes":[{"Type":"Relationship","Note":"This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated."},{"Type":"Applicable Platform","Note":"\n\nUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\n"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2009-10-21","SubmissionVersion":"1.6","SubmissionReleaseDate":"2009-10-29"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-02-16","ModificationComment":"updated Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-03-29","ModificationComment":"updated Common_Consequences, Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Applicable_Platforms, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-06-25","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Alternate_Terms, Demonstrative_Examples, Description, Likelihood_of_Exploit, Name, Observed_Examples, Relationships, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Demonstrative_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes, Relationships"},{"Type":"Rename","PreviousEntryName":"Uncontrolled Memory Allocation","Date":"2020-12-10"}]}