{"ID":"1232","Name":"Improper Lock Behavior After Power State Transition","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"Register lock bit protection disables changes to system configuration once the bit is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes) causing the system configuration to be changeable.","ExtendedDescription":"\n\nDevices may allow device configuration controls which need to be programmed after device power reset via a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. This action is commonly implemented using a programmable lock bit, which, when set, disables writes to a protected set of registers or address regions.\n\n\nAfter a power state transition, the lock bit is set to unlocked. Some common weaknesses that can exist in such a protection scheme are that the lock gets cleared, the values of the protected registers get reset, or the lock become programmable.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"667","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Access Control"],"Impact":["Modify Memory"],"Likelihood":["High"]}],"PotentialMitigations":[{"Phase":["Architecture and Design","Implementation","Testing"],"Description":"\n\n  - Security Lock bit protections should be reviewed for behavior across supported power state transitions.\n\n  - Security lock programming flow and lock properties should be tested in pre-silicon and post-silicon testing including testing across power transitions.\n\n","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"Consider the memory configuration settings of a system that uses DDR3 DRAM memory. Protecting the DRAM memory configuration from modification by software is required to ensure that system memory access control protections cannot be bypassed. This can be done by using lock bit protection that locks all of the memory configuration registers. The memory configuration lock can be set by the BIOS during the boot process.\n\n\nIf such a system also supports a rapid power on mode like hibernate, the DRAM data must be saved to a disk before power is removed and restored back to the DRAM once the system powers back up and before the OS resumes operation after returning from hibernate."},{"BodyText":"To support the hibernate transition back to the operating state, the DRAM memory configuration must be reprogrammed even though it was locked previously. As the hibernate resume does a partial reboot, the memory configuration could be altered before the memory lock is set. Functionally the hibernate resume flow requires a bypass of the lock-based protection. The memory configuration must be securely stored and restored by trusted system firmware. Lock settings and system configuration must be restored to the same state it was in before the device entered into the hibernate mode."}]},{"Entries":[{"IntroText":"The example code below is taken from the register lock module (reglk_wrapper) of the Hack@DAC'21 buggy OpenPiton System-on-Chip (SoC). Upon powering on, most of the silicon registers are initially unlocked. However, critical resources must be configured and locked by setting the lock bit in a register.\n\n\nIn this module, a set of six memory-mapped I/O registers (reglk_mem) is defined and maintained to control the access control of registers inside different peripherals in the SoC [REF-1432]. Each bit represents a register's read/write ability or sets of registers inside a peripheral. Setting improper lock values after system power transition or system rest would make a temporary window for the attackers to read unauthorized data, e.g., secret keys from the crypto engine, and write illegitimate data to critical registers, e.g., framework data. Furthermore, improper register lock values can also result in DoS attacks. \n\n\nIn this faulty implementation, the locks are disabled, i.e., initialized to zero, at reset instead of setting them to their appropriate values [REF-1433]. Improperly initialized locks might allow unauthorized access to sensitive registers, compromising the system's security."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module reglk_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~jtag_unlock \u0026\u0026 ~rst_9))\n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j \u003c 6; j=j+1) begin\n```\nreglk_mem[j] \u003c= 'h0;** \n\t\t\t\t\t\t end\n\t\t\t\t\t end\n\t\t\t\t ..."},{"BodyText":"To resolve this issue, it is crucial to ensure that register locks are correctly initialized during the reset phase of the SoC. Correct initialization values should be established to maintain the system's integrity, security, and predictable behavior and allow for proper control of peripherals. The specifics of initializing register locks and their values depend on the SoC's design and the system's requirements; for example, access to all registers through the user privilege level should be locked at reset. To address the problem depicted in the bad code example [REF-1433], the default value for \"reglk_mem\" should be set to 32'hFFFFFFFF. This ensures that access to protected data is restricted during power state transition or after reset until the system state transition is complete and security procedures have properly configured the register locks."},{"Nature":"Good","Language":"Verilog","ExampleCode":"module reglk_wrapper #(\n ...\n\n```\n\t always @(posedge clk_i)\n\t\t begin\n\t\t\t if(~(rst_ni \u0026\u0026 ~jtag_unlock \u0026\u0026 ~rst_9))\n\t\t\t\t begin\n\t\t\t\t\t for (j=0; j \u003c 6; j=j+1) begin\n```\nreglk_mem[j] \u003c= 'hffffffff;** \n\t\t\t\t\t\t end\n\t\t\t\t\t end\n\t\t\t\t ..."}]}],"RelatedAttackPatterns":["166"],"References":[{"ExternalReferenceID":"REF-1432","Title":"reglk_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/65d0ffdab7426da4509c98d62e163bcce642f651/piton/design/chip/tile/ariane/src/reglk/reglk_wrapper.sv#L39C1-L39C1"},{"ExternalReferenceID":"REF-1433","Title":"Bad Code reglk_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/65d0ffdab7426da4509c98d62e163bcce642f651/piton/design/chip/tile/ariane/src/reglk/reglk_wrapper.sv#L78C1-L85C16"},{"ExternalReferenceID":"REF-1434","Title":"Good Code reglk_wrapper.sv","PublicationYear":"2021","URL":"https://github.com/HACK-EVENT/hackatdac21/blob/5e2031fd3854bcc0b2ca11d13442542dd5ea98e0/piton/design/chip/tile/ariane/src/reglk/reglk_wrapper.sv#L83"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-01-15","SubmissionVersion":"4.0","SubmissionReleaseDate":"2020-02-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Description, Modes_of_Introduction, Potential_Mitigations, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2024-07-16","ModificationComment":"updated Demonstrative_Examples, References","ModificationVersion":"4.15","ModificationReleaseDate":"2024-07-16"},{"Type":"Contribution","ContributionName":"Shaza Zeitouni, Mohamadreza Rostami, Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Rahul Kande, Chen Chen, Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-11-07","ContributionComment":"suggested demonstrative example","ContributionType":"Content"}]}