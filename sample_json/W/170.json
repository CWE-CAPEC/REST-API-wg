{"ID":"170","Name":"Improper Null Termination","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product does not terminate or incorrectly terminates a string or array with a null character or equivalent terminator.","ExtendedDescription":"Null termination errors frequently occur in two different ways. An off-by-one error could cause a null to be written out of bounds, leading to an overflow. Or, a program could use a strncpy() function call incorrectly, which prevents a null terminator from being added at all. Other scenarios are possible.","LikelihoodOfExploit":"Medium","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"707","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"120","ViewID":"1000"},{"Nature":"CanPrecede","CweID":"126","ViewID":"1000"},{"Nature":"CanAlsoBe","CweID":"147","ViewID":"1000"},{"Nature":"PeerOf","CweID":"464","ViewID":"1000"},{"Nature":"PeerOf","CweID":"463","ViewID":"1000"},{"Nature":"ChildOf","CweID":"20","ViewID":"700","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Resultant"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability"],"Impact":["Read Memory","Execute Unauthorized Code or Commands"],"Note":"The case of an omitted null character is the most dangerous of the possible issues. This will almost certainly result in information disclosure, and possibly a buffer overflow condition, which may be exploited to execute arbitrary code."},{"Scope":["Confidentiality","Integrity","Availability"],"Impact":["DoS: Crash, Exit, or Restart","Read Memory","DoS: Resource Consumption (CPU)","DoS: Resource Consumption (Memory)"],"Note":"If a null character is omitted from a string, then most string-copying functions will read data until they locate a null character, even outside of the intended boundaries of the string. This could: cause a crash due to a segmentation fault cause sensitive adjacent memory to be copied and sent to an outsider trigger a buffer overflow when the copy is being written to a fixed-size buffer."},{"Scope":["Integrity","Availability"],"Impact":["Modify Memory","DoS: Crash, Exit, or Restart"],"Note":"Misplaced null characters may result in any number of security problems. The biggest issue is a subset of buffer overflow, and write-what-where conditions, where data corruption occurs from the writing of a null character over valid data, or even instructions. A randomly placed null character may put the system into an undefined state, and therefore make it prone to crashing. A misplaced null character may corrupt other data in memory."},{"Scope":["Integrity","Confidentiality","Availability","Access Control","Other"],"Impact":["Alter Execution Logic","Execute Unauthorized Code or Commands"],"Note":"Should the null character corrupt the process flow, or affect a flag controlling access, it may lead to logical errors which allow for the execution of arbitrary code."}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Requirements"],"Description":"Use a language that is not susceptible to these issues. However, be careful of null byte interaction errors (CWE-626) with lower-level constructs that may be written in a language that is susceptible."},{"Phase":["Implementation"],"Description":"Ensure that all string functions used are understood fully as to how they append null characters. Also, be wary of off-by-one errors when appending nulls to the end of strings."},{"Phase":["Implementation"],"Description":"If performance constraints permit, special code can be added that validates null-termination of string buffers, this is a rather naive and error-prone solution."},{"Phase":["Implementation"],"Description":"Switch to bounded string manipulation functions. Inspect buffer lengths involved in the buffer overrun trace reported with the defect."},{"Phase":["Implementation"],"Description":"Add code that fills buffers with nulls (however, the length of buffers still needs to be inspected, to ensure that the non null-terminated string is not written at the physical end of the buffer)."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The following code reads from cfgfile and copies the input into inputbuf using strcpy(). The code mistakenly assumes that inputbuf will always contain a NULL terminator."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t#define MAXLEN 1024\n\t...\n\tchar *pathbuf[MAXLEN];\n\t...\n\tread(cfgfile,inputbuf,MAXLEN); //does not null terminate\n\tstrcpy(pathbuf,inputbuf); //requires null terminated input\n\t...\n```"},{"BodyText":"The code above will behave correctly if the data read from cfgfile is null terminated on disk as expected. But if an attacker is able to modify this input so that it does not contain the expected NULL character, the call to strcpy() will continue copying from memory until it encounters an arbitrary NULL character. This will likely overflow the destination buffer and, if the attacker can control the contents of memory immediately following inputbuf, can leave the application susceptible to a buffer overflow attack."}]},{"Entries":[{"IntroText":"In the following code, readlink() expands the name of a symbolic link stored in pathname and puts the absolute path into buf. The length of the resulting value is then calculated using strlen()."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar buf[MAXPATH];\n\t...\n\treadlink(pathname, buf, MAXPATH);\n\tint length = strlen(buf);\n\t...\n```"},{"BodyText":"The code above will not always behave correctly as readlink() does not append a NULL byte to buf. Readlink() will stop copying characters once the maximum size of buf has been reached to avoid overflowing the buffer, this will leave the value buf not NULL terminated. In this situation, strlen() will continue traversing memory until it encounters an arbitrary NULL character further on down the stack, resulting in a length value that is much larger than the size of string. Readlink() does return the number of bytes copied, but when this return value is the same as stated buf size (in this case MAXPATH), it is impossible to know whether the pathname is precisely that many bytes long, or whether readlink() has truncated the name to avoid overrunning the buffer. In testing, vulnerabilities like this one might not be caught because the unused contents of buf and the memory immediately following it may be NULL, thereby causing strlen() to appear as if it is behaving correctly."}]},{"Entries":[{"IntroText":"While the following example is not exploitable, it provides a good example of how nulls can be omitted or misplaced, even when \"safe\" functions are used:"},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t#include \u003cstdio.h\u003e\n\t#include \u003cstring.h\u003e\n\tint main() {\n\t\t\tchar longString[] = \"String signifying nothing\";\n\t\t\tchar shortString[16];\n\t\t\tstrncpy(shortString, longString, 16);\n\t\t\tprintf(\"The last character in shortString is: %c (%1$x)\\n\", shortString[15]);\n\t\t\treturn (0);\n\t}\n```"},{"BodyText":"The above code gives the following output: \"The last character in shortString is: n (6e)\". So, the shortString array does not end in a NULL character, even though the \"safe\" string function strncpy() was used. The reason is that strncpy() does not impliciitly add a NULL character at the end of the string when the source is equal in length or longer than the provided size."}]}],"ObservedExamples":[{"Reference":"CVE-2000-0312","Description":"Attacker does not null-terminate argv[] when invoking another program.","Link":"https://www.cve.org/CVERecord?id=CVE-2000-0312"},{"Reference":"CVE-2003-0777","Description":"Interrupted step causes resultant lack of null termination.","Link":"https://www.cve.org/CVERecord?id=CVE-2003-0777"},{"Reference":"CVE-2004-1072","Description":"Fault causes resultant lack of null termination, leading to buffer expansion.","Link":"https://www.cve.org/CVERecord?id=CVE-2004-1072"},{"Reference":"CVE-2001-1389","Description":"Multiple vulnerabilities related to improper null termination.","Link":"https://www.cve.org/CVERecord?id=CVE-2001-1389"},{"Reference":"CVE-2003-0143","Description":"Product does not null terminate a message buffer after snprintf-like call, leading to overflow.","Link":"https://www.cve.org/CVERecord?id=CVE-2003-0143"},{"Reference":"CVE-2009-2523","Description":"Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2523"}],"TaxonomyMappings":[{"TaxonomyName":"PLOVER","EntryName":"Improper Null Termination"},{"TaxonomyName":"7 Pernicious Kingdoms","EntryName":"String Termination Error"},{"TaxonomyName":"CLASP","EntryName":"Miscalculated null termination"},{"TaxonomyName":"OWASP Top Ten 2004","EntryID":"A9","EntryName":"Denial of Service","MappingFit":"CWE More Specific"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"POS30-C","EntryName":"Use the readlink() function properly","MappingFit":"CWE More Abstract"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"STR03-C","EntryName":"Do not inadvertently truncate a null-terminated byte string"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"STR32-C","EntryName":"Do not pass a non-null-terminated character sequence to a library function that expects a string","MappingFit":"Exact"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP11","EntryName":"Improper Null Termination"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"Notes":[{"Type":"Relationship","Note":"Factors: this is usually resultant from other weaknesses such as off-by-one errors, but it can be primary to boundary condition violations such as buffer overflows. In buffer overflows, it can act as an expander for assumed-immutable data."},{"Type":"Relationship","Note":"Overlaps missing input terminator."},{"Type":"Applicable Platform","Note":"\n\nConceptually, this does not just apply to the C language; any language or representation that involves a terminator could have this type of problem.\n"},{"Type":"Maintenance","Note":"As currently described, this entry is more like a category than a weakness."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"PLOVER","SubmissionDate":"2006-07-19"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Time_of_Introduction"},{"Type":"Modification","ModificationOrganization":"KDM Analytics","ModificationDate":"2008-08-01","ModificationComment":"added/updated white box definitions"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Applicable_Platforms, Causal_Nature, Common_Consequences, Description, Likelihood_of_Exploit, Maintenance_Notes, Relationships, Other_Notes, Relationship_Notes, Taxonomy_Mappings, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-03-10","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-05-27","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"KDM Analytics","ModificationDate":"2009-07-17","ModificationComment":"Improved the White_Box_Definition"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-07-27","ModificationComment":"updated Common_Consequences, Other_Notes, Potential_Mitigations, White_Box_Definitions"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-10-29","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-03-29","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-06-23","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Causal_Nature, Observed_Examples, Relationships, Taxonomy_Mappings, White_Box_Definitions"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2018-03-27","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}