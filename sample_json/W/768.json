{"ID":"768","Name":"Incorrect Short Circuit Evaluation","Abstraction":"Variant","Structure":"Simple","Status":"Incomplete","Description":"The product contains a conditional statement with multiple logical expressions in which one of the non-leading expressions may produce side effects. This may lead to an unexpected state in the program after the execution of the conditional, because short-circuiting logic may prevent the side effects from occurring.","ExtendedDescription":"\n\nUsage of short circuit evaluation, though well-defined in the C standard, may alter control flow in a way that introduces logic errors that are difficult to detect, possibly causing errors later during the product's execution. If an attacker can discover such an inconsistency, it may be exploitable to gain arbitrary control over a system.\n\n\nIf the first condition of an \"or\" statement is assumed to be true under normal circumstances, or if the first condition of an \"and\" statement is assumed to be false, then any subsequent conditional may contain its own logic errors that are not detected during code review or testing.\n\n\nFinally, the usage of short circuit evaluation may decrease the maintainability of the code.\n","LikelihoodOfExploit":"Low","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"691","ViewID":"1000","Ordinal":"Primary"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability"],"Note":"Widely varied consequences are possible if an attacker is aware of an unexpected state in the product after a conditional. It may lead to information exposure, a system crash, or even complete attacker control of the system."}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Minimizing the number of statements in a conditional that produce side effects will help to prevent the likelihood of short circuit evaluation to alter control flow in an unexpected way."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"The following function attempts to take a size value from a user and allocate an array of that size (we ignore bounds checking for simplicity). The function tries to initialize each spot with the value of its index, that is, A[len-1] = len - 1; A[len-2] = len - 2; ... A[1] = 1; A[0] = 0; However, since the programmer uses the prefix decrement operator, when the conditional is evaluated with i == 1, the decrement will result in a 0 value for the first part of the predicate, causing the second portion to be bypassed via short-circuit evaluation. This means we cannot be sure of what value will be in A[0] when we return the array to the user."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t#define PRIV_ADMIN 0\n\t#define PRIV_REGULAR 1\n\ttypedef struct{\n\t\tint privileges;\n\t\tint id;\n\t} user_t;\n\tuser_t *Add_Regular_Users(int num_users){\n\t\tuser_t* users = (user_t*)calloc(num_users, sizeof(user_t));\n\t\tint i = num_users;\n\t\twhile( --i \u0026\u0026 (users[i].privileges = PRIV_REGULAR) ){\n\t\t\tusers[i].id = i;\n\t\t}\n\t\treturn users;\n\t}\n\tint main(){\n\t\tuser_t* test;\n\t\tint i;\n\t\ttest = Add_Regular_Users(25);\n\t\tfor(i = 0; i \u003c 25; i++) printf(\"user %d has privilege level %d\\n\", test[i].id, test[i].privileges);\n\t}\n```"},{"BodyText":"When compiled and run, the above code will output a privilege level of 1, or PRIV_REGULAR for every user but the user with id 0 since the prefix increment operator used in the if statement will reach zero and short circuit before setting the 0th user's privilege level. Since we used calloc, this privilege will be set to 0, or PRIV_ADMIN."}]}],"TaxonomyMappings":[{"TaxonomyName":"CLASP","EntryName":"Failure to protect stored data from modification"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP1","EntryName":"Glitch in computation"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2009-03-03"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-09-27","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Likelihood_of_Exploit, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Common_Consequences, Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}