{"ID":"770","Name":"Allocation of Resources Without Limits or Throttling","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.","ExtendedDescription":"\n\nCode frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.\n","LikelihoodOfExploit":"High","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"400","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"665","ViewID":"1000"},{"Nature":"ChildOf","CweID":"400","ViewID":"1003","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Often"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase."},{"Phase":"Implementation"},{"Phase":"Operation"},{"Phase":"System Configuration"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (CPU)","DoS: Resource Consumption (Memory)","DoS: Resource Consumption (Other)"],"Note":"When allocating resources without limits, an attacker could prevent other systems, applications, or processes from accessing the same type of resource."}],"DetectionMethods":[{"DetectionMethodID":"DM-8","Method":"Manual Static Analysis","Description":"Manual static analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. If denial-of-service is not considered a significant risk, or if there is strong emphasis on consequences such as code execution, then manual analysis may not focus on this weakness at all."},{"Method":"Fuzzing","Description":"\n\nWhile fuzzing is typically geared toward finding low-level implementation bugs, it can inadvertently find uncontrolled resource allocation problems. This can occur when the fuzzer generates a large number of test cases but does not restart the targeted product in between test cases. If an individual test case produces a crash, but it does not do so reliably, then an inability to limit resource allocation may be the cause.\n\n\nWhen the allocation is directly affected by numeric inputs, then fuzzing may produce indications of this weakness.\n","Effectiveness":"Opportunistic"},{"Method":"Automated Dynamic Analysis","Description":"Certain automated dynamic analysis techniques may be effective in producing side effects of uncontrolled resource allocation problems, especially with resources such as processes, memory, and connections. The technique may involve generating a large number of requests to the product within a short time frame. Manual analysis is likely required to interpret the results."},{"Method":"Automated Static Analysis","Description":"\n\nSpecialized configuration or tuning may be required to train automated tools to recognize this weakness.\n\n\nAutomated static analysis typically has limited utility in recognizing unlimited allocation problems, except for the missing release of program-independent system resources such as files, sockets, and processes, or unchecked arguments to memory. For system resources, automated static analysis may be able to detect circumstances in which resources are not released after they have expired, or if too much of a resource is requested at once, as can occur with memory. Automated analysis of configuration files may be able to detect settings that do not specify a maximum value.\n\n\nAutomated static analysis tools will not be appropriate for detecting exhaustion of custom resources, such as an intended security policy in which a bulletin board user is only allowed to make a limited number of posts per day.\n"}],"PotentialMitigations":[{"Phase":["Requirements"],"Description":"Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits."},{"Phase":["Architecture and Design"],"Description":"Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410."},{"Phase":["Architecture and Design"],"Description":"Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold."},{"MitigationID":"MIT-5","Phase":["Implementation"],"Strategy":"Input Validation","Description":"\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n","EffectivenessNotes":"This will only be applicable to cases where user input can influence the size or frequency of resource allocations."},{"MitigationID":"MIT-15","Phase":["Architecture and Design"],"Description":"For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."},{"Phase":["Architecture and Design"],"Description":"\n\nMitigation of resource exhaustion attacks requires that the target system either:\n\n\n  - recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays\n\n  - uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed.\n\nThe first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question.\n\nThe second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.\n"},{"Phase":["Architecture and Design"],"Description":"Ensure that protocols have specific limits of scale placed on them."},{"MitigationID":"MIT-38.1","Phase":["Architecture and Design","Implementation"],"Description":"\n\nIf the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery.\n\n\nEnsure that all failures in resource allocation place the system into a safe posture.\n"},{"MitigationID":"MIT-47","Phase":["Operation","Architecture and Design"],"Strategy":"Resource Limitation","Description":"\n\nUse resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems.\n\n\nWhen the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users.\n\n\nEnsure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).\n"}],"DemonstrativeExamples":[{"ID":"DX-25","Entries":[{"IntroText":"This code allocates a socket and forks each time it receives a new connection."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tsock=socket(AF_INET, SOCK_STREAM, 0);\n\twhile (1) {\n\t\tnewsock=accept(sock, ...);\n\t\tprintf(\"A connection has been accepted\\n\");\n\t\tpid = fork();\n\t}\n```"},{"BodyText":"The program does not track how many connections have been made, and it does not limit the number of connections. Because forking is a relatively expensive operation, an attacker would be able to cause the system to run out of CPU, processes, or memory by making a large number of connections. Alternatively, an attacker could consume all available connections, preventing others from accessing the system remotely."}]},{"ID":"DX-50","Entries":[{"IntroText":"In the following example a server socket connection is used to accept a request to store data on the local file system using a specified filename. The method openSocketConnection establishes a server socket to accept requests from a client. When a client establishes a connection to this service the getNextMessage method is first used to retrieve from the socket the name of the file to store the data, the openFileToWrite method will validate the filename and open a file to write to on the local file system. The getNextMessage is then used within a while loop to continuously read data from the socket and output the data to the file until there is no longer any data from the socket."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint writeDataFromSocketToFile(char *host, int port)\n\t{\n\t\t\tchar filename[FILENAME_SIZE];\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tint socket = openSocketConnection(host, port);\n\t\t\tif (socket \u003c 0) {\n\t\t\t\tprintf(\"Unable to open socket connection\");\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t\t\tif (getNextMessage(socket, filename, FILENAME_SIZE) \u003e 0) {\n\t\t\t\t\tif (openFileToWrite(filename) \u003e 0) {\n\t\t\t\t\t\t\twhile (getNextMessage(socket, buffer, BUFFER_SIZE) \u003e 0){\n\t\t\t\t\t\t\t\tif (!(writeToFile(buffer) \u003e 0))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcloseFile();\n\t\t\t}\n\t\t\tcloseSocket(socket);\n\t}\n```"},{"BodyText":"This example creates a situation where data can be dumped to a file on the local file system without any limits on the size of the file. This could potentially exhaust file or disk resources and/or limit other clients' ability to access the service."}]},{"ID":"DX-51","Entries":[{"IntroText":"In the following example, the processMessage method receives a two dimensional character array containing the message to be processed. The two-dimensional character array contains the length of the message in the first character array and the message body in the second character array. The getMessageLength method retrieves the integer value of the length from the first character array. After validating that the message length is greater than zero, the body character array pointer points to the start of the second character array of the two-dimensional character array and memory is allocated for the new body character array."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n```\n/* process message accepts a two-dimensional character array of the form [length][body] containing the message to be processed */* \n\tint processMessage(char **message)\n\t{\n\t```\n\t\t\tchar *body;\n\t\t\tint length = getMessageLength(message[0]);\n\t\t\tif (length \u003e 0) {\n\t\t\t\tbody = \u0026message[1][0];\n\t\t\t\tprocessMessageBody(body);\n\t\t\t\treturn(SUCCESS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Unable to process message; invalid message length\");\n\t\t\t\treturn(FAIL);\n\t\t\t}\n\t}\n```"},{"BodyText":"This example creates a situation where the length of the body character array can be very large and will consume excessive memory, exhausting system resources. This can be avoided by restricting the length of the second character array with a maximum length check"},{"BodyText":"Also, consider changing the type from 'int' to 'unsigned int', so that you are always guaranteed that the number is positive. This might not be possible if the protocol specifically requires allowing negative values, or if you cannot control the return value from getMessageLength(), but it could simplify the check to ensure the input is positive, and eliminate other errors such as signed-to-unsigned conversion errors (CWE-195) that may occur elsewhere in the code."},{"Nature":"Good","Language":"C","ExampleCode":"```\n\tunsigned int length = getMessageLength(message[0]);\n\tif ((length \u003e 0) \u0026\u0026 (length \u003c MAX_LENGTH)) {...}\n```"}]},{"ID":"DX-52","Entries":[{"IntroText":"In the following example, a server object creates a server socket and accepts client connections to the socket. For every client connection to the socket a separate thread object is generated using the ClientSocketThread class that handles request made by the client through the socket."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tpublic void acceptConnections() {\n\t\t\ttry {\n\t\t\t\tServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n\t\t\t\tint counter = 0;\n\t\t\t\tboolean hasConnections = true;\n\t\t\t\twhile (hasConnections) {\n\t\t\t\t\tSocket client = serverSocket.accept();\n\t\t\t\t\tThread t = new Thread(new ClientSocketThread(client));\n\t\t\t\t\tt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\n\t\t\t\t\tt.start();\n\t\t\t\t}\n\t\t\t\tserverSocket.close();\n\t\t\t} catch (IOException ex) {...}\n\t}\n```"},{"BodyText":"In this example there is no limit to the number of client connections and client threads that are created. Allowing an unlimited number of client connections and threads could potentially overwhelm the system and system resources."},{"BodyText":"The server should limit the number of client connections and the client threads that are created. This can be easily done by creating a thread pool object that limits the number of threads that are generated."},{"Nature":"Good","Language":"Java","ExampleCode":"```\n\tpublic static final int SERVER_PORT = 4444;\n\tpublic static final int MAX_CONNECTIONS = 10;\n\t...\n\tpublic void acceptConnections() {\n\t\t\ttry {\n\t\t\t\tServerSocket serverSocket = new ServerSocket(SERVER_PORT);\n\t\t\t\tint counter = 0;\n\t\t\t\tboolean hasConnections = true;\n\t\t\t\twhile (hasConnections) {\n\t\t\t\t\thasConnections = checkForMoreConnections();\n\t\t\t\t\tSocket client = serverSocket.accept();\n\t\t\t\t\tThread t = new Thread(new ClientSocketThread(client));\n\t\t\t\t\tt.setName(client.getInetAddress().getHostName() + \":\" + counter++);\n\t\t\t\t\tExecutorService pool = Executors.newFixedThreadPool(MAX_CONNECTIONS);\n\t\t\t\t\tpool.execute(t);\n\t\t\t\t}\n\t\t\t\tserverSocket.close();\n\t\t\t} catch (IOException ex) {...}\n\t}\n```"}]},{"Entries":[{"IntroText":"An unnamed web site allowed a user to purchase tickets for an event. A menu option allowed the user to purchase up to 10 tickets, but the back end did not restrict the actual number of tickets that could be purchased."},{"Reference":"REF-667"}]},{"Entries":[{"IntroText":"Here the problem is that every time a connection is made, more memory is allocated. So if one just opened up more and more connections, eventually the machine would run out of memory."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tbar connection() {\n\t\tfoo = malloc(1024);\n\t\treturn foo;\n\t}\n\tendConnection(bar foo) {\n\t\tfree(foo);\n\t}\n\tint main() {\n\t\twhile(1) {\n\t\t\tfoo=connection();\n\t\t}\n\t\tendConnection(foo)\n\t}\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2022-21668","Description":"Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).","Link":"https://www.cve.org/CVERecord?id=CVE-2022-21668"},{"Reference":"CVE-2009-4017","Description":"Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..","Link":"https://www.cve.org/CVERecord?id=CVE-2009-4017"},{"Reference":"CVE-2009-2726","Description":"Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2726"},{"Reference":"CVE-2009-2540","Description":"Large integer value for a length property in an object causes a large amount of memory allocation.","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2540"},{"Reference":"CVE-2009-2054","Description":"Product allows exhaustion of file descriptors when processing a large number of TCP packets.","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2054"},{"Reference":"CVE-2008-5180","Description":"Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-5180"},{"Reference":"CVE-2008-1700","Description":"Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-1700"},{"Reference":"CVE-2005-4650","Description":"CMS does not restrict the number of searches that can occur simultaneously, leading to resource exhaustion.","Link":"https://www.cve.org/CVERecord?id=CVE-2005-4650"},{"Reference":"CVE-2020-15100","Description":"web application scanner attempts to read an excessively large file created by a user, causing process termination","Link":"https://www.cve.org/CVERecord?id=CVE-2020-15100"},{"Reference":"CVE-2020-7218","Description":"Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service","Link":"https://www.cve.org/CVERecord?id=CVE-2020-7218"}],"TaxonomyMappings":[{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"FIO04-J","EntryName":"Close resources when they are no longer needed"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"SER12-J","EntryName":"Avoid memory and resource leaks during serialization"},{"TaxonomyName":"The CERT Oracle Secure Coding Standard for Java (2011)","EntryID":"MSC05-J","EntryName":"Do not exhaust heap space"}],"RelatedAttackPatterns":["125","130","147","197","229","230","231","469","482","486","487","488","489","490","491","493","494","495","496","528"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"References":[{"ExternalReferenceID":"REF-386","Authors":["Joao Antunes","Nuno Ferreira Neves","Paulo Verissimo"],"Title":"Detection and Prediction of Resource-Exhaustion Vulnerabilities","Publication":"Proceedings of the IEEE International Symposium on Software Reliability Engineering (ISSRE)","PublicationYear":"2008","PublicationMonth":"11","URL":"http://homepages.di.fc.ul.pt/~nuno/PAPERS/ISSRE08.pdf"},{"ExternalReferenceID":"REF-387","Authors":["D.J. Bernstein"],"Title":"Resource exhaustion","URL":"http://cr.yp.to/docs/resources.html"},{"ExternalReferenceID":"REF-388","Authors":["Pascal Meunier"],"Title":"Resource exhaustion","Publication":"Secure Programming Educational Material","PublicationYear":"2004","URL":"http://homes.cerias.purdue.edu/~pmeunier/secprog/sanitized/class1/6.resource%20exhaustion.ppt"},{"ExternalReferenceID":"REF-7","Section":"Chapter 17, \"Protecting Against Denial of Service Attacks\" Page 517","Authors":["Michael Howard","David LeBlanc"],"Title":"Writing Secure Code","Edition":"2nd Edition","PublicationYear":"2002","PublicationMonth":"12","PublicationDay":"04","Publisher":"Microsoft Press","URL":"https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"},{"ExternalReferenceID":"REF-667","Authors":["Rafal Los"],"Title":"Real-Life Example of a 'Business Logic Defect' (Screen Shots!)","PublicationYear":"2011","URL":"http://h30501.www3.hp.com/t5/Following-the-White-Rabbit-A/Real-Life-Example-of-a-Business-Logic-Defect-Screen-Shots/ba-p/22581"},{"ExternalReferenceID":"REF-672","Authors":["Frank Kim"],"Title":"Top 25 Series - Rank 22 - Allocation of Resources Without Limits or Throttling","PublicationYear":"2010","PublicationMonth":"03","PublicationDay":"23","Publisher":"SANS Software Security Institute","URL":"https://web.archive.org/web/20170113055136/https://software-security.sans.org/blog/2010/03/23/top-25-series-rank-22-allocation-of-resources-without-limits-or-throttling/","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-62","Section":"Chapter 10, \"Resource Limits\", Page 574","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"}],"Notes":[{"Type":"Relationship","Note":"This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771)."},{"Type":"Theoretical","Note":"Vulnerability theory is largely about how behaviors and resources interact. \"Resource exhaustion\" can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2009-05-13"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-07-27","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-10-29","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-12-28","ModificationComment":"updated Applicable_Platforms, Demonstrative_Examples, Detection_Factors, Observed_Examples, References, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-02-16","ModificationComment":"updated Common_Consequences, Detection_Factors, Potential_Mitigations, References, Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-04-05","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-06-21","ModificationComment":"updated Common_Consequences, Potential_Mitigations, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-09-27","ModificationComment":"updated Demonstrative_Examples, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-03-29","ModificationComment":"updated Demonstrative_Examples, Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, References, Related_Attack_Patterns, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-10-30","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-02-18","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-06-23","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2015-12-07","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-05-03","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Demonstrative_Examples, Likelihood_of_Exploit, Modes_of_Introduction, Potential_Mitigations, References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2018-03-27","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Demonstrative_Examples, Description, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Potential_Mitigations, Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-06-25","ModificationComment":"updated Applicable_Platforms, Description, Maintenance_Notes, Potential_Mitigations, Relationship_Notes, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Observed_Examples, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description, Detection_Factors"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}