{"ID":"1221","Name":"Incorrect Register Defaults or Module Parameters","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"Hardware description language code incorrectly defines register defaults or hardware IP parameters to insecure values.","ExtendedDescription":"\n\nIntegrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. Hardware descriptive languages also support definition of parameter variables, which can be defined in code during instantiation of the hardware IP module. Such parameters are generally used to configure a specific instance of a hardware IP in the design.\n\n\nThe system security settings of a hardware design can be affected by incorrectly defined default values or IP parameters. The hardware IP would be in an insecure state at power reset, and this can be exposed or exploited by untrusted software running on the system. Both register defaults and parameters are hardcoded values, which cannot be changed using software or firmware patches but must be changed in hardware silicon. Thus, such security issues are considerably more difficult to address later in the lifecycle. Hardware designs can have a large number of such parameters and register defaults settings, and it is important to have design tool support to check these settings in an automated way and be able to identify which settings are security sensitive.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"665","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"Verilog","Prevalence":"Undetermined"},{"Type":"Language","Name":"VHDL","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation","Note":"Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases."}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability","Access Control"],"Impact":["Varies by Context"],"Note":"Degradation of system functionality, or loss of access control enforcement can occur."}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"During hardware design, all the system parameters and register defaults must be reviewed to identify security sensitive settings."},{"Phase":["Implementation"],"Description":"The default values of these security sensitive settings need to be defined as part of the design review phase."},{"Phase":["Testing"],"Description":"Testing phase should use automated tools to test that values are configured per design specifications."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"Consider example design module system verilog code shown below.register_example module is an example parameterized module that defines two parameters, REGISTER_WIDTH and REGISTER_DEFAULT. Register_example module defines a Secure_mode setting, which when set makes the register content read-only and not modifiable by software writes. register_top module instantiates two registers, Insecure_Device_ID_1 and Insecure_Device_ID_2. Generally, registers containing device identifier values are required to be read only to prevent any possibility of software modifying these values."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"// Parameterized Register module example \n // Secure_mode : REGISTER_DEFAULT[0] : When set to 1 register is read only and not writable// \n module register_example \n #( \n parameter REGISTER_WIDTH = 8, // Parameter defines width of register, default 8 bits \n parameter [REGISTER_WIDTH-1:0] REGISTER_DEFAULT = 2**REGISTER_WIDTH -2 // Default value of register computed from Width. Sets all bits to 1s except bit 0 (Secure _mode) \n ) \n ( \n input [REGISTER_WIDTH-1:0] Data_in, \n input Clk, \n input resetn, \n input write, \n output reg [REGISTER_WIDTH-1:0] Data_out \n ); \n\n reg Secure_mode; \n\n always @(posedge Clk or negedge resetn) \n\n```\n\t if (~resetn) \n\t begin \n\t\t Data_out \u003c= REGISTER_DEFAULT; // Register content set to Default at reset \n\t\t Secure_mode \u003c= REGISTER_DEFAULT[0]; // Register Secure_mode set at reset \n\t end \n\t else if (write \u0026 ~Secure_mode) \n\t begin \n\t\t Data_out \u003c= Data_in; \n\t end \n endmodule \n module register_top \n ( \n input Clk, \n input resetn, \n input write, \n input [31:0] Data_in, \n output reg [31:0] Secure_reg, \n output reg [31:0] Insecure_reg \n ); \n register_example #( \n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1224) // Incorrect Default value used bit 0 is 0. \n ) Insecure_Device_ID_1 ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n register_example #(\n\t .REGISTER_WIDTH (32) // Default not defined 2^32-2 value will be used as default. \n ) Insecure_Device_ID_2 ( \n\t .Data_in (Data_in), \n\t .Data_out (Insecure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n ); \n endmodule \n```"},{"BodyText":"These example instantiations show how, in a hardware design, it would be possible to instantiate the register module with insecure defaults and parameters."},{"BodyText":"In the example design, both registers will be software writable since Secure_mode is defined as zero."},{"Nature":"Good","Language":"Verilog","ExampleCode":"register_example #( \n\n```\n\t .REGISTER_WIDTH (32), \n\t .REGISTER_DEFAULT (1225) // Correct default value set, to enable Secure_mode \n ) Secure_Device_ID_example ( \n\t .Data_in (Data_in), \n\t .Data_out (Secure_reg), \n\t .Clk (Clk), \n\t .resetn (resetn), \n\t .write (write) \n );\n```"}]}],"RelatedAttackPatterns":["166"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2019-12-12"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}