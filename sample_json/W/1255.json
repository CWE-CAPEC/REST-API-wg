{"ID":"1255","Name":"Comparison Logic is Vulnerable to Power Side-Channel Attacks","Abstraction":"Variant","Structure":"Simple","Status":"Draft","Description":"A device's real time power consumption may be monitored during security token evaluation and the information gleaned may be used to determine the value of the reference token.","ExtendedDescription":"\n\nThe power consumed by a device may be instrumented and monitored in real time. If the algorithm for evaluating security tokens is not sufficiently robust, the power consumption may vary by token entry comparison against the reference value. Further, if retries are unlimited, the power difference between a \"good\" entry and a \"bad\" entry may be observed and used to determine whether each entry itself is correct thereby allowing unauthorized parties to calculate the reference value.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"1300","ViewID":"1000","Ordinal":"Primary"},{"Nature":"PeerOf","CweID":"1259","ViewID":"1194","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"The design of the algorithm itself may intrinsically allow the power side channel attack to be effective"},{"Phase":"Implementation","Note":"This weakness may be introduced during implementation despite a robust design that otherwise prevents exploitation"}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability","Access Control","Accountability","Authentication","Authorization","Non-Repudiation"],"Impact":["Modify Memory","Read Memory","Read Files or Directories","Modify Files or Directories","Execute Unauthorized Code or Commands","Gain Privileges or Assume Identity","Bypass Protection Mechanism","Read Application Data","Modify Application Data","Hide Activities"],"Note":"As compromising a security token may result in complete system control, the impacts are relatively universal"}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"The design phase must consider each check of a security token against a standard and the amount of power consumed during the check of a good token versus a bad token. The alternative is an all at once check where a retry counter is incremented PRIOR to the check."},{"Phase":["Architecture and Design"],"Description":"Another potential mitigation is to parallelize shifting of secret data (see example 2 below). Note that the wider the bus the more effective the result."},{"Phase":["Architecture and Design"],"Description":"An additional potential mitigation is to add random data to each crypto operation then subtract it out afterwards. This is highly effective but costly in performance, area, and power consumption. It also requires a random number generator."},{"Phase":["Implementation"],"Description":"If the architecture is unable to prevent the attack, using filtering components may reduce the ability to implement an attack, however, consideration must be given to the physical removal of the filter elements."},{"Phase":["Integration"],"Description":"During integration, avoid use of a single secret for an extended period (e.g. frequent key updates). This limits the amount of data compromised but at the cost of complexity of use."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"Consider an example hardware module that checks a user-provided password (or PIN) to grant access to a user. The user-provided password is compared against a stored value byte-by-byte."},{"Nature":"Bad","Language":"C","ExampleCode":"static nonvolatile password_tries = NUM_RETRIES;\n do\n\n```\n\t while (password_tries == 0) ; // Hang here if no more password tries\n\t password_ok = 0;\n\t for (i = 0; i \u003c NUM_PW_DIGITS; i++)\n\t\t if (GetPasswordByte() == stored_password([i])\n\t\t\t password_ok |= 1; // Power consumption is different here\n\t\t else\n\t\t\t password_ok |= 0; // than from here\n\t end\n\t if (password_ok \u003e 0)\n\t\t password_tries = NUM_RETRIES;\n\t\t break_to_Ok_to_proceed\n\t password_tries--;\n while (true)\n // Password OK\n```"},{"BodyText":"Since the algorithm uses a different number of 1's and 0's for password validation, a different amount of power is consumed for the good byte versus the bad byte comparison. Using this information, an attacker may be able to guess the correct password for that byte-by-byte iteration with several repeated attempts by stopping the password evaluation before it completes."},{"BodyText":"Among various options for mitigating the string comparison is obscuring the power consumption by having opposing bit flips during bit operations. Note that in this example, the initial change of the bit values could still provide power indication depending upon the hardware itself. This possibility needs to be measured for verification."},{"Nature":"Good","Language":"C","ExampleCode":"static nonvolatile password_tries = NUM_RETRIES;\n do\n\n```\n\t while (password_tries == 0) ; // Hang here if no more password tries\n\t password_tries--; // Put retry code here to catch partial retries\n\t password_ok = 0;\n\t for (i = 0; i \u003c NUM_PW_DIGITS; i++)\n\t\t if (GetPasswordByte() == stored_password([i])\n\t\t\t password_ok |= 0x10; // Power consumption here\n\t\t else\n\t\t\t password_ok |= 0x01; // is now the same here\n\t end\n\t if ((password_ok \u0026 1) == 0)\n\t\t password_tries = NUM_RETRIES;\n\t\t break_to_Ok_to_proceed\n while (true)\n // Password OK\n```"},{"BodyText":"Since the algorithm uses a different number of 1's and 0's for password validation, a different amount of power is consumed for the good byte versus the bad byte comparison. Using this information, an attacker may be able to guess the correct password for that byte-by-byte iteration with several repeated attempts by stopping the password evaluation before it completes."},{"BodyText":"An alternative to the previous example is simply comparing the whole password simultaneously."},{"Nature":"Good","Language":"C","ExampleCode":"static nonvolatile password_tries = NUM_RETRIES;\n do\n\n```\n\t while (password_tries == 0) ; // Hang here if no more password tries\n\t password_tries--; // Put retry code here to catch partial retries\n\t for (i = 0; i \u003c NUM_PW_DIGITS; i++)\n\t\t stored_password([i]) = GetPasswordByte();\n\t end\n\t if (stored_password == saved_password)\n\t\t password_tries = NUM_RETRIES;\n\t\t break_to_Ok_to_proceed\n while (true)\n // Password OK\n```"},{"BodyText":"Since comparison is done atomically, there is no indication which bytes fail forcing the attacker to brute force the whole password at once. Note that other mitigations may exist such as masking - causing a large current draw to mask individual bit flips."}]},{"Entries":[{"IntroText":"This code demonstrates the transfer of a secret key using Serial-In/Serial-Out shift. It's easy to extract the secret using simple power analysis as each shift gives data on a single bit of the key."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module siso(clk,rst,a,q);\n\n```\n\t input a;\n\t input clk,rst;\n\t output q;\n\t reg q;\n\t always@(posedge clk,posedge rst)\n\t begin\n\t\t if(rst==1'b1)\n\t\t\t q\u003c1'b0;\n\t\t else\n\t\t\t q\u003ca;\n\t end\n endmodule\n```"},{"BodyText":"This code demonstrates the transfer of a secret key using a Parallel-In/Parallel-Out shift. In a parallel shift, data confounded by multiple bits of the key, not just one."},{"Nature":"Good","Language":"Verilog","ExampleCode":"module pipo(clk,rst,a,q);\n\n```\n\t input clk,rst;\n\t input[3:0]a;\n\t output[3:0]q;\n\t reg[3:0]q;\n\t always@(posedge clk,posedge rst)\n\t begin\n\t\t if (rst==1'b1)\n\t\t\t q\u003c4'b0000;\n\t\t else\n\t\t\t q\u003ca;\n\t end\n endmodule\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2020-12788","Description":"CMAC verification vulnerable to timing and power attacks.","Link":"https://www.cve.org/CVERecord?id=CVE-2020-12788"}],"FunctionalAreas":["Power"],"RelatedAttackPatterns":["189"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"References":[{"ExternalReferenceID":"REF-1184","Authors":["Wikipedia"],"Title":"Power Analysis","URL":"https://en.wikipedia.org/wiki/Power_analysis"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2020-05-29"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Functional_Areas, Maintenance_Notes, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Demonstrative_Examples, Modes_of_Introduction, Observed_Examples, Potential_Mitigations, References, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Maintenance_Notes, References, Relationships, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-06-28","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Contribution","ContributionName":"Accellera IP Security Assurance (IPSA) Working Group","ContributionOrganization":"Accellera Systems Initiative","ContributionDate":"2020-09-09","ContributionComment":"Submitted new material that could be added to already-existing entry CWE-1255. Added new Potential Mitigations, a new example, an observed example, and an additional reference.\n        ","ContributionType":"Content"}]}