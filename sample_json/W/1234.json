{"ID":"1234","Name":"Hardware Internal or Debug Modes Allow Override of Locks","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"System configuration protection may be bypassed during debug mode.","ExtendedDescription":"\n\nDevice configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set, disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, modification of the lock protection may be allowed allowing access and modification of configuration information.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"667","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Access Control"],"Impact":["Bypass Protection Mechanism"],"Likelihood":["High"],"Note":"Bypass of lock bit allows access and modification of system configuration even when the lock bit is set."}],"PotentialMitigations":[{"Phase":["Architecture and Design","Implementation","Testing"],"Description":"\n\n  - Security Lock bit protections should be reviewed for any bypass/override modes supported.\n\n  - Any supported override modes either should be removed or protected using authenticated debug modes.\n\n  - Security lock programming flow and lock properties should be tested in pre-silicon and post-silicon testing.\n\n","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"For example, consider the example Locked_override_register example. This register module supports a lock mode that blocks any writes after lock is set to 1. \n However, it also allows override of the lock protection when scan_mode or debug_unlocked modes are active."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"module Locked_register_example\n (\n input [15:0] Data_in,\n input Clk,\n input resetn,\n input write,\n input Lock,\n input scan_mode,\n input debug_unlocked,\n output reg [15:0] Data_out\n );\n\n reg lock_status;\n\n always @(posedge Clk or negedge resetn)\n\n```\n\t if (~resetn) // Register is reset resetn\n\t begin\n\t\t lock_status \u003c= 1'b0;\n\t end\n\t else if (Lock)\n\t begin\n\t\t lock_status \u003c= 1'b1;\n\t end\n\t else if (~Lock)\n\t begin\n\t\t lock_status \u003c= lock_status\n\t end\n always @(posedge Clk or negedge resetn)\n\t if (~resetn) // Register is reset resetn\n\t begin\n\t\t Data_out \u003c= 16'h0000;\n\t end\n\t else if (write \u0026 (~lock_status | scan_mode | debug_unlocked) ) // Register protected by Lock bit input, overrides supported for scan_mode \u0026 debug_unlocked\n\t begin\n\t\t Data_out \u003c= Data_in;\n\t end\n\t else if (~write)\n\t begin\n\t\t Data_out \u003c= Data_out;\n\t end\n endmodule\n```"},{"BodyText":"If either the scan_mode or the debug_unlocked modes can be triggered by software, then the lock protection may be bypassed."},{"Nature":"Good","ExampleCode":"Either remove the debug and scan mode overrides or protect enabling of these modes so that only trusted and authorized users may enable these modes."}]}],"RelatedAttackPatterns":["176"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-01-15"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Description, Modes_of_Introduction, Potential_Mitigations, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}