{"ID":"125","Name":"Out-of-bounds Read","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The product reads data past the end, or before the beginning, of the intended buffer.","ExtendedDescription":"Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string. The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow. The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent read operation then produces undefined or unexpected results.","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"119","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1003","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1305","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1340","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"},{"Type":"Technology","Class":"ICS/OT","Prevalence":"Often"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory"]},{"Scope":["Confidentiality"],"Impact":["Bypass Protection Mechanism"],"Note":"By reading out-of-bounds memory, an attacker might be able to get secret values, such as memory addresses, which can be bypass protection mechanisms such as ASLR in order to improve the reliability and likelihood of exploiting a separate weakness to achieve code execution instead of just denial of service."}],"DetectionMethods":[{"DetectionMethodID":"DM-13","Method":"Fuzzing","Description":"Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.","Effectiveness":"High"},{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"MitigationID":"MIT-5","Phase":["Implementation"],"Strategy":"Input Validation","Description":"\n\nAssume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.\n\n\nWhen performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"\n\n\nDo not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.\n\n\nTo reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.\n"},{"Phase":["Architecture and Design"],"Strategy":"Language Selection","Description":"Use a language that provides appropriate memory abstractions."}],"DemonstrativeExamples":[{"ID":"DX-100","Entries":[{"IntroText":"In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method"},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint getValueFromArray(int *array, int len, int index) {\n\t\t\tint value;\n```\n// check that the array index is less than the maximum* \n\t\t\t\n\t\t\t\n\t\t\t *// length of the array* \n\t\t\tif (index \u003c len) {\n\t\t\t```\n```\n// get the value at the specified index of the array* \n\t\t\t\t\tvalue = array[index];}\n\t\t\t\n\t\t\t *// if array index is invalid then output error message* \n\t\t\t\n\t\t\t\n\t\t\t *// and return value indicating error* \n\t\t\telse {\n\t\t\t```\n\t\t\t\tprintf(\"Value is: %d\\n\", array[index]);\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\treturn value;\n\t}\n```"},{"BodyText":"However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."},{"Nature":"Good","Language":"C","ExampleCode":"```\n\t...\n```\n// check that the array index is within the correct* \n\t\n\t\n\t *// range of values for the array* \n\tif (index \u003e= 0 \u0026\u0026 index \u003c len) {\n\t\n\t..."}]}],"ObservedExamples":[{"Reference":"CVE-2020-11899","Description":"Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.","Link":"https://www.cve.org/CVERecord?id=CVE-2020-11899"},{"Reference":"CVE-2014-0160","Description":"Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.","Link":"https://www.cve.org/CVERecord?id=CVE-2014-0160"},{"Reference":"CVE-2018-10887","Description":"Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125)","Link":"https://www.cve.org/CVERecord?id=CVE-2018-10887"},{"Reference":"CVE-2009-2523","Description":"Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2523"},{"Reference":"CVE-2018-16069","Description":"Chain: series of floating-point precision errors (CWE-1339) in a web browser rendering engine causes out-of-bounds read (CWE-125), giving access to cross-origin data","Link":"https://www.cve.org/CVERecord?id=CVE-2018-16069"},{"Reference":"CVE-2004-0112","Description":"out-of-bounds read due to improper length check","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0112"},{"Reference":"CVE-2004-0183","Description":"packet with large number of specified elements cause out-of-bounds read.","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0183"},{"Reference":"CVE-2004-0221","Description":"packet with large number of specified elements cause out-of-bounds read.","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0221"},{"Reference":"CVE-2004-0184","Description":"out-of-bounds read, resultant from integer underflow","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0184"},{"Reference":"CVE-2004-1940","Description":"large length value causes out-of-bounds read","Link":"https://www.cve.org/CVERecord?id=CVE-2004-1940"},{"Reference":"CVE-2004-0421","Description":"malformed image causes out-of-bounds read","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0421"},{"Reference":"CVE-2008-4113","Description":"OS kernel trusts userland-supplied length value, allowing reading of sensitive information","Link":"https://www.cve.org/CVERecord?id=CVE-2008-4113"}],"TaxonomyMappings":[{"TaxonomyName":"PLOVER","EntryName":"Out-of-bounds Read"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"ARR30-C","EntryName":"Do not form or use out-of-bounds pointers or array subscripts","MappingFit":"Imprecise"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"ARR38-C","EntryName":"Guarantee that library functions do not form invalid pointers","MappingFit":"Imprecise"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"EXP39-C","EntryName":"Do not access a variable through a pointer of an incompatible type","MappingFit":"Imprecise"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"STR31-C","EntryName":"Guarantee that storage for strings has sufficient space for character data and the null terminator","MappingFit":"Imprecise"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"STR32-C","EntryName":"Do not pass a non-null-terminated character sequence to a library function that expects a string","MappingFit":"CWE More Abstract"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP8","EntryName":"Faulty Buffer Access"}],"RelatedAttackPatterns":["540"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"References":[{"ExternalReferenceID":"REF-1034","Authors":["Raoul Strackx","Yves Younan","Pieter Philippaerts","Frank Piessens","Sven Lachmund","Thomas Walter"],"Title":"Breaking the memory secrecy assumption","PublicationYear":"2009","PublicationMonth":"03","PublicationDay":"31","Publisher":"ACM","URL":"https://dl.acm.org/doi/10.1145/1519144.1519145","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-1035","Authors":["Fermin J. Serna"],"Title":"The info leak era on software exploitation","PublicationYear":"2012","PublicationMonth":"07","PublicationDay":"25","URL":"https://media.blackhat.com/bh-us-12/Briefings/Serna/BH_US_12_Serna_Leak_Era_Slides.pdf"},{"ExternalReferenceID":"REF-44","Section":"\"Sin 5: Buffer Overruns.\" Page 89","Authors":["Michael Howard","David LeBlanc","John Viega"],"Title":"24 Deadly Sins of Software Security","Publication":"McGraw-Hill","PublicationYear":"2010"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"PLOVER","SubmissionDate":"2006-07-19"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Applicable_Platforms, Relationships, Taxonomy_Mappings, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-10-29","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-09-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-06-23","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2015-12-07","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Causal_Nature, Observed_Examples, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2018-03-27","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Description, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-09-19","ModificationComment":"updated Common_Consequences, Observed_Examples, Potential_Mitigations, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Potential_Mitigations, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-06-25","ModificationComment":"updated Observed_Examples, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Observed_Examples, Potential_Mitigations, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Observed_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Research_Gaps"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-06-28","ModificationComment":"updated Observed_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Applicable_Platforms, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes, Relationships"}]}