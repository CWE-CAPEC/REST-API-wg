{"ID":"839","Name":"Numeric Range Comparison Without Minimum Check","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.","ExtendedDescription":"\n\nSome products use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption.\n\n\nThe use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"1023","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"195","ViewID":"1000"},{"Nature":"CanPrecede","CweID":"682","ViewID":"1000"},{"Nature":"CanPrecede","CweID":"119","ViewID":"1000"},{"Nature":"CanPrecede","CweID":"124","ViewID":"1000"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Often"},{"Type":"Language","Name":"C++","Prevalence":"Often"}],"AlternateTerms":[{"Term":"Signed comparison","Description":"The \"signed comparison\" term is often used to describe when the product uses a signed variable and checks it to ensure that it is less than a maximum value (typically a maximum buffer size), but does not verify that it is greater than 0."}],"CommonConsequences":[{"Scope":["Integrity","Confidentiality","Availability"],"Impact":["Modify Application Data","Execute Unauthorized Code or Commands"],"Note":"An attacker could modify the structure of the message or data being sent to the downstream component, possibly injecting commands."},{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (Other)"],"Note":"in some contexts, a negative value could lead to resource consumption."},{"Scope":["Confidentiality","Integrity"],"Impact":["Modify Memory","Read Memory"],"Note":"If a negative value is used to access memory, buffers, or other indexable structures, it could access memory outside the bounds of the buffer."}],"PotentialMitigations":[{"Phase":["Implementation"],"Strategy":"Enforcement by Conversion","Description":"If the number to be used is always expected to be positive, change the variable type from signed to unsigned or size_t."},{"Phase":["Implementation"],"Strategy":"Input Validation","Description":"If the number to be used could have a negative value based on the specification (thus requiring a signed value), but the number should only be positive to preserve code correctness, then include a check to ensure that the value is positive."}],"DemonstrativeExamples":[{"ID":"DX-21","Entries":[{"IntroText":"The following code is intended to read an incoming packet from a socket and extract one or more headers."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tDataPacket *packet;\n\tint numHeaders;\n\tPacketHeader *headers;\n\tsock=AcceptSocketConnection();\n\tReadPacket(packet, sock);\n\tnumHeaders =packet-\u003eheaders;\n\tif (numHeaders \u003e 100) {\n\t\tExitError(\"too many headers!\");\n\t}\n\theaders = malloc(numHeaders * sizeof(PacketHeader);\n\tParsePacketHeaders(packet, headers);\n```"},{"BodyText":"The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."}]},{"ID":"DX-23","Entries":[{"IntroText":"The following code reads a maximum size and performs a sanity check on that size. It then performs a strncpy, assuming it will not exceed the boundaries of the array. While the use of \"short s\" is forced in this particular example, short int's are frequently used within real-world code, such as code that processes structured data."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint GetUntrustedInt () {\n\t\treturn(0x0000FFFF);\n\t}\n\tvoid main (int argc, char **argv) {\n\t\t\tchar path[256];\n\t\t\tchar *input;\n\t\t\tint i;\n\t\t\tshort s;\n\t\t\tunsigned int sz;\n\t\t\ti = GetUntrustedInt();\n\t\t\ts = i;\n\t\t\t/* s is -1 so it passes the safety check - CWE-697 */\n\t\t\tif (s \u003e 256) {\n\t\t\t\tDiePainfully(\"go away!\\n\");\n\t\t\t}\n\t\t\t/* s is sign-extended and saved in sz */\n\t\t\tsz = s;\n\t\t\t/* output: i=65535, s=-1, sz=4294967295 - your mileage may vary */\n\t\t\tprintf(\"i=%d, s=%d, sz=%u\\n\", i, s, sz);\n\t\t\tinput = GetUserInput(\"Enter pathname:\");\n\t\t\t/* strncpy interprets s as unsigned int, so it's treated as MAX_INT\n\t\t\t(CWE-195), enabling buffer overflow (CWE-119) */\n\t\t\tstrncpy(path, input, s);\n\t\t\tpath[255] = '\\0'; /* don't want CWE-170 */\n\t\t\tprintf(\"Path is: %s\\n\", path);\n\t}\n```"},{"BodyText":"This code first exhibits an example of CWE-839, allowing \"s\" to be a negative number. When the negative short \"s\" is converted to an unsigned integer, it becomes an extremely large positive integer. When this converted integer is used by strncpy() it will lead to a buffer overflow (CWE-119)."}]},{"ID":"DX-100","Entries":[{"IntroText":"In the following code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method"},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint getValueFromArray(int *array, int len, int index) {\n\t\t\tint value;\n```\n// check that the array index is less than the maximum* \n\t\t\t\n\t\t\t\n\t\t\t *// length of the array* \n\t\t\tif (index \u003c len) {\n\t\t\t```\n```\n// get the value at the specified index of the array* \n\t\t\t\t\tvalue = array[index];}\n\t\t\t\n\t\t\t *// if array index is invalid then output error message* \n\t\t\t\n\t\t\t\n\t\t\t *// and return value indicating error* \n\t\t\telse {\n\t\t\t```\n\t\t\t\tprintf(\"Value is: %d\\n\", array[index]);\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\treturn value;\n\t}\n```"},{"BodyText":"However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129). In this example the if statement should be modified to include a minimum range check, as shown below."},{"Nature":"Good","Language":"C","ExampleCode":"```\n\t...\n```\n// check that the array index is within the correct* \n\t\n\t\n\t *// range of values for the array* \n\tif (index \u003e= 0 \u0026\u0026 index \u003c len) {\n\t\n\t..."}]},{"Entries":[{"IntroText":"The following code shows a simple BankAccount class with deposit and withdraw methods."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tpublic class BankAccount {\n\t\t\tpublic final int MAXIMUM_WITHDRAWAL_LIMIT = 350;\n```\n// variable for bank account balance* \n\t\t\tprivate double accountBalance;\n\t\t\t\n\t\t\t\n\t\t\t *// constructor for BankAccount* \n\t\t\tpublic BankAccount() {\n\t\t\t```\n\t\t\t\taccountBalance = 0;\n\t\t\t}\n```\n// method to deposit amount into BankAccount* \n\t\t\tpublic void deposit(double depositAmount) {...}\n\t\t\t\n\t\t\t\n\t\t\t *// method to withdraw amount from BankAccount* \n\t\t\tpublic void withdraw(double withdrawAmount) {\n\t\t\t```\n\t\t\t\t\tif (withdrawAmount \u003c MAXIMUM_WITHDRAWAL_LIMIT) {\n\t\t\t\t\t\t\tdouble newBalance = accountBalance - withdrawAmount;\n\t\t\t\t\t\t\taccountBalance = newBalance;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.err.println(\"Withdrawal amount exceeds the maximum limit allowed, please try again...\");\n\t\t\t\t\t\t...\n\t\t\t\t\t}\n\t\t\t}\n```\n// other methods for accessing the BankAccount object* \n\t\t\t...}"},{"BodyText":"The withdraw method includes a check to ensure that the withdrawal amount does not exceed the maximum limit allowed, however the method does not check to ensure that the withdrawal amount is greater than a minimum value (CWE-129). Performing a range check on a value that does not include a minimum check can have significant security implications, in this case not including a minimum range check can allow a negative value to be used which would cause the financial application using this class to deposit money into the user account rather than withdrawing. In this example the if statement should the modified to include a minimum range check, as shown below."},{"Nature":"Good","Language":"Java","ExampleCode":"```\n\tpublic class BankAccount {\n\t\t\tpublic final int MINIMUM_WITHDRAWAL_LIMIT = 0;\n\t\t\tpublic final int MAXIMUM_WITHDRAWAL_LIMIT = 350;\n\t\t\t...\n```\n// method to withdraw amount from BankAccount* \n\t\t\tpublic void withdraw(double withdrawAmount) {\n\t\t\t```\n\t\t\t\t\tif (withdrawAmount \u003c MAXIMUM_WITHDRAWAL_LIMIT \u0026\u0026\n\t\t\t\t\twithdrawAmount \u003e MINIMUM_WITHDRAWAL_LIMIT) {\n\t\t\t\t\t\t\t...\n```"},{"BodyText":"Note that this example does not protect against concurrent access to the BankAccount balance variable, see CWE-413 and CWE-362."},{"BodyText":"While it is out of scope for this example, note that the use of doubles or floats in financial calculations may be subject to certain kinds of attacks where attackers use rounding errors to steal money."}]}],"ObservedExamples":[{"Reference":"CVE-2010-1866","Description":"Chain: integer overflow causes a negative signed value, which later bypasses a maximum-only check, leading to heap-based buffer overflow.","Link":"https://www.cve.org/CVERecord?id=CVE-2010-1866"},{"Reference":"CVE-2009-1099","Description":"Chain: 16-bit counter can be interpreted as a negative value, compared to a 32-bit maximum value, leading to buffer under-write.","Link":"https://www.cve.org/CVERecord?id=CVE-2009-1099"},{"Reference":"CVE-2011-0521","Description":"Chain: kernel's lack of a check for a negative value leads to memory corruption.","Link":"https://www.cve.org/CVERecord?id=CVE-2011-0521"},{"Reference":"CVE-2010-3704","Description":"Chain: parser uses atoi() but does not check for a negative value, which can happen on some platforms, leading to buffer under-write.","Link":"https://www.cve.org/CVERecord?id=CVE-2010-3704"},{"Reference":"CVE-2010-2530","Description":"Chain: Negative value stored in an int bypasses a size check and causes allocation of large amounts of memory.","Link":"https://www.cve.org/CVERecord?id=CVE-2010-2530"},{"Reference":"CVE-2009-3080","Description":"Chain: negative offset value to IOCTL bypasses check for maximum index, then used as an array index for buffer under-read.","Link":"https://www.cve.org/CVERecord?id=CVE-2009-3080"},{"Reference":"CVE-2008-6393","Description":"chain: file transfer client performs signed comparison, leading to integer overflow and heap-based buffer overflow.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-6393"},{"Reference":"CVE-2008-4558","Description":"chain: negative ID in media player bypasses check for maximum index, then used as an array index for buffer under-read.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-4558"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"References":[{"ExternalReferenceID":"REF-62","Section":"Chapter 6, \"Type Conversion Vulnerabilities\" Page 246","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-62","Section":"Chapter 6, \"Comparisons\", Page 265","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2011-03-24"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-02-18","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2018-03-27","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Alternate_Terms, Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}