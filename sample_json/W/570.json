{"ID":"570","Name":"Expression is Always False","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The product contains an expression that will always evaluate to false.","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"710","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"561","ViewID":"1000"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Other"],"Impact":["Quality Degradation","Varies by Context"]}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Testing"],"Description":"Use Static Analysis tools to spot such conditions."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"In the following Java example the updateUserAccountOrder() method used within an e-business product ordering/inventory application will validate the product number that was ordered and the user account number. If they are valid, the method will update the product inventory, the user account, and the user order appropriately."},{"Nature":"Bad","Language":"Java","ExampleCode":"```\n\tpublic void updateUserAccountOrder(String productNumber, String accountNumber) {\n\t\t\tboolean isValidProduct = false;\n\t\t\tboolean isValidAccount = false;\n\t\t\tif (validProductNumber(productNumber)) {\n\t\t\t\tisValidProduct = true;\n\t\t\t\tupdateInventory(productNumber);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validAccountNumber(accountNumber)) {\n\t\t\t\tisValidProduct = true;\n\t\t\t\tupdateAccount(accountNumber, productNumber);\n\t\t\t}\n\t\t\tif (isValidProduct \u0026\u0026 isValidAccount) {\n\t\t\t\tupdateAccountOrder(accountNumber, productNumber);\n\t\t\t}\n\t}\n```"},{"BodyText":"However, the method never sets the isValidAccount variable after initializing it to false so the isValidProduct is mistakenly used twice. The result is that the expression \"isValidProduct \u0026\u0026 isValidAccount\" will always evaluate to false, so the updateAccountOrder() method will never be invoked. This will create serious problems with the product ordering application since the user account and inventory databases will be updated but the order will not be updated."},{"BodyText":"This can be easily corrected by updating the appropriate variable."},{"Nature":"Good","ExampleCode":"```\n\t...\n\tif (validAccountNumber(accountNumber)) {\n\t\tisValidAccount = true;\n\t\tupdateAccount(accountNumber, productNumber);\n\t}\n\t...\n```"}]},{"Entries":[{"IntroText":"In the following example, the hasReadWriteAccess method uses bit masks and bit operators to determine if a user has read and write privileges for a particular process. The variable mask is defined as a bit mask from the BIT_READ and BIT_WRITE constants that have been defined. The variable mask is used within the predicate of the hasReadWriteAccess method to determine if the userMask input parameter has the read and write bits set."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\t#define BIT_READ 0x0001 // 00000001\n\t#define BIT_WRITE 0x0010 // 00010000\n\tunsigned int mask = BIT_READ \u0026 BIT_WRITE; /* intended to use \"|\" */\n\t// using \"\u0026\", mask = 00000000\n\t// using \"|\", mask = 00010001\n\t// determine if user has read and write access\n\tint hasReadWriteAccess(unsigned int userMask) {\n\t\t\t// if the userMask has read and write bits set\n\t\t\t// then return 1 (true)\n\t\t\tif (userMask \u0026 mask) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// otherwise return 0 (false)\n\t\t\treturn 0;\n\t}\n```"},{"BodyText":"However the bit operator used to initialize the mask variable is the AND operator rather than the intended OR operator (CWE-480), this resulted in the variable mask being set to 0. As a result, the if statement will always evaluate to false and never get executed."},{"BodyText":"The use of bit masks, bit operators and bitwise operations on variables can be difficult. If possible, try to use frameworks or libraries that provide appropriate functionality and abstract the implementation."}]},{"Entries":[{"IntroText":"In the following example, the updateInventory method used within an e-business inventory application will update the inventory for a particular product. This method includes an if statement with an expression that will always evaluate to false. This is a common practice in C/C++ to introduce debugging statements quickly by simply changing the expression to evaluate to true and then removing those debugging statements by changing expression to evaluate to false. This is also a common practice for disabling features no longer needed."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint updateInventory(char* productNumber, int numberOfItems) {\n\t\t\tint initCount = getProductCount(productNumber);\n\t\t\tint updatedCount = initCount + numberOfItems;\n\t\t\tint updated = updateProductCount(updatedCount);\n\t\t\t// if statement for debugging purposes only\n\t\t\tif (1 == 0) {\n\t\t\t\t\tchar productName[128];\n\t\t\t\t\tproductName = getProductName(productNumber);\n\t\t\t\t\tprintf(\"product %s initially has %d items in inventory \\n\", productName, initCount);\n\t\t\t\t\tprintf(\"adding %d items to inventory for %s \\n\", numberOfItems, productName);\n\t\t\t\t\tif (updated == 0) {\n\t\t\t\t\t\tprintf(\"Inventory updated for product %s to %d items \\n\", productName, updatedCount);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tprintf(\"Inventory not updated for product: %s \\n\", productName);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn updated;\n\t}\n```"},{"BodyText":"Using this practice for introducing debugging statements or disabling features creates dead code that can cause problems during code maintenance and potentially introduce vulnerabilities. To avoid using expressions that evaluate to false for debugging purposes a logging API or debugging API should be used for the output of debugging messages."}]}],"TaxonomyMappings":[{"TaxonomyName":"CERT C Secure Coding","EntryID":"MSC00-C","EntryName":"Compile cleanly at high warning levels"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP1","EntryName":"Glitch in computation"}],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Community","SubmissionDate":"2006-12-15"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Potential_Mitigations, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Relationships, Other_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-07-27","ModificationComment":"updated Demonstrative_Examples, Other_Notes, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-10-29","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-27","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Applicable_Platforms, Demonstrative_Examples, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}