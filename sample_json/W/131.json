{"ID":"131","Name":"Incorrect Calculation of Buffer Size","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.","LikelihoodOfExploit":"High","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"682","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"682","ViewID":"1003","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"682","ViewID":"1305","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"682","ViewID":"1340","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"119","ViewID":"1000"}],"ApplicablePlatforms":[{"Type":"Language","Name":"C","Prevalence":"Undetermined"},{"Type":"Language","Name":"C++","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Integrity","Availability","Confidentiality"],"Impact":["DoS: Crash, Exit, or Restart","Execute Unauthorized Code or Commands","Read Memory","Modify Memory"],"Note":"If the incorrect calculation is used in the context of memory allocation, then the software may create a buffer that is smaller or larger than expected. If the allocated buffer is smaller than expected, this could lead to an out-of-bounds read or write (CWE-119), possibly causing a crash, allowing arbitrary code execution, or exposing sensitive data."}],"DetectionMethods":[{"DetectionMethodID":"DM-1","Method":"Automated Static Analysis","Description":"\n\nThis weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.\n\n\nAutomated static analysis generally does not account for environmental considerations when reporting potential errors in buffer calculations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.\n","Effectiveness":"High","EffectivenessNotes":"Detection techniques for buffer-related errors are more mature than for most other weakness types."},{"DetectionMethodID":"DM-2","Method":"Automated Dynamic Analysis","Description":"This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.","Effectiveness":"Moderate","EffectivenessNotes":"Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem."},{"DetectionMethodID":"DM-9","Method":"Manual Analysis","Description":"Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large."},{"DetectionMethodID":"DM-7","Method":"Manual Analysis","Description":"\n\nThis weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.\n\n\nSpecifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.\n","Effectiveness":"High","EffectivenessNotes":"These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules."},{"Method":"Automated Static Analysis - Binary or Bytecode","Description":"\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tBytecode Weakness Analysis - including disassembler + source code weakness analysis\n\t\tBinary Weakness Analysis - including disassembler + source code weakness analysis","Effectiveness":"High"},{"Method":"Manual Static Analysis - Binary or Bytecode","Description":"\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tBinary / Bytecode disassembler - then use manual analysis for vulnerabilities \u0026 anomalies","Effectiveness":"SOAR Partial"},{"Method":"Manual Static Analysis - Source Code","Description":"\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tCost effective for partial coverage:\n```\n\n\t\tFocused Manual Spotcheck - Focused manual analysis of source\n\t\tManual Source Code Review (not inspections)","Effectiveness":"SOAR Partial"},{"Method":"Automated Static Analysis - Source Code","Description":"\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tSource code Weakness Analyzer\n\t\tContext-configured Source Code Weakness Analyzer\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tSource Code Quality Analyzer","Effectiveness":"High"},{"Method":"Architecture or Design Review","Description":"\n\nAccording to SOAR, the following detection techniques may be useful:\n\n```\n\t\tHighly cost effective:\n```\n\n\t\tFormal Methods / Correct-By-Construction\n\t```\n\t\tCost effective for partial coverage:\n```\n\n\t\tInspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts \"\u0026\" characters to \"\u0026amp;\" for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer."},{"MitigationID":"MIT-36","Phase":["Implementation"],"Description":"\n\nUnderstand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7]\n\n\nAlso be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.\n"},{"MitigationID":"MIT-8","Phase":["Implementation"],"Strategy":"Input Validation","Description":"Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range."},{"MitigationID":"MIT-15","Phase":["Architecture and Design"],"Description":"For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."},{"Phase":["Implementation"],"Description":"When processing structured incoming data containing a size field followed by raw data, identify and resolve any inconsistencies between the size field and the actual size of the data (CWE-130)."},{"Phase":["Implementation"],"Description":"When allocating memory that uses sentinels to mark the end of a data structure - such as NUL bytes in strings - make sure you also include the sentinel in your calculation of the total amount of memory that must be allocated."},{"MitigationID":"MIT-13","Phase":["Implementation"],"Description":"Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.","Effectiveness":"Moderate","EffectivenessNotes":"This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131). Additionally, this only addresses potential overflow issues. Resource consumption / exhaustion issues are still possible."},{"Phase":["Implementation"],"Description":"Use sizeof() on the appropriate data type to avoid CWE-467."},{"Phase":["Implementation"],"Description":"Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity. This will simplify validation and will reduce surprises related to unexpected casting."},{"MitigationID":"MIT-4","Phase":["Architecture and Design"],"Strategy":"Libraries or Frameworks","Description":"\n\nUse a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.\n\n\nUse libraries or frameworks that make it easier to handle numbers without unexpected consequences, or buffer allocation routines that automatically track buffer size.\n\n\nExamples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]\n"},{"MitigationID":"MIT-10","Phase":["Operation","Build and Compilation"],"Strategy":"Environment Hardening","Description":"\n\nUse automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. \n\n\n D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"\n\n This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. \n"},{"MitigationID":"MIT-11","Phase":["Operation","Build and Compilation"],"Strategy":"Environment Hardening","Description":"\n\nRun or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. \n\n\n Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. \n\n\n For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]"},{"MitigationID":"MIT-12","Phase":["Operation"],"Strategy":"Environment Hardening","Description":"\n\n Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. \n\n\n For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. \n","Effectiveness":"Defense in Depth","EffectivenessNotes":"This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application."},{"MitigationID":"MIT-26","Phase":["Implementation"],"Strategy":"Compilation or Build Hardening","Description":"Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system."},{"MitigationID":"MIT-17","Phase":["Architecture and Design","Operation"],"Strategy":"Environment Hardening","Description":"Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."},{"MitigationID":"MIT-22","Phase":["Architecture and Design","Operation"],"Strategy":"Sandbox or Jail","Description":"\n\nRun the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.\n\n\nOS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.\n\n\nThis may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.\n\n\nBe careful to avoid CWE-243 and other weaknesses related to jails.\n","Effectiveness":"Limited","EffectivenessNotes":"The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed."}],"DemonstrativeExamples":[{"ID":"DX-20","Entries":[{"IntroText":"The following code allocates memory for a maximum number of widgets. It then gets a user-specified number of widgets, making sure that the user does not request too many. It then initializes the elements of the array using InitializeWidget(). Because the number of widgets can vary for each request, the code inserts a NULL pointer to signify the location of the last widget."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint i;\n\tunsigned int numWidgets;\n\tWidget **WidgetList;\n\tnumWidgets = GetUntrustedSizeValue();\n\tif ((numWidgets == 0) || (numWidgets \u003e MAX_NUM_WIDGETS)) {\n\t\tExitError(\"Incorrect number of widgets requested!\");\n\t}\n\tWidgetList = (Widget **)malloc(numWidgets * sizeof(Widget *));\n\tprintf(\"WidgetList ptr=%p\\n\", WidgetList);\n\tfor(i=0; i\u003cnumWidgets; i++) {\n\t\tWidgetList[i] = InitializeWidget();\n\t}\n\tWidgetList[numWidgets] = NULL;\n\tshowWidgets(WidgetList);\n```"},{"BodyText":"However, this code contains an off-by-one calculation error (CWE-193). It allocates exactly enough space to contain the specified number of widgets, but it does not include the space for the NULL pointer. As a result, the allocated buffer is smaller than it is supposed to be (CWE-131). So if the user ever requests MAX_NUM_WIDGETS, there is an out-of-bounds write (CWE-787) when the NULL is assigned. Depending on the environment and compilation settings, this could cause memory corruption."}]},{"ID":"DX-33","Entries":[{"IntroText":"The following image processing code allocates a table for images."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\timg_t table_ptr; /*struct containing img data, 10kB each*/\n\tint num_imgs;\n\t...\n\tnum_imgs = get_num_imgs();\n\ttable_ptr = (img_t*)malloc(sizeof(img_t)*num_imgs);\n\t...\n```"},{"BodyText":"This code intends to allocate a table of size num_imgs, however as num_imgs grows large, the calculation determining the size of the list will eventually overflow (CWE-190). This will result in a very small list to be allocated instead. If the subsequent code operates on the list as if it were num_imgs long, it may result in many types of out-of-bounds problems (CWE-119)."}]},{"ID":"DX-19","Entries":[{"IntroText":"This example applies an encoding procedure to an input string and stores it into a buffer."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar * copy_input(char *user_supplied_string){\n\t\t\tint i, dst_index;\n\t\t\tchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\n\t\t\tif ( MAX_SIZE \u003c= strlen(user_supplied_string) ){\n\t\t\t\tdie(\"user string too long, die evil hacker!\");\n\t\t\t}\n\t\t\tdst_index = 0;\n\t\t\tfor ( i = 0; i \u003c strlen(user_supplied_string); i++ ){\n\t\t\t\t\tif( '\u0026' == user_supplied_string[i] ){\n\t\t\t\t\t\tdst_buf[dst_index++] = '\u0026';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'a';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'm';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'p';\n\t\t\t\t\t\tdst_buf[dst_index++] = ';';\n\t\t\t\t\t}\n\t\t\t\t\telse if ('\u003c' == user_supplied_string[i] ){\n```\n/* encode to \u0026lt; */* \n\t\t\t\t\t\t\t}\n\t\t\t\t\telse dst_buf[dst_index++] = user_supplied_string[i];}\n\t\t\treturn dst_buf;}"},{"BodyText":"The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."}]},{"ID":"DX-21","Entries":[{"IntroText":"The following code is intended to read an incoming packet from a socket and extract one or more headers."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tDataPacket *packet;\n\tint numHeaders;\n\tPacketHeader *headers;\n\tsock=AcceptSocketConnection();\n\tReadPacket(packet, sock);\n\tnumHeaders =packet-\u003eheaders;\n\tif (numHeaders \u003e 100) {\n\t\tExitError(\"too many headers!\");\n\t}\n\theaders = malloc(numHeaders * sizeof(PacketHeader);\n\tParsePacketHeaders(packet, headers);\n```"},{"BodyText":"The code performs a check to make sure that the packet does not contain too many headers. However, numHeaders is defined as a signed int, so it could be negative. If the incoming packet specifies a value such as -3, then the malloc calculation will generate a negative number (say, -300 if each header can be a maximum of 100 bytes). When this result is provided to malloc(), it is first converted to a size_t type. This conversion then produces a large value such as 4294966996, which may cause malloc() to fail or to allocate an extremely large amount of memory (CWE-195). With the appropriate negative numbers, an attacker could trick malloc() into using a very small positive number, which then allocates a buffer that is much smaller than expected, potentially leading to a buffer overflow."}]},{"Entries":[{"IntroText":"The following code attempts to save three different identification numbers into an array. The array is allocated from memory using a call to malloc()."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint *id_sequence;\n```\n/* Allocate space for an array of three ids. */* \n\t\n\t\n\tid_sequence = (int*) malloc(3);\n\tif (id_sequence == NULL) exit(1);\n\t\n\t\n\t */* Populate the id array. */* \n\t\n\t\n\tid_sequence[0] = 13579;\n\tid_sequence[1] = 24680;\n\tid_sequence[2] = 97531;"},{"BodyText":"The problem with the code above is the value of the size parameter used during the malloc() call. It uses a value of '3' which by definition results in a buffer of three bytes to be created. However the intention was to create a buffer that holds three ints, and in C, each int requires 4 bytes worth of memory, so an array of 12 bytes is needed, 4 bytes for each int. Executing the above code could result in a buffer overflow as 12 bytes of data is being saved into 3 bytes worth of allocated space. The overflow would occur during the assignment of id_sequence[0] and would continue with the assignment of id_sequence[1] and id_sequence[2]."},{"BodyText":"The malloc() call could have used '3*sizeof(int)' as the value for the size parameter in order to allocate the correct amount of space required to store the three ints."}]}],"ObservedExamples":[{"Reference":"CVE-2020-17087","Description":"Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.","Link":"https://www.cve.org/CVERecord?id=CVE-2020-17087"},{"Reference":"CVE-2004-1363","Description":"substitution overflow: buffer overflow using environment variables that are expanded after the length check is performed","Link":"https://www.cve.org/CVERecord?id=CVE-2004-1363"},{"Reference":"CVE-2004-0747","Description":"substitution overflow: buffer overflow using expansion of environment variables","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0747"},{"Reference":"CVE-2005-2103","Description":"substitution overflow: buffer overflow using a large number of substitution strings","Link":"https://www.cve.org/CVERecord?id=CVE-2005-2103"},{"Reference":"CVE-2005-3120","Description":"transformation overflow: product adds extra escape characters to incoming data, but does not account for them in the buffer length","Link":"https://www.cve.org/CVERecord?id=CVE-2005-3120"},{"Reference":"CVE-2003-0899","Description":"transformation overflow: buffer overflow when expanding \"\u003e\" to \"\u0026gt;\", etc.","Link":"https://www.cve.org/CVERecord?id=CVE-2003-0899"},{"Reference":"CVE-2001-0334","Description":"expansion overflow: buffer overflow using wildcards","Link":"https://www.cve.org/CVERecord?id=CVE-2001-0334"},{"Reference":"CVE-2001-0248","Description":"expansion overflow: long pathname + glob = overflow","Link":"https://www.cve.org/CVERecord?id=CVE-2001-0248"},{"Reference":"CVE-2001-0249","Description":"expansion overflow: long pathname + glob = overflow","Link":"https://www.cve.org/CVERecord?id=CVE-2001-0249"},{"Reference":"CVE-2002-0184","Description":"special characters in argument are not properly expanded","Link":"https://www.cve.org/CVERecord?id=CVE-2002-0184"},{"Reference":"CVE-2004-0434","Description":"small length value leads to heap overflow","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0434"},{"Reference":"CVE-2002-1347","Description":"multiple variants","Link":"https://www.cve.org/CVERecord?id=CVE-2002-1347"},{"Reference":"CVE-2005-0490","Description":"needs closer investigation, but probably expansion-based","Link":"https://www.cve.org/CVERecord?id=CVE-2005-0490"},{"Reference":"CVE-2004-0940","Description":"needs closer investigation, but probably expansion-based","Link":"https://www.cve.org/CVERecord?id=CVE-2004-0940"},{"Reference":"CVE-2008-0599","Description":"Chain: Language interpreter calculates wrong buffer size (CWE-131) by using \"size = ptr ? X : Y\" instead of \"size = (ptr ? X : Y)\" expression.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-0599"}],"TaxonomyMappings":[{"TaxonomyName":"PLOVER","EntryName":"Other length calculation error"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"INT30-C","EntryName":"Ensure that unsigned integer operations do not wrap","MappingFit":"Imprecise"},{"TaxonomyName":"CERT C Secure Coding","EntryID":"MEM35-C","EntryName":"Allocate sufficient memory for an object","MappingFit":"CWE More Abstract"}],"RelatedAttackPatterns":["100","47"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"References":[{"ExternalReferenceID":"REF-106","Authors":["David LeBlanc","Niels Dekker"],"Title":"SafeInt","URL":"http://safeint.codeplex.com/"},{"ExternalReferenceID":"REF-107","Authors":["Jason Lam"],"Title":"Top 25 Series - Rank 18 - Incorrect Calculation of Buffer Size","PublicationYear":"2010","PublicationMonth":"03","PublicationDay":"19","Publisher":"SANS Software Security Institute","URL":"http://software-security.sans.org/blog/2010/03/19/top-25-series-rank-18-incorrect-calculation-of-buffer-size"},{"ExternalReferenceID":"REF-58","Authors":["Michael Howard"],"Title":"Address Space Layout Randomization in Windows Vista","URL":"https://learn.microsoft.com/en-us/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-61","Authors":["Microsoft"],"Title":"Understanding DEP as a mitigation technology part 1","URL":"https://msrc.microsoft.com/blog/2009/06/understanding-dep-as-a-mitigation-technology-part-1/","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-60","Title":"PaX","URL":"https://en.wikipedia.org/wiki/Executable_space_protection#PaX","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-76","Authors":["Sean Barnum","Michael Gegick"],"Title":"Least Privilege","PublicationYear":"2005","PublicationMonth":"09","PublicationDay":"14","URL":"https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-7","Section":"Chapter 20, \"Integer Overflows\" Page 620","Authors":["Michael Howard","David LeBlanc"],"Title":"Writing Secure Code","Edition":"2nd Edition","PublicationYear":"2002","PublicationMonth":"12","PublicationDay":"04","Publisher":"Microsoft Press","URL":"https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223"},{"ExternalReferenceID":"REF-44","Section":"\"Sin 5: Buffer Overruns.\" Page 89","Authors":["Michael Howard","David LeBlanc","John Viega"],"Title":"24 Deadly Sins of Software Security","Publication":"McGraw-Hill","PublicationYear":"2010"},{"ExternalReferenceID":"REF-62","Section":"Chapter 8, \"Incrementing Pointers Incorrectly\", Page 401","Authors":["Mark Dowd","John McDonald","Justin Schuh"],"Title":"The Art of Software Security Assessment","Edition":"1st Edition","PublicationYear":"2006","Publisher":"Addison Wesley"},{"ExternalReferenceID":"REF-64","Authors":["Grant Murphy"],"Title":"Position Independent Executables (PIE)","PublicationYear":"2012","PublicationMonth":"11","PublicationDay":"28","Publisher":"Red Hat","URL":"https://www.redhat.com/en/blog/position-independent-executables-pie","URLDate":"2023-04-07"},{"ExternalReferenceID":"REF-1332","Authors":["John Richard Moser"],"Title":"Prelink and address space randomization","PublicationYear":"2006","PublicationMonth":"07","PublicationDay":"05","URL":"https://lwn.net/Articles/190139/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1333","Authors":["Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh"],"Title":"Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR","PublicationYear":"2016","URL":"http://www.cs.ucr.edu/~nael/pubs/micro16.pdf","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1334","Authors":["D3FEND"],"Title":"Stack Frame Canary Validation (D3-SFCV)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:StackFrameCanaryValidation/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1335","Authors":["D3FEND"],"Title":"Segment Address Offset Randomization (D3-SAOR)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:SegmentAddressOffsetRandomization/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1336","Authors":["D3FEND"],"Title":"Process Segment Execution Prevention (D3-PSEP)","PublicationYear":"2023","URL":"https://d3fend.mitre.org/technique/d3f:ProcessSegmentExecutionPrevention/","URLDate":"2023-04-26"},{"ExternalReferenceID":"REF-1337","Section":"Memory information leaks","Authors":["Alexander Sotirov and Mark Dowd"],"Title":"Bypassing Browser Memory Protections: Setting back browser security by 10 years","PublicationYear":"2008","URL":"https://www.blackhat.com/presentations/bh-usa-08/Sotirov_Dowd/bh08-sotirov-dowd.pdf","URLDate":"2023-04-26"}],"Notes":[{"Type":"Maintenance","Note":"\n\nThis is a broad category. Some examples include:\n\n\n  - simple math errors,\n\n  - incorrectly updating parallel counters,\n\n  - not accounting for size differences when \"transforming\" one input to another format (e.g. URL canonicalization or other transformation that can generate a result that's larger than the original input, i.e. \"expansion\").\n\nThis level of detail is rarely available in public reports, so it is difficult to find good examples."},{"Type":"Maintenance","Note":"\n\nThis weakness may be a composite or a chain. It also may contain layering or perspective differences.\n\n\nThis issue may be associated with many different types of incorrect calculations (CWE-682), although the integer overflow (CWE-190) is probably the most prevalent. This can be primary to resource consumption problems (CWE-400), including uncontrolled memory allocation (CWE-789). However, its relationship with out-of-bounds buffer access (CWE-119) must also be considered.\n"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"PLOVER","SubmissionDate":"2006-07-19"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Potential_Mitigations, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Applicable_Platforms, Maintenance_Notes, Relationships, Taxonomy_Mappings, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-10-14","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-11-24","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-12-28","ModificationComment":"updated Demonstrative_Examples, Likelihood_of_Exploit, Observed_Examples, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-02-16","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Detection_Factors, Maintenance_Notes, Potential_Mitigations, Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-04-05","ModificationComment":"updated Detection_Factors, Potential_Mitigations, References, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-06-21","ModificationComment":"updated Common_Consequences, Detection_Factors, Potential_Mitigations, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-09-27","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2010-12-13","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-03-29","ModificationComment":"updated Maintenance_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-09-13","ModificationComment":"updated Potential_Mitigations, References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Demonstrative_Examples, Potential_Mitigations, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-10-30","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2013-02-21","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2013-07-17","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-02-18","ModificationComment":"updated Potential_Mitigations, References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Likelihood_of_Exploit, References, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2018-03-27","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Demonstrative_Examples, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-06-28","ModificationComment":"updated Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated References"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Potential_Mitigations, References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Rename","PreviousEntryName":"Other Length Calculation Error","Date":"2008-01-30"}]}