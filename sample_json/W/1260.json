{"ID":"1260","Name":"Improper Handling of Overlap Between Protected Memory Ranges","Abstraction":"Base","Structure":"Simple","Status":"Stable","Description":"The product allows address regions to overlap, which can result in the bypassing of intended memory protection.","ExtendedDescription":"\n\nIsolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.\n\n\nIf a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"284","ViewID":"1000","Ordinal":"Primary"},{"Nature":"CanPrecede","CweID":"119","ViewID":"1000","Ordinal":"Primary"}],"WeaknessOrdinalities":[{"Ordinality":"Primary"},{"Ordinality":"Resultant"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Memory Hardware","Prevalence":"Undetermined"},{"Type":"Technology","Name":"Processor Hardware","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design","Note":"Such issues could be introduced during hardware architecture and design or implementation and identified later during the Testing phase."},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability"],"Impact":["Modify Memory","Read Memory","DoS: Instability"],"Likelihood":["High"]}],"DetectionMethods":[{"Method":"Manual Analysis","Description":"Create a high privilege memory block of any arbitrary size. Attempt to create a lower privilege memory block with an overlap of the high privilege memory block. If the creation attempt works, fix the hardware. Repeat the test.","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Architecture and Design"],"Description":"\n\nEnsure that memory regions are isolated as intended and that access control (read/write) policies are used by hardware to protect privileged software.\n"},{"Phase":["Implementation"],"Description":"\n\nFor all of the programmable memory protection regions, the memory protection unit (MPU) design can define a priority scheme.\n\n\nFor example: if three memory regions can be programmed (Region_0, Region_1, and Region_2), the design can enforce a priority scheme, such that, if a system address is within multiple regions, then the region with the lowest ID takes priority and the access-control policy of that region will be applied. In some MPU designs, the priority scheme can also be programmed by trusted software.\n\n\nHardware logic or trusted firmware can also check for region definitions and block programming of memory regions with overlapping addresses. \n\n\nThe memory-access-control-check filter can also be designed to apply a policy filter to all of the overlapping ranges, i.e., if an address is within Region_0 and Region_1, then access to this address is only granted if both Region_0 and Region_1 policies allow the access.\n","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"For example, consider a design with a 16-bit address that has two software privilege levels: Privileged_SW and Non_privileged_SW. To isolate the system memory regions accessible by these two privilege levels, the design supports three memory regions: Region_0, Region_1, and Region_2.\n\n\nEach region is defined by two 32 bit registers: its range and its access policy.\n\n\n  - Address_range[15:0]: specifies the Base address of the region\n\n  - Address_range[31:16]: specifies the size of the region\n\n  - Access_policy[31:0]: specifies what types of software can access a region and which actions are allowed\n\nCertain bits of the access policy are defined symbolically as follows:\n\n  - Access_policy.read_np: if set to one, allows reads from Non_privileged_SW\n\n  - Access_policy.write_np: if set to one, allows writes from Non_privileged_SW\n\n  - Access_policy.execute_np: if set to one, allows code execution by Non_privileged_SW\n\n  - Access_policy.read_p: if set to one, allows reads from Privileged_SW\n\n  - Access_policy.write_p: if set to one, allows writes from Privileged_SW\n\n  - Access_policy.execute_p: if set to one, allows code execution by Privileged_SW\n\nFor any requests from software, an address-protection filter checks the address range and access policies for each of the three regions, and only allows software access if all three filters allow access.\n\nConsider the following goals for access control as intended by the designer:\n\n\n  - Region_0 \u0026 Region_1: registers are programmable by Privileged_SW\n\n  - Region_2: registers are programmable by Non_privileged_SW\n\nThe intention is that Non_privileged_SW cannot modify memory region and policies defined by Privileged_SW in Region_0 and Region_1. Thus, it cannot read or write the memory regions that Privileged_SW is using."},{"Nature":"Bad","ExampleCode":"Non_privileged_SW can program the Address_range register for Region_2 so that its address overlaps with the ranges defined by Region_0 or Region_1. Using this capability, it is possible for Non_privileged_SW to block any memory region from being accessed by Privileged_SW, i.e., Region_0 and Region_1."},{"BodyText":"This design could be improved in several ways."},{"Nature":"Good","ExampleCode":"Ensure that software accesses to memory regions are only permitted if all three filters permit access. Additionally, the scheme could define a memory region priority to ensure that Region_2 (the memory region defined by Non_privileged_SW) cannot overlap Region_0 or Region_1 (which are used by Privileged_SW)."}]},{"Entries":[{"IntroText":"The example code below is taken from the IOMMU controller module of the HACK@DAC'19 buggy CVA6 SoC [REF-1338]. The static memory map is composed of a set of Memory-Mapped Input/Output (MMIO) regions covering different IP agents within the SoC. Each region is defined by two 64-bit variables representing the base address and size of the memory region (XXXBase and XXXLength)."},{"BodyText":"In this example, we have 12 IP agents, and only 4 of them are called out for illustration purposes in the code snippets. Access to the AES IP MMIO region is considered privileged as it provides access to AES secret key, internal states, or decrypted data."},{"Nature":"Bad","Language":"Verilog","ExampleCode":"```\n\t... \n\t\t localparam logic[63:0] PLICLength = 64'h03FF_FFFF;\n```\nlocalparam logic[63:0] UARTLength = 64'h0011_1000;** \n\t\t\n\t\t **localparam logic[63:0] AESLength = 64'h0000_1000;** \n\t\t localparam logic[63:0] SPILength = 64'h0080_0000;\n\t\t\n\t```\n\t\t...\n\t\t typedef enum logic [63:0] {\n\t\t\t ...\n\t\t\t PLICBase = 64'h0C00_0000,\n```\nUARTBase = 64'h1000_0000,** \n\t\t\t\n\t\t\t **AESBase = 64'h1010_0000,** \n\t\t\t SPIBase = 64'h2000_0000,\n\t\t\t ..."},{"BodyText":"The vulnerable code allows the overlap between the protected MMIO region of the AES peripheral and the unprotected UART MMIO region. As a result, unprivileged users can access the protected region of the AES IP. In the given vulnerable example UART MMIO region starts at address 64'h1000_0000 and ends at address 64'h1011_1000 (UARTBase is 64'h1000_0000, and the size of the region is provided by the UARTLength of 64'h0011_1000)."},{"BodyText":"On the other hand, the AES MMIO region starts at address 64'h1010_0000 and ends at address 64'h1010_1000, which implies an overlap between the two peripherals' memory regions. Thus, any user with access to the UART can read or write the AES MMIO region, e.g., the AES secret key."},{"BodyText":"To mitigate this issue, remove the overlapping address regions by decreasing the size of the UART memory region or adjusting memory bases for all the remaining peripherals. [REF-1339]"},{"Nature":"Good","Language":"Verilog","ExampleCode":"```\n\t... \n\t\t localparam logic[63:0] PLICLength = 64'h03FF_FFFF;\n```\nlocalparam logic[63:0] UARTLength = 64'h0000_1000;** \n\t\t localparam logic[63:0] AESLength = 64'h0000_1000;\n\t\t localparam logic[63:0] SPILength = 64'h0080_0000;\n\t\t\n\t```\n\t\t...\n\t\t typedef enum logic [63:0] {\n\t\t\t ...\n\t\t\t PLICBase = 64'h0C00_0000,\n\t\t\t UARTBase = 64'h1000_0000,\n\t\t\t AESBase = 64'h1010_0000,\n\t\t\t SPIBase = 64'h2000_0000,\n\t\t\t ...\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2008-7096","Description":"virtualization product allows compromise of hardware product by accessing certain remapping registers.","Link":"https://www.cve.org/CVERecord?id=CVE-2008-7096"},{"Reference":"[REF-1100]","Description":"processor design flaw allows ring 0 code to access more privileged rings by causing a register window to overlap a range of protected system RAM [REF-1100]","Link":"https://github.com/xoreaxeaxeax/sinkhole/blob/master/us-15-Domas-TheMemorySinkhole-wp.pdf"}],"RelatedAttackPatterns":["456","679"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"References":[{"ExternalReferenceID":"REF-1100","Authors":["Christopher Domas"],"Title":"The Memory Sinkhole","PublicationYear":"2015","PublicationMonth":"07","PublicationDay":"20","URL":"https://github.com/xoreaxeaxeax/sinkhole/blob/master/us-15-Domas-TheMemorySinkhole-wp.pdf"},{"ExternalReferenceID":"REF-1338","Title":"Hackatdac19 ariane_soc_pkg.sv","PublicationYear":"2019","URL":"https://github.com/HACK-EVENT/hackatdac19/blob/619e9fb0ef32ee1e01ad76b8732a156572c65700/tb/ariane_soc_pkg.sv#L44:L62","URLDate":"2023-06-21"},{"ExternalReferenceID":"REF-1339","Authors":["Florian Zaruba","Michael Schaffner","Andreas Traber"],"Title":"csr_regfile.sv","PublicationYear":"2019","URL":"https://github.com/openhwgroup/cva6/blob/7951802a0147aedb21e8f2f6dc1e1e9c4ee857a2/src/csr_regfile.sv#L45","URLDate":"2023-06-21"}],"Notes":[{"Type":"Maintenance","Note":"As of CWE 4.6, CWE-1260 and CWE-1316 are siblings under view 1000, but CWE-1260 might be a parent of CWE-1316. More analysis is warranted."}],"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-02-10"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Demonstrative_Examples, Description, Modes_of_Introduction, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Maintenance_Notes"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-10-28","ModificationComment":"updated Demonstrative_Examples, Description, Detection_Factors, Maintenance_Notes, Observed_Examples, Relationships, Weakness_Ordinalities"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Applicable_Platforms, Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-06-28","ModificationComment":"updated Applicable_Platforms"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Demonstrative_Examples, Mapping_Notes, References"},{"Type":"Contribution","ContributionName":"Narasimha Kumar V Mangipudi","ContributionOrganization":"Lattice Semiconductor","ContributionDate":"2021-10-20","ContributionComment":"suggested content improvements","ContributionType":"Feedback"},{"Type":"Contribution","ContributionName":"Hareesh Khattri","ContributionOrganization":"Intel Corporation","ContributionDate":"2021-10-22","ContributionComment":"suggested observed examples","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Shaza Zeitoni","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Mohamadreza Rostami","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Pouya Mahmoody","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Ahmad-Reza Sadeghi","ContributionOrganization":"Technical University of Darmstadt","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Rahul Kande","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Chen Chen","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"},{"Type":"Contribution","ContributionName":"Jeyavijayan Rajendran","ContributionOrganization":"Texas A\u0026M University","ContributionDate":"2023-06-21","ContributionComment":"suggested demonstrative example","ContributionType":"Content"}]}