{"ID":"674","Name":"Uncontrolled Recursion","Abstraction":"Class","Structure":"Simple","Status":"Draft","Description":"The product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"834","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"}],"AlternateTerms":[{"Term":"Stack Exhaustion"}],"ModesOfIntroduction":[{"Phase":"Implementation","Note":"The uncontrolled recursion is often due to an improper or missing conditional"}],"CommonConsequences":[{"Scope":["Availability"],"Impact":["DoS: Resource Consumption (CPU)","DoS: Resource Consumption (Memory)"],"Note":"Resources including CPU, memory, and stack memory could be rapidly consumed or exhausted, eventually leading to an exit or crash."},{"Scope":["Confidentiality"],"Impact":["Read Application Data"],"Note":"In some cases, an application's interpreter might kill a process or thread that appears to be consuming too much resources, such as with PHP's memory_limit setting. When the interpreter kills the process/thread, it might report an error containing detailed information such as the application's installation path."}],"DetectionMethods":[{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"PotentialMitigations":[{"Phase":["Implementation"],"Description":"Ensure an end condition will be reached under all logic conditions. The end condition may include testing against the depth of recursion and exiting with an error if the recursion goes too deep. The complexity of the end condition contributes to the effectiveness of this action.","Effectiveness":"Moderate"},{"Phase":["Implementation"],"Description":"Increase the stack size.","Effectiveness":"Limited","EffectivenessNotes":"Increasing the stack size might only be a temporary measure, since the stack typically is still not very large, and it might remain easy for attackers to cause an out-of-stack fault."}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"In this example a mistake exists in the code where the exit condition contained in flg is never called. This results in the function calling itself over and over again until the stack is exhausted."},{"Nature":"Bad","Language":"C","ExampleCode":"void do_something_recursive (int flg)\n {\n\n```\n\t ... // Do some real work here, but the value of flg is unmodified\n\t if (flg) { do_something_recursive (flg); } // flg is never modified so it is always TRUE - this call will continue until the stack explodes\n }\n int flag = 1; // Set to TRUE\n do_something_recursive (flag);\n```"},{"BodyText":"Note that the only difference between the Good and Bad examples is that the recursion flag will change value and cause the recursive call to return."},{"Nature":"Good","Language":"C","ExampleCode":"void do_something_recursive (int flg)\n {\n\n```\n\t ... // Do some real work here\n\t // Modify value of flg on done condition\n\t if (flg) { do_something_recursive (flg); } // returns when flg changes to 0\n }\n int flag = 1; // Set to TRUE\n do_something_recursive (flag);\n```"}]}],"ObservedExamples":[{"Reference":"CVE-2007-1285","Description":"Deeply nested arrays trigger stack exhaustion.","Link":"https://www.cve.org/CVERecord?id=CVE-2007-1285"},{"Reference":"CVE-2007-3409","Description":"Self-referencing pointers create infinite loop and resultant stack exhaustion.","Link":"https://www.cve.org/CVERecord?id=CVE-2007-3409"},{"Reference":"CVE-2016-10707","Description":"Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.","Link":"https://www.cve.org/CVERecord?id=CVE-2016-10707"},{"Reference":"CVE-2016-3627","Description":"An attempt to recover a corrupted XML file infinite recursion protection counter was not always incremented missing the exit condition.","Link":"https://www.cve.org/CVERecord?id=CVE-2016-3627"},{"Reference":"CVE-2019-15118","Description":"USB-audio driver's descriptor code parsing allows unlimited recursion leading to stack exhaustion.","Link":"https://www.cve.org/CVERecord?id=CVE-2019-15118"}],"AffectedResources":["CPU"],"TaxonomyMappings":[{"TaxonomyName":"OWASP Top Ten 2004","EntryID":"A9","EntryName":"Denial of Service","MappingFit":"CWE More Specific"},{"TaxonomyName":"Software Fault Patterns","EntryID":"SFP13","EntryName":"Unrestricted Consumption"},{"TaxonomyName":"OMG ASCRM","EntryID":"ASCRM-CWE-674"}],"RelatedAttackPatterns":["230","231"],"MappingNotes":{"Usage":"Allowed-with-Review","Rationale":"This CWE entry is a Class and might have Base-level children that would be more appropriate","Comments":"Examine children of this entry to see if there is a better fit","Reasons":["Abstraction"]},"References":[{"ExternalReferenceID":"REF-961","Section":"ASCRM-CWE-674","Authors":["Object Management Group (OMG)"],"Title":"Automated Source Code Reliability Measure (ASCRM)","PublicationYear":"2016","PublicationMonth":"01","URL":"http://www.omg.org/spec/ASCRM/1.0/"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2008-04-11"},{"Type":"Modification","ModificationName":"Eric Dalci","ModificationOrganization":"Cigital","ModificationDate":"2008-07-01","ModificationComment":"updated Potential_Mitigations, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2008-09-08","ModificationComment":"updated Common_Consequences, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2009-03-10","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-03-29","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-10-30","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2013-02-21","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-02-18","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-07-30","ModificationComment":"updated Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Applicable_Platforms, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated References, Related_Attack_Patterns, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-06-20","ModificationComment":"updated Related_Attack_Patterns, Relationships, Type"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Related_Attack_Patterns, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Demonstrative_Examples, Description, Modes_of_Introduction, Observed_Examples, Potential_Mitigations, Time_of_Introduction"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-03-15","ModificationComment":"updated Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}