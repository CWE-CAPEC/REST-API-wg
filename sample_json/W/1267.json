{"ID":"1267","Name":"Policy Uses Obsolete Encoding","Abstraction":"Base","Structure":"Simple","Status":"Draft","Description":"The product uses an obsolete encoding mechanism to implement access controls.","ExtendedDescription":"\n\nWithin a System-On-a-Chip (SoC), various circuits and hardware engines generate transactions for the purpose of accessing (read/write) assets or performing various actions (e.g., reset, fetch, compute, etc.). Among various types of message information, a typical transaction is comprised of source identity (identifying the originator of the transaction) and a destination identity (routing the transaction to the respective entity). Sometimes the transactions are qualified with a Security Token. This Security Token helps the destination agent decide on the set of allowed actions (e.g., access to an asset for reads and writes). A policy encoder is used to map the bus transactions to Security Tokens that in turn are used as access-controls/protection mechanisms. A common weakness involves using an encoding which is no longer trusted, i.e., an obsolete encoding.\n","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"284","ViewID":"1000","Ordinal":"Primary"}],"ApplicablePlatforms":[{"Type":"Language","Class":"Not Language-Specific","Prevalence":"Undetermined"},{"Type":"Operating_System","Class":"Not OS-Specific","Prevalence":"Undetermined"},{"Type":"Architecture","Class":"Not Architecture-Specific","Prevalence":"Undetermined"},{"Type":"Technology","Class":"Not Technology-Specific","Prevalence":"Undetermined"}],"ModesOfIntroduction":[{"Phase":"Architecture and Design"},{"Phase":"Implementation"}],"CommonConsequences":[{"Scope":["Confidentiality","Integrity","Availability","Access Control"],"Impact":["Modify Memory","Read Memory","Modify Files or Directories","Read Files or Directories","DoS: Resource Consumption (Other)","Execute Unauthorized Code or Commands","Gain Privileges or Assume Identity","Bypass Protection Mechanism","Reduce Reliability"],"Likelihood":["High"]}],"PotentialMitigations":[{"Phase":["Architecture and Design","Implementation"],"Description":"\n\nSecurity Token Decoders should be reviewed for design inconsistency and common weaknesses.\n\n\nAccess and programming flows should be tested in both pre-silicon and post-silicon testing.\n","Effectiveness":"High"}],"DemonstrativeExamples":[{"Entries":[{"IntroText":"For example, consider a system that has four bus masters. The table below provides bus masters, their Security Tokens, and trust assumptions.\n\n| Bus Master | Security Token Decoding | Trust Assumptions | \n| --- | --- | --- |\n| Master_0 | \"00\" | Untrusted  |\n| Master_1 | \"01\" | Trusted  |\n| Master_2 | \"10\" | Untrusted  |\n| Master_3 | \"11\" | Untrusted  |\n\n\t\nThe policy encoding is to be defined such that Security Token will be used in implemented access-controls. The bits in the bus transaction that contain Security-Token information are Bus_transaction [15:11]. The assets are the AES-Key registers for encryption or decryption. The key of 128 bits is implemented as a set of four, 32-bit registers.\n\n\t| Register | Field description | \n| --- | --- |\n| AES_ENC_DEC_KEY_0 | AES key [0:31] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_1 | AES key [32:63] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_2 | AES key [64:95] for encryption or decryption, Default 0x00000000  |\n| AES_ENC_DEC_KEY_4 | AES key [96:127] for encryption or decryption, Default 0x00000000  |\n\n\t\t\nBelow is an example of a policy encoding scheme inherited from a previous project where all \"ODD\" numbered Security Tokens are trusted."},{"Nature":"Bad","ExampleCode":"```\n\tIf (Bus_transaction[14] == \"1\")\n\t\tTrusted = \"1\"\n\tElse\n\t\tTrusted = \"0\"\n\tIf (trusted)\n\t\tAllow access to AES-Key registers\n\tElse\n\t\tDeny access to AES-Key registers\n```"},{"BodyText":"The inherited policy encoding is obsolete and does not work for the new system where an untrusted bus master with an odd Security Token exists in the system, i.e., Master_3 whose Security Token is \"11\". Based on the old policy, the untrusted bus master (Master_3) has access to the AES-Key registers. To resolve this, a register AES_KEY_ACCESS_POLICY can be defined to provide necessary, access controls:"},{"BodyText":"New Policy: \n\n|  | \n|\n| AES_KEY_ACCESS_POLICY | [31:0] Default 0x00000002 - agent with Security Token \"1\" has access to AES_ENC_DEC_KEY_0 through AES_ENC_DEC_KEY_4 registers  |\n\n\t\nThe AES_KEY_ACCESS_POLICY register defines which agents with a Security Token in the transaction can access the AES-key registers. Each bit in this 32-bit register defines a Security Token. There could be a maximum of 32 security Tokens that are allowed access to the AES-key registers. The number of the bit when set (i.e., \"1\") allows respective action from an agent whose identity matches the number of the bit and, if \"0\" (i.e., Clear), disallows the respective action to that corresponding agent. Thus, any bus master with Security Token \"01\" is allowed access to the AES-Key registers. Below is the Pseudo Code for policy encoding:"},{"Nature":"Good","ExampleCode":"```\n\tSecurity_Token[4:0] = Bus_transaction[15:11]\n\tIf (AES_KEY_ACCESS_POLICY[Security_Token] == \"1\")\n\t\tAllow access to AES-Key registers\n\tElse\n\t\tDeny access to AES-Key registers\n```"}]}],"RelatedAttackPatterns":["121","681"],"MappingNotes":{"Usage":"Allowed","Rationale":"This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.","Comments":"Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.","Reasons":["Acceptable-Use"]},"References":[{"ExternalReferenceID":"REF-1093","Authors":["Brandon Hill"],"Title":"Huge Intel CPU Bug Allegedly Causes Kernel Memory Vulnerability With Up To 30% Performance Hit In Windows And Linux","PublicationYear":"2018","PublicationMonth":"01","PublicationDay":"02","URL":"https://hothardware.com/news/intel-cpu-bug-kernel-memory-isolation-linux-windows-macos","URLDate":"2023-04-07"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"Arun Kanuparthi, Hareesh Khattri, Parbati Kumar Manna, Narasimha Kumar V Mangipudi","SubmissionOrganization":"Intel Corporation","SubmissionDate":"2020-04-18"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Applicable_Platforms, Demonstrative_Examples, Description, Modes_of_Introduction, Potential_Mitigations"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Related_Attack_Patterns"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-10-13","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated References, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"}]}