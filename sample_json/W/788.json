{"ID":"788","Name":"Access of Memory Location After End of Buffer","Abstraction":"Base","Structure":"Simple","Status":"Incomplete","Description":"The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.","ExtendedDescription":"This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.","RelatedWeaknesses":[{"Nature":"ChildOf","CweID":"119","ViewID":"1000","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1305","Ordinal":"Primary"},{"Nature":"ChildOf","CweID":"119","ViewID":"1340","Ordinal":"Primary"}],"CommonConsequences":[{"Scope":["Confidentiality"],"Impact":["Read Memory"],"Note":"For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences."},{"Scope":["Integrity","Availability"],"Impact":["Modify Memory","DoS: Crash, Exit, or Restart"],"Note":"Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop."},{"Scope":["Integrity"],"Impact":["Modify Memory","Execute Unauthorized Code or Commands"],"Note":"If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator."}],"DetectionMethods":[{"DetectionMethodID":"DM-13","Method":"Fuzzing","Description":"Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues.","Effectiveness":"High"},{"DetectionMethodID":"DM-14","Method":"Automated Static Analysis","Description":"Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.)","Effectiveness":"High"}],"DemonstrativeExamples":[{"ID":"DX-1","Entries":[{"IntroText":"This example takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tvoid host_lookup(char *user_supplied_addr){\n\t\t\tstruct hostent *hp;\n\t\t\tin_addr_t *addr;\n\t\t\tchar hostname[64];\n\t\t\tin_addr_t inet_addr(const char *cp);\n```\n/*routine that ensures user_supplied_addr is in the right format for conversion */* \n\t\t\t\n\t\t\tvalidate_addr_form(user_supplied_addr);\n\t\t\taddr = inet_addr(user_supplied_addr);\n\t\t\thp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\n\t\t\tstrcpy(hostname, hp-\u003eh_name);}"},{"BodyText":"This function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker."},{"BodyText":"Note that this example also contains an unchecked return value (CWE-252) that can lead to a NULL pointer dereference (CWE-476)."}]},{"ID":"DX-114","Entries":[{"IntroText":"In the following example, it is possible to request that memcpy move a much larger segment of memory than assumed:"},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint returnChunkSize(void *) {\n```\n/* if chunk info is valid, return the size of usable memory,* \n\t\t\t\n\t\t\t\n\t\t\t ** else, return -1 to indicate an error* \n\t\t\t\n\t\t\t\n\t\t\t **/* \n\t\t\t...}\n\tint main() {\n\t```\n\t\t...\n\t\tmemcpy(destBuf, srcBuf, (returnChunkSize(destBuf)-1));\n\t\t...\n\t}\n```"},{"BodyText":"If returnChunkSize() happens to encounter an error it will return -1. Notice that the return value is not checked before the memcpy operation (CWE-252), so -1 can be passed as the size argument to memcpy() (CWE-805). Because memcpy() assumes that the value is unsigned, it will be interpreted as MAXINT-1 (CWE-195), and therefore will copy far more memory than is likely available to the destination buffer (CWE-787, CWE-788)."}]},{"ID":"DX-19","Entries":[{"IntroText":"This example applies an encoding procedure to an input string and stores it into a buffer."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tchar * copy_input(char *user_supplied_string){\n\t\t\tint i, dst_index;\n\t\t\tchar *dst_buf = (char*)malloc(4*sizeof(char) * MAX_SIZE);\n\t\t\tif ( MAX_SIZE \u003c= strlen(user_supplied_string) ){\n\t\t\t\tdie(\"user string too long, die evil hacker!\");\n\t\t\t}\n\t\t\tdst_index = 0;\n\t\t\tfor ( i = 0; i \u003c strlen(user_supplied_string); i++ ){\n\t\t\t\t\tif( '\u0026' == user_supplied_string[i] ){\n\t\t\t\t\t\tdst_buf[dst_index++] = '\u0026';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'a';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'm';\n\t\t\t\t\t\tdst_buf[dst_index++] = 'p';\n\t\t\t\t\t\tdst_buf[dst_index++] = ';';\n\t\t\t\t\t}\n\t\t\t\t\telse if ('\u003c' == user_supplied_string[i] ){\n```\n/* encode to \u0026lt; */* \n\t\t\t\t\t\t\t}\n\t\t\t\t\telse dst_buf[dst_index++] = user_supplied_string[i];}\n\t\t\treturn dst_buf;}"},{"BodyText":"The programmer attempts to encode the ampersand character in the user-controlled string, however the length of the string is validated before the encoding procedure is applied. Furthermore, the programmer assumes encoding expansion will only expand a given character by a factor of 4, while the encoding of the ampersand expands by 5. As a result, when the encoding procedure expands the string it is possible to overflow the destination buffer if the attacker provides a string of many ampersands."}]},{"ID":"DX-91","Entries":[{"IntroText":"In the following C/C++ example the method processMessageFromSocket() will get a message from a socket, placed into a buffer, and will parse the contents of the buffer into a structure that contains the message length and the message body. A for loop is used to copy the message body into a local character string which will be passed to another method for processing."},{"Nature":"Bad","Language":"C","ExampleCode":"```\n\tint processMessageFromSocket(int socket) {\n\t\t\tint success;\n\t\t\tchar buffer[BUFFER_SIZE];\n\t\t\tchar message[MESSAGE_SIZE];\n```\n// get message from socket and store into buffer* \n\t\t\t\n\t\t\t\n\t\t\t *//Ignoring possibliity that buffer \u003e BUFFER_SIZE* \n\t\t\tif (getMessage(socket, buffer, BUFFER_SIZE) \u003e 0) {\n\t\t\t```\n```\n// place contents of the buffer into message structure* \n\t\t\t\t\tExMessage *msg = recastBuffer(buffer);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t *// copy message body into string for processing* \n\t\t\t\t\tint index;\n\t\t\t\t\tfor (index = 0; index \u003c msg-\u003emsgLength; index++) {\n\t\t\t\t\t```\n\t\t\t\t\t\tmessage[index] = msg-\u003emsgBody[index];\n\t\t\t\t\t}\n\t\t\t\t\tmessage[index] = '\\0';\n```\n// process message* \n\t\t\t\t\tsuccess = processMessage(message);}\n\t\t\treturn success;}"},{"BodyText":"However, the message length variable from the structure is used as the condition for ending the for loop without validating that the message length variable accurately reflects the length of the message body (CWE-606). This can result in a buffer over-read (CWE-125) by reading from memory beyond the bounds of the buffer if the message length variable indicates a length that is longer than the size of a message body (CWE-130)."}]}],"ObservedExamples":[{"Reference":"CVE-2009-2550","Description":"Classic stack-based buffer overflow in media player using a long entry in a playlist","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2550"},{"Reference":"CVE-2009-2403","Description":"Heap-based buffer overflow in media player using a long entry in a playlist","Link":"https://www.cve.org/CVERecord?id=CVE-2009-2403"},{"Reference":"CVE-2009-0689","Description":"large precision value in a format string triggers overflow","Link":"https://www.cve.org/CVERecord?id=CVE-2009-0689"},{"Reference":"CVE-2009-0558","Description":"attacker-controlled array index leads to code execution","Link":"https://www.cve.org/CVERecord?id=CVE-2009-0558"},{"Reference":"CVE-2008-4113","Description":"OS kernel trusts userland-supplied length value, allowing reading of sensitive information","Link":"https://www.cve.org/CVERecord?id=CVE-2008-4113"},{"Reference":"CVE-2007-4268","Description":"Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)","Link":"https://www.cve.org/CVERecord?id=CVE-2007-4268"}],"TaxonomyMappings":[{"TaxonomyName":"OMG ASCRM","EntryID":"ASCRM-CWE-788"}],"MappingNotes":{"Usage":"Discouraged","Rationale":"The CWE entry might be misused when lower-level CWE entries might be available. It also overlaps existing CWE entries and might be deprecated in the future.","Comments":"If the \"Access\" operation is known to be a read or a write, then investigate children of entries such as CWE-787: Out-of-bounds Write and CWE-125: Out-of-bounds Read.","Reasons":["Potential Deprecation","Frequent Misuse"]},"References":[{"ExternalReferenceID":"REF-961","Section":"ASCRM-CWE-788","Authors":["Object Management Group (OMG)"],"Title":"Automated Source Code Reliability Measure (ASCRM)","PublicationYear":"2016","PublicationMonth":"01","URL":"http://www.omg.org/spec/ASCRM/1.0/"}],"ContentHistory":[{"Type":"Submission","SubmissionName":"CWE Content Team","SubmissionOrganization":"MITRE","SubmissionDate":"2009-10-21"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2011-06-01","ModificationComment":"updated Common_Consequences"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2012-05-11","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Observed_Examples, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2013-02-21","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2014-06-23","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2015-12-07","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-05-03","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2017-11-08","ModificationComment":"updated Common_Consequences, Demonstrative_Examples, Observed_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2019-01-03","ModificationComment":"updated References, Relationships, Taxonomy_Mappings"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-02-24","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-06-25","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-08-20","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2020-12-10","ModificationComment":"updated Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2021-07-20","ModificationComment":"updated Demonstrative_Examples"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2022-04-28","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-01-31","ModificationComment":"updated Description"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-04-27","ModificationComment":"updated Detection_Factors, Relationships"},{"Type":"Modification","ModificationName":"CWE Content Team","ModificationOrganization":"MITRE","ModificationDate":"2023-06-29","ModificationComment":"updated Mapping_Notes"},{"Type":"Contribution","ContributionName":"Eric Constantin Brinz","ContributionOrganization":"GENIA-SEC IT-Sicherheitsmanagement GmbH","ContributionDate":"2022-02-23","ContributionComment":"Suggested corrections to extended description.","ContributionType":"Feedback"}]}